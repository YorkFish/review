<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>区间DP on York&#39;s blog</title>
    <link>https://yorkfish.github.io/review/tags/%E5%8C%BA%E9%97%B4dp/</link>
    <description>Recent content in 区间DP on York&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy;2020 - 2021, All Rights Reserved</copyright>
    <lastBuildDate>Mon, 22 Feb 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://yorkfish.github.io/review/tags/%E5%8C%BA%E9%97%B4dp/index.xml" rel="self" type="application/rss+xml" />
    
    
    
      
      <item>
        <title>压缩编码</title>
        <link>https://yorkfish.github.io/review/blog/28-exercise-02-21/</link>
        <pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yorkfish.github.io/review/blog/28-exercise-02-21/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;活动时间：2021-02-21&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AcWing 3240&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给定一段文字，已知单词 a1,a2,,,,,an 出现的频率分别 t1,t2,&amp;hellip;,tn。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用 01 串给这些单词编码，即将每个单词与一个 01 串对应，使得任何一个单词的编码（对应的 01 串）不是另一个单词编码的前缀，这种编码称为前缀码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用前缀码编码一段文字是指将这段文字中的每个单词依次对应到其编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一段文字经过前缀编码后的长度为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L = a&lt;sub&gt;1&lt;/sub&gt; 的编码长度 x t&lt;sub&gt;1&lt;/sub&gt; + a&lt;sub&gt;2&lt;/sub&gt; 的编码长度 x t&lt;sub&gt;2&lt;/sub&gt; + &amp;hellip; + a&lt;sub&gt;n&lt;/sub&gt; 的编码长度 x t&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义一个前缀编码为字典序编码，指对于 1 &amp;lt;= i &amp;lt; n，a&lt;sub&gt;i&lt;/sub&gt; 的编码（对应的 01 串）的字典序在 a&lt;sub&gt;i+1&lt;/sub&gt; 编码之前，即 a&lt;sub&gt;1&lt;/sub&gt;,a&lt;sub&gt;2&lt;/sub&gt;,&amp;hellip;,a&lt;sub&gt;n&lt;/sub&gt; 的编码是按字典序升序排列的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如，文字 &lt;code&gt;E A E C D E B C C E C B D B E&lt;/code&gt; 中， 5 个单词 A,B,C,D,E 出现的频率分别为 1,3,4,2,5，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;则一种可行的编码方案是 &lt;code&gt;A:000&lt;/code&gt;, &lt;code&gt;B:001&lt;/code&gt;, &lt;code&gt;C:01&lt;/code&gt;, &lt;code&gt;D:10&lt;/code&gt;, &lt;code&gt;E:11&lt;/code&gt;，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应的编码后的 01 串为 &lt;code&gt;1100011011011001010111010011000111&lt;/code&gt;，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应的长度 L 为 3x1 + 3x3 + 2x4 + 2x2 + 2x5 = 34。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这个例子中，如果使用哈夫曼(Huffman)编码，对应的编码方案是 &lt;code&gt;A:000&lt;/code&gt;, &lt;code&gt;B:01&lt;/code&gt;, &lt;code&gt;C:10&lt;/code&gt;, &lt;code&gt;D:001&lt;/code&gt;, &lt;code&gt;E:11&lt;/code&gt;，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然最终文字编码后的总长度只有 33，但是这个编码不满足字典序编码的性质，比如 C 的编码的字典序不在 D 的编码之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这个例子中，有些人可能会想的另一个字典序编码是 &lt;code&gt;A:000&lt;/code&gt;, &lt;code&gt;B:001&lt;/code&gt;, &lt;code&gt;C:010&lt;/code&gt;, &lt;code&gt;D:011&lt;/code&gt;, &lt;code&gt;E:1&lt;/code&gt;，编码后的文字长度为 35。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请找出一个字典序编码，使得文字经过编码后的长度 L 最小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在输出时，你只需要输出最小的长度 L，而不需要输出具体的方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在上面的例子中，最小的长度 L 为 34。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      </item>
      
      <item>
        <title>加分二叉树</title>
        <link>https://yorkfish.github.io/review/blog/08-exercise-01-29/</link>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yorkfish.github.io/review/blog/08-exercise-01-29/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;活动时间：2021-01-29&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AcWing 479&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;orange&#34;&gt;中等&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;设一个 n 个节点的二叉树 tree 的中序遍历为 (1,2,3,&amp;hellip;,n)，其中数字 1,2,3,&amp;hellip;,n 为节点编号。&lt;/li&gt;
&lt;li&gt;每个节点都有一个分数（均为正整数），记第 i 个节点的分数为 di，&lt;/li&gt;
&lt;li&gt;tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下
&lt;ul&gt;
&lt;li&gt;subtree 的左子树的加分 x subtree 的右子树的加分 + subtree 的根的分数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若某个子树为空，规定其加分为 1。&lt;/li&gt;
&lt;li&gt;叶子的加分就是叶节点本身的分数，不考虑它的空子树。&lt;/li&gt;
&lt;li&gt;试求一棵符合中序遍历为 (1,2,3,&amp;hellip;,n) 且加分最高的二叉树 tree。&lt;/li&gt;
&lt;/ul&gt;</description>
      </item>
      
    
  </channel>
</rss>