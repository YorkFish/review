<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Huffman树 on York&#39;s blog</title>
    <link>https://yorkfish.github.io/review/tags/huffman%E6%A0%91/</link>
    <description>Recent content in Huffman树 on York&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy;2020 - 2021, All Rights Reserved</copyright>
    <lastBuildDate>Mon, 22 Feb 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://yorkfish.github.io/review/tags/huffman%E6%A0%91/index.xml" rel="self" type="application/rss+xml" />
    
    
    
      
      <item>
        <title>压缩编码</title>
        <link>https://yorkfish.github.io/review/blog/28-exercise-02-21/</link>
        <pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yorkfish.github.io/review/blog/28-exercise-02-21/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;活动时间：2021-02-21&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AcWing 3240&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给定一段文字，已知单词 a1,a2,,,,,an 出现的频率分别 t1,t2,&amp;hellip;,tn。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用 01 串给这些单词编码，即将每个单词与一个 01 串对应，使得任何一个单词的编码（对应的 01 串）不是另一个单词编码的前缀，这种编码称为前缀码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用前缀码编码一段文字是指将这段文字中的每个单词依次对应到其编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一段文字经过前缀编码后的长度为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L = a&lt;sub&gt;1&lt;/sub&gt; 的编码长度 x t&lt;sub&gt;1&lt;/sub&gt; + a&lt;sub&gt;2&lt;/sub&gt; 的编码长度 x t&lt;sub&gt;2&lt;/sub&gt; + &amp;hellip; + a&lt;sub&gt;n&lt;/sub&gt; 的编码长度 x t&lt;sub&gt;n&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义一个前缀编码为字典序编码，指对于 1 &amp;lt;= i &amp;lt; n，a&lt;sub&gt;i&lt;/sub&gt; 的编码（对应的 01 串）的字典序在 a&lt;sub&gt;i+1&lt;/sub&gt; 编码之前，即 a&lt;sub&gt;1&lt;/sub&gt;,a&lt;sub&gt;2&lt;/sub&gt;,&amp;hellip;,a&lt;sub&gt;n&lt;/sub&gt; 的编码是按字典序升序排列的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如，文字 &lt;code&gt;E A E C D E B C C E C B D B E&lt;/code&gt; 中， 5 个单词 A,B,C,D,E 出现的频率分别为 1,3,4,2,5，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;则一种可行的编码方案是 &lt;code&gt;A:000&lt;/code&gt;, &lt;code&gt;B:001&lt;/code&gt;, &lt;code&gt;C:01&lt;/code&gt;, &lt;code&gt;D:10&lt;/code&gt;, &lt;code&gt;E:11&lt;/code&gt;，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应的编码后的 01 串为 &lt;code&gt;1100011011011001010111010011000111&lt;/code&gt;，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应的长度 L 为 3x1 + 3x3 + 2x4 + 2x2 + 2x5 = 34。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这个例子中，如果使用哈夫曼(Huffman)编码，对应的编码方案是 &lt;code&gt;A:000&lt;/code&gt;, &lt;code&gt;B:01&lt;/code&gt;, &lt;code&gt;C:10&lt;/code&gt;, &lt;code&gt;D:001&lt;/code&gt;, &lt;code&gt;E:11&lt;/code&gt;，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然最终文字编码后的总长度只有 33，但是这个编码不满足字典序编码的性质，比如 C 的编码的字典序不在 D 的编码之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这个例子中，有些人可能会想的另一个字典序编码是 &lt;code&gt;A:000&lt;/code&gt;, &lt;code&gt;B:001&lt;/code&gt;, &lt;code&gt;C:010&lt;/code&gt;, &lt;code&gt;D:011&lt;/code&gt;, &lt;code&gt;E:1&lt;/code&gt;，编码后的文字长度为 35。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请找出一个字典序编码，使得文字经过编码后的长度 L 最小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在输出时，你只需要输出最小的长度 L，而不需要输出具体的方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在上面的例子中，最小的长度 L 为 34。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      </item>
      
      <item>
        <title>合并果子</title>
        <link>https://yorkfish.github.io/review/blog/21-exercise-02-13/</link>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yorkfish.github.io/review/blog/21-exercise-02-13/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;活动时间：2021-02-13&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AcWing 148&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;green&#34;&gt;简单&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。&lt;/li&gt;
&lt;li&gt;达达决定把所有的果子合成一堆。&lt;/li&gt;
&lt;li&gt;每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。&lt;/li&gt;
&lt;li&gt;可以看出，所有的果子经过 n-1 次合并之后，就只剩下一堆了。&lt;/li&gt;
&lt;li&gt;达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。&lt;/li&gt;
&lt;li&gt;因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。&lt;/li&gt;
&lt;li&gt;假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。&lt;/li&gt;
&lt;li&gt;例如有 3 种果子，数目依次为 1, 2, 9。&lt;/li&gt;
&lt;li&gt;可以先将 1, 2 堆合并，新堆数目为 3，耗费体力为 3。&lt;/li&gt;
&lt;li&gt;接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。&lt;/li&gt;
&lt;li&gt;所以达达总共耗费体力 = 3+12 = 15。&lt;/li&gt;
&lt;li&gt;可以证明 15 为最小的体力耗费值。&lt;/li&gt;
&lt;/ul&gt;</description>
      </item>
      
    
  </channel>
</rss>