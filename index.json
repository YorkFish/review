[{"content":"1. 与 \u0026amp;  若参加与运算的是负数，则以补码形式表示二进制，然后“按位与”  作用  清零 取出数中指定位 保留数中指定位  2. 或 |  对一个数据的某些位定值为 1  3. 异或 ^ 作用  使特定位翻转  说明  XOR 也是异或的意思 与 0 异或，保留原值  举例   交换两个值，不用临时变量，不担心溢出\n1 2 3  a = a ^ b; b = b ^ a; a = a ^ b;     4. 取反 作用  使某数最后一位为零，如 a = a \u0026amp; ~1;  说明  ~ 优先级比算术运算符、关系运算符、逻辑运算符（! 除外）、其他位运算符都高  5. 左移 作用  左移 n 位，即乘以 22  说明  有的 C 编译程序自动将“乘二”运算用左移实现  6. 右移  对无符号数，高位补 0 对有符号数，高位补的数与编译有关  移入 0 的称为“逻辑右移” (gcc-32bit) 移入 1 的称为“算术右移”    7. 不同长度的数据进行位运算  系统会将二者进行右端对齐 将短的正数左端补 0  例 短的负数左端不什么 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { short a = -1; // 1000 0000 0000 0001  int b = 0; // 0000 0000 0000 0000 0000 0000 0000 0000  int c = a|b; char d[32]; itoa(c, d, 2); // 将 c 的 2 进制写入 d  printf(\u0026#34;%s\\n\u0026#34;, d); // 1111 1111 1111 1111 1111 1111 1111 1111  return 0; }    负数是以补码的形式存储的，所以需要把转换 转换后的原码：0b1000 0000 0000 0000 0000 0000 0000 0001 由此可见，是把符号位移到新的最高位，然后补 0  ","description":"","id":0,"section":"c","tags":null,"title":"01 位运算简介","uri":"https://yorkfish.github.io/review/c/bit/01_overview/"},{"content":"1. 一般形式  #define 标识符 字符串 如 #define PI 3.1415926  2. 一些约定  宏名一般习惯用大写字母表示 宏定义是用宏名代替一个字符串，也就是作简单的置换，不作正确性检查 宏定义不是 C 的语句，不必在行末加分号，如果加了分号，会连分号一起进行置换 通常，#define 命令写在文件开头，函数之前，作为文件一部分，在此文件范围内有效  3. 注意事项   可以用 #undef 命令终止宏定义的作用域\n1 2 3 4 5 6 7 8 9 10 11  #define G 9.8  void main() { // ... } #undef  void f1() { // ... }     进行宏定义时可以引用已定义的宏名，可以层层置换\n  对程序中用双引号括起来的字符串内的字符，即使与宏名相同，也不进行置换\n  宏定义是专门用于预处理命令的一个专用名词，它与定义变量的含义不同，只作字符替换，不分配内存空间\n  ","description":"","id":1,"section":"c","tags":null,"title":"01. 不带参宏定义","uri":"https://yorkfish.github.io/review/c/preprocessor/01_with_no_arguments/"},{"content":"1. 简介  一个 C 程序由一个或多个程序模块组成 每个程序模块作为一个源程序文件 一个源程序文件由一个或多个函数以及其他有关内容（如命令行、数据定义等）组成 C 程序的执行，从 main 函数开始，在 main 函数中结束 所有函数都是平行的，即在定义函数时是分别进行的，是相互独立的  2. 两种角度  从用户的角度看，函数有两种  标准函数 用户自定义的函数   从函数的形式看，函数分两类  无参函数 有参函数    ","description":"","id":2,"section":"c","tags":null,"title":"01. 函数概述","uri":"https://yorkfish.github.io/review/c/function/01_overview/"},{"content":"1. 优势  正确而灵活地运用指针，可以  有效地表示复杂的数据结构 动态分配内存 方便地使用字符串 有效而方便地使用数组 调用函数时，获得一个以上的结果 直接处理内存单元地址 。。。    2. 名词解释  指针\n一个地址  能找到以它的值为地址的内存单元 一个变量的地址称为该变量的指针   指针变量  存放地址的变量 它的值是地址    ","description":"","id":3,"section":"c","tags":null,"title":"01. 指针概述","uri":"https://yorkfish.github.io/review/c/pointer/01_overview/"},{"content":"1. 分类  基本类型 构造类型 指针类型 空类型  2. 常用的基本类型    类型名 写法 缩写     短整型 short int short   整型 int /   长整型 long int long   长整型 long long int long long     一般  sizeof(short) \u0026lt; sizeof(long) sizeof(short) \u0026lt;= sizeof(int) 或 sizeof(int) \u0026lt;= sizeof(long)    ","description":"","id":4,"section":"c","tags":null,"title":"01. 数据类型","uri":"https://yorkfish.github.io/review/c/basics/01_data_type/"},{"content":"1. 简介  每个被使用的文件都在内存中开辟一个区，用来存放文件的有关信息 这些信息是保存在一个结构体变量中的 该结构体类型是由系统定义的，取名为 FILE  2. stdio.h 中的文件类型声明 1 2 3 4 5 6 7 8 9 10 11 12 13  #ifndef _FILE_DEFINED  struct _iobuf { char *_ptr; // 指向文件输入的下一个位置  int _cnt; // 当前缓冲区的相对位置  char *_base; // 文件的起始位置  int _flag; // 文件状态标志  int _file; // 用于文件的有效性验证  int _charbuf; // 检查缓冲区状况，若无缓冲区，则不读取  int _bufsiz; // 缓冲区的大小  char *_tmpfname; // 临时文件名  }; typedef struct _iobuf FILE; #define _FILE_DEFINED   ","description":"","id":5,"section":"c","tags":null,"title":"01. 文件概述","uri":"https://yorkfish.github.io/review/c/file/01_overview/"},{"content":"一般声明形式 struct 结构体名 {\r成员列表\r};\r举例 1 2 3 4 5 6 7 8  struct student { char name[20]; char addr[30]; char gender; int age; int num; float score; };   ps   不要忽略最后的分号\n  “结构体名”用作结构体类型的标志，又称“结构体标记” structure tag\n  “成员列表” member list 又称“域表” field list\n  每一个成员也称为结构体中的一个域\n  ","description":"","id":6,"section":"c","tags":null,"title":"01. 结构体概述","uri":"https://yorkfish.github.io/review/c/struct-union-enum/01_overview_of_struct/"},{"content":"1. 官方文档  Hugo_quick-start: \u0026gt; 传送门 zdoc_theme: \u0026gt; 传送门 zdoc_quickstart: \u0026gt; 传送门  2. 初始化  假设本地站点名为 hugoblog  方法一  D:\\\u0026gt;hugo new site hugoblog  方法二  新建文件夹 hugoblog D:\\hugoblog\u0026gt;hugo new site .  3. 添加主题 方法一  打开网页：https://github.com/zzossig/hugo-theme-zdoc Code -\u0026gt; Download Zip 解压并重命名为 zdoc 将 zdoc 复制到 D:\\hugoblog\\themes  方法二  D:\\hugoblog\u0026gt;git clone https://github.com/zzossig/hugo-theme-zdoc.git themes/zdoc  方法三  如果使用 git 对站点进行版本控制  D:\\hugoblog\u0026gt;git submodule add https://github.com/zzossig/hugo-theme-zdoc.git themes/zdoc   更新方式  D:\\hugoblog\u0026gt;git submodule update --remote --merge    4. 预览 exampleSite  D:\\hugoblog\u0026gt;cd themes\\zdoc\\exampleSite D:\\hugoblog\\themes\\zdoc\\exampleSite\u0026gt;hugo server --themesDir ../..  ps  D:\\hugoblog\\themes\\zdoc\\exampleSite\\content\\en\\blog 中 rich-content 因为网络原因可能报错 删除文中用双花括号包裹的语句，即可成功预览 D:\\hugoblog\\themes\\zdoc\\exampleSite\\content\\ko\\blog 中也同样处理  ","description":"preview exampleSite","id":7,"section":"hugo","tags":null,"title":"Quick start","uri":"https://yorkfish.github.io/review/hugo/hugo_01/"},{"content":"1. 打开文件 fopen 一般形式 FILE * fp;\rfp = fopen(\u0026quot;filename\u0026quot;, \u0026quot;usemode\u0026quot;);\r打开模式    文件使用方式 含义     \u0026quot;r\u0026quot; 读，打开   \u0026quot;w\u0026quot; 写，打开   \u0026quot;a\u0026quot; 追加，打开   \u0026quot;rb\u0026quot; 读，二进制打开   \u0026quot;wb\u0026quot; 写，二进制打开   \u0026quot;ab\u0026quot; 追加，二进制打开   \u0026quot;r+\u0026quot; 读写，打开   \u0026quot;w+\u0026quot; 读写，新建   \u0026quot;a+\u0026quot; 读写，打开   \u0026quot;rb+\u0026quot; 读写，二进制打开   \u0026quot;wb+\u0026quot; 读写，二进制新建   \u0026quot;ab+\u0026quot; 读写，二进制打开    说明   输入文件：从文件读数据\n  输出文件：向文件写数据\n  如果不能实现“打开”的任务，fopen 函数将会带回一个出错信息，并返回空指针值 NULL\n  出错原因可能是\n 用 \u0026quot;r\u0026quot; 方式打开一个并不存在的文件 磁盘出故障 磁盘已满，无法建立新文件 。。。    有的版本只能用 \u0026quot;r\u0026quot;, \u0026quot;w\u0026quot;, \u0026quot;a\u0026quot;\n  有的版本用 \u0026quot;rw\u0026quot;, \u0026quot;wr\u0026quot;, \u0026quot;ar\u0026quot; 代替 \u0026quot;r+\u0026quot;, \u0026quot;w+\u0026quot;, \u0026quot;a+\u0026quot;\n  在向计算机输入文本文件时，回车换行会转换为一个换行符\n  在输出时，把换行符转换成为回车和换行两个字符\n  用二进制文件时，不进行这种转换\n  在程序开始运行时，系统自动打开三个标准文件\n 标准输入 stdin 标准输出 stdout 标准出错输出 stderr    2. 关闭文件 fclose 一般形式 fclose(fp);\n说明  先把缓冲区中的数据输出到磁盘文件，然后才释放文件指针变量  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; int main() { char* filename = \u0026#34;test.txt\u0026#34;; FILE* fp = fopen(filename, \u0026#34;r\u0026#34;); if (fp == NULL) { printf(\u0026#34;cannot open %s!\\n\u0026#34;, filename); printf(\u0026#34;let me help you to build it...\\n\u0026#34;); fp = fopen(filename, \u0026#34;w\u0026#34;); } fclose(fp); return 0; }   ","description":"","id":8,"section":"c","tags":null,"title":"02. fopen() \u0026 fclose()","uri":"https://yorkfish.github.io/review/c/file/02_fopen_and_fclose/"},{"content":"例一 取某几位数  求整数 a 右端的 4~7 位  原码：xxxx ... xxxx xxxx\r位数：xxxx ... 7654 3210\r1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { short a = 666; // 0b0000 0010 1001 1010  short b = (a\u0026gt;\u0026gt;4) \u0026amp; ~(~0 \u0026lt;\u0026lt; 4); char c[4]; itoa(b, c, 2); printf(\u0026#34;%s\\n\u0026#34;, c); // 1001  return 0; }   例二 循环移位  将 a 进行右循环移位 4 位  移位前：xxxx ... xxxx x???\r移位后：???x ... xxxx xxxx\r1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { unsigned short a = 666; // 0b0000 0010 1001 1010  unsigned short b = a\u0026lt;\u0026lt;(16-4) | a\u0026gt;\u0026gt;4; char c[16]; itoa(b, c, 2); printf(\u0026#34;%s\\n\u0026#34;, c); // 1010 0000 0010 1001  return 0; }   例三 改变字节中一个或几个二进制位  将整数 a 右端的 4~7 位改为 1101  1 2 3  data = (data \u0026amp; ~(15\u0026lt;\u0026lt;4)) | (n\u0026amp;15)\u0026lt;\u0026lt;4 -------- ------ 1111 ... 0000 1111 0 \u0026lt;= n\u0026#39; \u0026lt;= 15   1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { short a = 666; // 0b0000 0010 1001 1010  short b = 0b1101; short c = (a \u0026amp; ~(15\u0026lt;\u0026lt;4)) | (b\u0026amp;15)\u0026lt;\u0026lt;4; char d[16]; itoa(c, d, 2); printf(\u0026#34;%s\\n\u0026#34;, d); // 0000 0010 1101 1010  return 0; }   ","description":"","id":9,"section":"c","tags":null,"title":"02. 举例","uri":"https://yorkfish.github.io/review/c/bit/02_examples/"},{"content":"1. 默认类型  如果在定义函数时不指定函数类型，系统会隐含指定函数类型为 int 不推荐这样做  2. 空函数   形式\n1 2  void dummy() { }     调用此函数时，什么工作也不做，没有任何实际作用\n  等以后扩充函数功能时补上\n  ","description":"","id":10,"section":"c","tags":null,"title":"02. 函数定义","uri":"https://yorkfish.github.io/review/c/function/02_general_form/"},{"content":"1. 一般形式  #define 宏名(参数表) 字符串 如  定义：#define S(a,b) a*b 使用：area = S(3, 2); // 矩形边长    2. 两个注意点 坑一 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; #define S(a,b) a*b  int main() { int area = S(5, 5+10); // 5 X 15  printf(\u0026#34;%d\\n\u0026#34;, area); // 35  return 0; }     解释\n area = S(5, 5+10); \u0026gt; area = 5*5+10; \u0026gt; area = 35;    改正\n #define S(a,b) (a)*(b)    坑二 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; #define S (a,b) a*b // S 后多了个空格  int main() { int area = S(5, 5+10); // 报错  printf(\u0026#34;%d\\n\u0026#34;, area); return 0; }    解释  宏名与带参数的括号之间不应加空格 第一个空格以后的字符都放会作为代替字符串 int area = S(5, 5+10); \u0026gt; int area = (a,b) a*b(5, 5+10); \u0026gt; 报错    3. 说明  函数调用时，先求出实参表达式的值，再带入形参 函数调用是在程序运行时处理的，为形参分配临时的内存单元 宏展开是在编译前进行的，展开时并不分配内存空间，不进行值的传递，也没有返回值的概念 对函数中的实参和形参都要定义类型，二者要求一致，如不一致，应进行类型转换 宏不存在类型问题，宏名无类型，它的参数也无类型，只是一个符号代表 展开时代入指定的字符串即可 宏定义时，字符串可以是任何类型的数据  字符：#define CHAR1 CHINA 数值：#define a 3.6 。。。    4. 取舍  通过宏展开可以得到若干个结果 使用宏次数多时，宏展开后源程序变长，因为每展开一次都使得程序增长 函数调用不会使源程序变长 宏替换不占用运行时间，只占用编译时间 函数调用占运行时间（分配单元、保留现场、值传递、返回） 一般用宏来代表简短的表达式比较合适 有些问题，用宏和函数都可以  5. 补充  可以写出各种输入输出的格式，如  单精度浮点型、双精度浮点型 长整型 十六进制整数、八进制整数 字符型 。。。   把它们单独编成一个文件，相当一个“格式库” 用 #include 命令“包括”到自己所编的程序中  ","description":"","id":11,"section":"c","tags":null,"title":"02. 带参宏定义","uri":"https://yorkfish.github.io/review/c/preprocessor/02_with_parameters/"},{"content":"1. 定义 1 2 3  int i; int * pointer_1; pointer_1 = \u0026amp;i;    将变量 i 的地址存放到指针变量 pointer_1 中，pointer_1 “指向”了变量 i 指针变量中只能存放地址（指针）  2. 两个运算符  \u0026amp;: 取地址运算符 *: 指针运算符，取指针所指向的对象的内容  ps   \u0026amp;, *, ++ 优先级相同，一般按“自右而左”方向结合\n  参照\n1 2  int num = 10; int* p = \u0026amp;num;     下方左右写法等价\n     左 右     \u0026amp;*p \u0026amp;num   *\u0026amp;num num   (*p)++ num++   *p++ *(p++)    3. 反例 例一 1 2 3 4 5 6  void swap(int* p1, int* p2) { int* temp; *temp = *p1; // 这句有问题，因为 temp 没有指向某片地址  *p1 = *p2; *p2 = *temp; }   例二 1 2 3 4 5 6  void swap(int a, int b) { int t; t = a; a = b; b = t; }    这是“单向传递”的“值传递”方式 形参值的改变不能使实参的值随之改变  例三 1 2 3 4 5 6  void swap(int* p1, int* p2) { int *p; p = p1; p1 = p2; p2 = p; }    swap 中，指针的指向对调了，但不改变实参的地址 这里不要多想，直接通过地址改值就行  ","description":"","id":12,"section":"c","tags":null,"title":"02. 指针的定义与使用","uri":"https://yorkfish.github.io/review/c/pointer/02_definition_and_use_of_pointer/"},{"content":" ANSI C 标准没有规定标识符的长度（字符个数） C 标准建议至少应能识别 31 个字符 若两个标识符很长，但不同之处在头部的可识别范围内，则编译器可辨别  ","description":"","id":13,"section":"c","tags":null,"title":"02. 标识符长度","uri":"https://yorkfish.github.io/review/c/basics/02_length_of_identifier/"},{"content":"1. 更换配置文件  删除博客根目录的 config.toml 复制 D:\\hugoblog\\themes\\zdoc\\exampleSite 的 4 个文件夹到博客根目录  ps  不复制，按照主题的说明文档依次新建也行  2. 部分结构   新的配置文件路径 D:hugoblog\\config\\_default\n  文件结构\nroot\r├── config\r│ ├── _default\r│ │ ├── config.toml\r│ │ ├── languages.toml\r│ │ ├── menus.en.toml\r│ │ ├── menus.ko.toml\r│ │ ├── params.toml\r  3. 配置 3.1 menus   删去 _default 中的 menus.en.toml, menus.ko.toml\n  新建 menus.zh.toml，并写入如下语句\n[[main]]\ridentifier = \u0026quot;hugo\u0026quot;\rname = \u0026quot;Hugo\u0026quot;\rurl = \u0026quot;hugo\u0026quot;\rweight = 1\r  3.2 cofnig  打开 cofnig.toml，依次搜索到下方四句  baseURL = \u0026quot;http://example.org\u0026quot; defaultContentLanguage = \u0026quot;en\u0026quot; hasCJKLanguage = false copyright = \u0026quot;\u0026amp;copy;{year}, All Rights Reserved\u0026quot;   修改至如下  baseURL = \u0026quot;https://yorkfish.github.io/review\u0026quot; defaultContentLanguage = \u0026quot;zh\u0026quot; hasCJKLanguage = true copyright = \u0026quot;\u0026amp;copy;2020, All Rights Reserved\u0026quot;   解释  review 是远程仓库名 zh 需要后续设置，详见下方 4. 添加语言环境 CJK 依次表示“中文”、“日文”、“韩文” 若 copyright “跨年”，可以这样：2020-{year}    3.3 languages   打开 languages.toml，并添加如下语句\n[zh]\rtitle = \u0026quot;York's blog\u0026quot;\rlanguageName = \u0026quot;中文\u0026quot;\rweight = 3\rcontentdir = \u0026quot;content\u0026quot;\r  3.4 params  打开 params.toml，依次搜索到下方三句  logoText = \u0026quot;ZDoc\u0026quot; enableLangChange = true github = \u0026quot;https://github.com/zzossig/hugo-theme-zdoc\u0026quot;   修改至如下  logoText = \u0026quot;YorkFish\u0026quot; enableLangChange = false github = \u0026quot;https://github.com/YorkFish/git_study\u0026quot;   解释  logoText 对应左上角的标题 enableLangChange 对应语言切换按钮 github 对应右上角的 GitHub 按钮    4. 添加语言环境 方法一   切换路径至 D:\\hugoblog\\themes\\zdoc\\i18n\n  新建 zh.toml，并写入如下语句\n[toc-label]\rother = \u0026quot;文章目录\u0026quot;\r[tooltip-written]\rother = \u0026quot;Written At\u0026quot;\r[tooltip-modified]\rother = \u0026quot;Modified At\u0026quot;\r[tooltip-reading-time]\rother = \u0026quot;Reading Time\u0026quot;\r[summary-dateformat]\rother = \u0026quot;2006/01/02\u0026quot;\r[reading-time]\rother = \u0026quot;min read\u0026quot;\r[single-writtenBy]\rother = \u0026quot;WRITTEN BY\u0026quot;\r[edit-this-page]\rother = \u0026quot;EDIT THIS PAGE\u0026quot;\r  方法二  在博客根目录新建文件夹 i18n 新建 zh.toml，并写入方法一的语句  ","description":"config","id":14,"section":"hugo","tags":null,"title":"Configuration","uri":"https://yorkfish.github.io/review/hugo/hugo_02/"},{"content":"1. 先声明，再定义 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; }; int main() { struct student st1; return 0; }   2. 声明的同时定义 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; } st1; int main() { return 0; }   3. 直接定义 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; struct { char name[20]; char gender; int num; } st1; int main() { return 0; }   ps   类型与变量是不同的概念\n  结构体中的成员，即域，可以单独使用\n  成员也可以是一个结构体变量\n1 2 3 4 5 6 7 8 9 10 11 12  struct date { int year; int month; int day; }; struct student { char name[20]; char gender; int num; struct date birthday; };     成员名可以与程序中的变量名相同，二者不代表同一对象\n  ","description":"","id":15,"section":"c","tags":null,"title":"02. 定义方法","uri":"https://yorkfish.github.io/review/c/struct-union-enum/02_define/"},{"content":"1. fgetc 简介  从指定的文件读入一个字符，该文件必须是以读或写方式打开的  一般形式 char ch = fgetc(fp); // fp 为文件型指针变量\n说明   如果在执行 fgetc 函数读字符时遇到文件结束符，函数返回一个结束标志 EOF，即 -1\n  EOF 不是可输出字符，因此无法打印\n  其实，EOF 就是 ASCII（扩展）表的第 255 位\n char i = -1; // 补码：0b1111 1111 =\u0026gt; 255    ANSI C 之后允许用缓冲文件系统处理二进制文件，而读入的某个字节中的二进制数据的值可能为 -1\n  ANSI C 提供了一个 feof 函数来判断文件是否真的结束\n feof(fp) == 1 =\u0026gt; 真 feof(fp) == 0 =\u0026gt; 假    例一  从一个磁盘文件顺序读入字符，并打印  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); char c = fgetc(fp); while (c != EOF) { putchar(c); c = fgetc(fp); } fclose(fp); return 0; }   例二  顺序读入一个二进制文件中的数据，并打印  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); char c; while (!feof(fp)) { c = fgetc(fp); putchar(c); } fclose(fp); return 0; }    这种方法也适用于文本文件 Windows 下，行末的回车、换行，打印时的效果是“两次回车”  2. fputc 简介  把一个字符写到磁盘文件上去  一般调用形式 fputc(ch, fp);\n说明   fputc 函数带一个返回值\n 若输出成功，返回值就是输出的字符 若输出失败，返回一个 EOF，即 -1    putchar 其实是从 fputc 派生出来的\n #define putchar(ch) fputc(ch, stdout) 作用：将 ch 的值输出到终端    例三 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;a\u0026#34;); fputc(\u0026#39;y\u0026#39;, fp); fclose(fp); return 0; }   3. 等价写法  fputc 和 putc 等价 fgetc 和 getc 等价 可以少写一个字母~  ","description":"","id":16,"section":"c","tags":null,"title":"03. fgetc() \u0026 fputc()","uri":"https://yorkfish.github.io/review/c/file/03_fgetc_and_fputc/"},{"content":"1. 作用  声明新的类型名，代替已有的类型名  2. 简介  用 typedef 可以声明各种类型名，但不能用来定义变量 #define 是在预编译时处理的，它只能作简单的字符串替换 typedef 是在编译时处理的，实际上，它不是作简单的替换 使用 typedef 有利于程序的通用与移植  如，将 typedef int INTEGER; 改为 typedef long INTEGER;    3. 举例 例一 1 2  typedef int COUNT; COUNT i, j;   例二 1 2 3 4 5 6 7 8 9  typedef struct { int year; int month; int day; } DATE, *pDate; DATE birthday; DATE* p1; pDate p2;   例三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;stdio.h\u0026gt; typedef int NUMS[10]; // 声明 NUMS 为整型数组类型  int main() { NUMS nums; // 说白了，就是让 nums 替换 \u0026#34;int NUMS[10];\u0026#34; 中的 NUMS  for (int i = 0; i \u0026lt; 10; i++) { nums[i] = i; } for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d\\n\u0026#34;, nums[i]); } return 0; }    定义的方法（不是推导，是操作步骤）  先按定义数组变量形式书写 int nums[100]; 将变量名 nums 换成自己指定的类型名 int NUMS[100]; 在前面加上 typedef 得到 typedef int NUM[100]; 用来定义变量 NUMS nums;    例四 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; typedef char * STRING; // 声明 STRING 为字符指针类型  int main() { STRING pStr1 = \u0026#34;york\u0026#34;; STRING pStr2 = \u0026#34;fish\u0026#34;; STRING s[] = {pStr1, pStr2}; printf(\u0026#34;%s\\n\u0026#34;, s[0]); printf(\u0026#34;%s\\n\u0026#34;, s[1]); return 0; }   例五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;stdio.h\u0026gt; typedef int (*POINTER)(); // 声明 POINTER 为指向函数的指针类型，该函数返回整型值  int test() { return 1; } int main() { POINTER p; p = test; printf(\u0026#34;%d\\n\u0026#34;, p()); return 0; }   ","description":"","id":17,"section":"c","tags":null,"title":"03. typedef","uri":"https://yorkfish.github.io/review/c/struct-union-enum/03_typedef/"},{"content":"1. 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int main() { int arr1[4] = {1, 2, 3, 4}; int arr2[] = {1, 2, 3, 4}; int* p1 = arr1; int* p2 = \u0026amp;arr1[0]; int arr3[5] = {0}; // 0, 0, 0, 0, 0  int arr4[5] = {1, 2, 3}; // 1, 2, 3, 0, 0  // c99, c11, c18  int arr5[10] = {[1]=2, 4, [5]=6}; // 0, 2, 4, 0, 0, 6, 0, 0, 0, 0  return 0; }   2. 使用 例一 索引 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { int arr[] = {1, 2, 3, 4}; int* p = arr; printf(\u0026#34;%d\\n\u0026#34;, arr[0]); // 1  printf(\u0026#34;%d\\n\u0026#34;, *(arr+1)); // 2  printf(\u0026#34;%d\\n\u0026#34;, p[2]); // 3  printf(\u0026#34;%d\\n\u0026#34;, *(p+3)); // 4  return 0; }    Tip: *(arr+i) 等价于 arr[i]  例二 传参 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt; void f1(int arr[], int arrSize) { for (int i = 0; i \u0026lt; arrSize; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } printf(\u0026#34;\\n\u0026#34;); } void f2(int* arr, int arrSize) { for (int i = 0; i \u0026lt; arrSize; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int arr[] = {1, 2, 3, 4}; int arrSize = 4; f1(arr, arrSize); f2(arr, arrSize); return 0; }    Tip: f(int arr[], int n) 等价于 f(int* arr, int n) C 编译都是将形参数组名作为指针变量来处理的  ","description":"","id":18,"section":"c","tags":null,"title":"03. 一维数组与指针","uri":"https://yorkfish.github.io/review/c/pointer/03_arrays_and_pointers-1/"},{"content":"1. 简介  C 语言允许在结构体中以位为单位，来指定其成员所占内存长度 这种以位为单位的成员称为“位段”或“位域” bit field 利用位段能够利用较少的位数存储数据 位段成员的类型必须指定为 unsigned 或 int  2. 举例 例一 1 2 3 4 5 6 7 8 9  struct packed_data { unsigned a: 4; unsigned b: 12; unsigned c: 8; unsigned d: 8; int i; } data; // a b c d i // (4 )(12 )(8 )(8 )(32...)    a, b, c, d 分别占 4 位，12 位，8 位，8 位 i 为整型，占 4 个字节  例二  可以使各个位段不占满一个字节  1 2 3 4 5 6 7 8  struct packed_data { unsigned a: 4; unsigned b: 12; unsigned c: 8; int i; } data; // a b c i // (4 )(12 )(8 )(xxxxxxxx)(32...)    在存储单元中，位段的分配方向因机器而异 在微机使用的 C 系统中，一般是“由右到左”进行分配的  例三  位段中的数据引用的方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;stdio.h\u0026gt; struct packed_data { unsigned a: 4; unsigned b: 12; unsigned c: 8; int i; } data; int main() { data.a = 16; data.b = 1; data.c = 2; data.i = 3; printf(\u0026#34;%d\\n\u0026#34;, data.a); // 0，有 warning  return 0; }    注意位段允许的最大值范围 a 占 4 位，最大值为 15，给多了，只截取低位  3. 新字节放位段   若某一位段要从另一个字节开始存放，可以用以下形式定义\n1 2 3 4 5 6  struct data { unsigned a: 1; //  unsigned b: 2; // 头两句是一个存储单元  unsigned : 0; unsigned c: 3; // 这是另一个存储单元 };     unsigned :0; 的作用：使下一个位段从下一个存储单元开始存放\n  上述“存储单元”可能是一个字节，也可能是两个字节，视不同的编译器而异\n  一个位段必须存储在同一单元中，不能跨两个单元\n  如果第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段\n  4. 无名位段 1 2 3 4 5 6  struct data { unsigned a: 1; unsigned : 2; // 这两位空间不用，此为“无名位段”  unsigned b: 3; unsigned c: 4; };    位段的长度不能大于存储单元的长度，也不能定义位段数组 位段可以用整型格式符输出，例如  printf(\u0026quot;%d, %d, %d\\n\u0026quot;, data.a, data.b, data.c); 也可以用 %u, %o, %x 等格式符输出   位段可以在数值表达式中引用，它会被系统自动地转换成整型数，例如  int num = data.a + 5/data.b;    ","description":"","id":19,"section":"c","tags":null,"title":"03. 位段","uri":"https://yorkfish.github.io/review/c/bit/03_bit_field/"},{"content":"1. 形参  形参，在未出现函数调用时，它们并不占内存中的存储单元 只有在发生函数调用时，形参才被分配内存单元 在调用结束后，形参所占的内存空间也被释放  2. 实参  实参可以是常量、变量或表达式 实参与形参的类型应相同或复制兼容 实参向形参的数据传递是“值传递”，即单向传递 调用结束后，形参单元被释放  3. 返回值 写法  以下方两种写法等价  return z; return (z);   z 可以是一个表达式  ps  函数类型决定返回值类型 若函数值的类型和 return 语句中表达式的值不一致，则以函数类型为准  ","description":"","id":20,"section":"c","tags":null,"title":"03. 函数的参数与返回值","uri":"https://yorkfish.github.io/review/c/function/03_params_and_ret_values/"},{"content":"1. 前提  .h + .c  2. 编译  在编译时并不是对两个文件分别进行编译，然后再将它们的目标程序连接的 而是在经过编译预处理后将头文件 .h 包含到主文件中，得到一个新的源程序 然后对这个文件进行编译，得到一个目标文件 .obj 被包含的文件成为新的源文件的一部分，而单独生成目标文件  3. 约定  这种常用在文件头部的被包含的文件称为“标题文件”或“头文件”常以 .h 为后缀 用 .c 甚至不用都行，但 .h 作后缀更能表示此文件的性质  4. 优势  如果要修改程序中的一些参数，可以不修改每个程序，只需把这些参数放在一个头文件中 注意：被包含的文件修改后，凡包含此文件的所有文件都要全部重新编译  5. 说明   一个 #include 命令只能指定一个被包含文件，如果要包含 n 个，就用 n 个命令\n  如果“文件1”包含“文件2”，“文件2”要用到“文件3”，则可在“文件1”中用两个 #include\n 注意，先包含“文件3”，再包含“文件2” 不过这种情况有特殊性    \u0026lt;.h\u0026gt; -\u0026gt; 系统到存放 C 库函数头文件的目录中寻找要包含的文件，此为标准方式\n  \u0026quot;.h\u0026quot; -\u0026gt; 系统先到用户当前目录中寻找要包含的文件，若找不到，再按标准方式查找\n  使用对应方式包含可以节省时间\n  预编译后，将成为一个文件，如果 .h 中有全局变量，它在 .c 中也有效，不必用 extern 声明\n  ","description":"","id":21,"section":"c","tags":null,"title":"03. 导入","uri":"https://yorkfish.github.io/review/c/preprocessor/03_include/"},{"content":"1. 补码  数值是以补码形式存储的 正数：原码 = 反码 = 补码 负数  反码：原码除符号位，按位取反 补码：原码除符号位，按位取反再加 1    2. unsigned int  一个整数常量后面加一个字母 u 或 U，则认为是 unsigned int  例：-12345u 的存储 1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\\n\u0026#34;, -12345u); // -12345 (-1 X 12345)  printf(\u0026#34;%u\\n\u0026#34;, -12345u); // 4294954951  return 0; }     -12345 原码：0b1000 0000 0000 0000 0011 0000 0011 1001\n  -12345 反码：0b1111 1111 1111 1111 1100 1111 1100 0110\n  -12345 补码：0b1111 1111 1111 1111 1100 1111 1100 0111\n  0b11111111111111111100111111000111 = 4294954951\n  计算机先将 -12345 转换成其补码 4294954951，再按无符号数存储\n  3. long int  一个整数常量后面加一个字母 l 或 L，则认为是 long int  用法 1 2 3 4 5 6 7  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%ld\\n\u0026#34;, 1L); // %ld 是 long int 的格式字符  return 0; }   ps  使用 gcc 编译时，如果使用了 -Wall 参数，%lld 会有 warning Windows 下消除 warning 的两种方法  用 %I64d 代替 %lld 引入头文件 #include \u0026lt;inttypes.h\u0026gt;，并使用 %\u0026quot; PRId64 \u0026quot; 代替 %lld    4. 指数  形如 123e3 或 123E3，e/E 之前必须有数，之后必为整数 若 e/E 之前为小数，则小数点左边应该有且只有一位非零数字，如  5689.65 \u0026gt; 5.68965e+003    5. 浮点数 单精度  一般，一个单精度浮点数型变量只能保证 7 位有效数字  1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { float n1 = 111111.1; float n2 = 111111.1; float n3 = n1 + n2; printf(\u0026#34;%f\\n\u0026#34;, n3); // 222222.203125  return 0; }   双精度  一般，一个双精度浮点数型变量只能保证 16 位有效数字  1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { double n1 = 1111111111111.1113; double n2 = 1111111111111.1113; double n3 = n1 + n2; printf(\u0026#34;%f\\n\u0026#34;, n3); // 2222222222222.222700  return 0; }   ps  应当避免一个很大的数和一个很小的数直接相加或相减  1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { float num = 1234567.0e5f + 20.0f; printf(\u0026#34;%f\\n\u0026#34;, num); // 123456700416.000000  return 0; }   ","description":"","id":22,"section":"c","tags":null,"title":"03. 数值的表示","uri":"https://yorkfish.github.io/review/c/basics/03_representation_of_value/"},{"content":"Step1   删除 D:hugoblog\\content\u0026gt; 下的文件夹 ko, en\n  新建 _index.md，并写入如下语句\n---\rtitle: ZDoc\rdescription: Hugo ZDoc theme landing page\rdate: 2020-08-28T00:00:00+08:00\rdraft: false\rlanding:\rheight: 500\rimage: favicon/android-icon-192x192.png\rtitle:\r- YorkFish's Blog\rtext:\r- Knowledge review\rtitleColor:\rtextColor:\rspaceBetweenTitleText: 25\rbuttons:\r- link: hugo/hugo_01\rtext: GET STARTED\rcolor: primary\r---\r  Step2 single page   在 content 文件夹内新建文件夹 test\n  在 test 内新建文档 SinglePage.md，并写入如下内容\n---\rtitle: \u0026quot;Content Formats\u0026quot;\rdescription: \u0026quot;test post\u0026quot;\rdate: 2020-08-23T00:30:00+08:00\rdraft: false\rweight: 1\r---\r*Markdown here*\r  collapsible page   在 test 内新建文件夹 CollapsiblePage\n  在 CollapsiblePage 内新建文档 _index.md，并写入如下内容\n---\rtitle: \u0026quot;Collapsible Page\u0026quot;\rdescription: \u0026quot;test post index\u0026quot;\rdate: 2020-08-23T00:30:00+08:00\rdraft: false\rweight: 2\rcollapsible: true\r---\r  在 CollapsiblePage 内新建几个文档，如\n GettingStarted.md Installation.md BasicUsage.md    在各文档内写入类似如下的语句\n---\rtitle: \u0026quot;Frontmatter\u0026quot;\rdescription: \u0026quot;test post\u0026quot;\rdate: 2020-08-23T00:30:00+08:00\rdraft: false\r---\r*Markdown here*\r  在 D:\\hugoblog\\config\\_default\\menus.zh.toml 中添加如下语句\n[[main]]\ridentifier = \u0026quot;test\u0026quot;\rname = \u0026quot;Test\u0026quot;\rurl = \u0026quot;test\u0026quot;\rweight = 2\r  补充  也可以使用命令添加文档，如 D:\\hugoblog\u0026gt;hugo new about/index.zh.md  这条命令会在 D:\\hugoblog\\content 下新建文件夹 about 并在 about 内新建文档 index.zh.md    ","description":"add docs","id":23,"section":"hugo","tags":null,"title":"Make doc","uri":"https://yorkfish.github.io/review/hugo/hugo_03/"},{"content":"1. 简介  fread 和 fwrite 函数可以用来读写一个字符 因为常常需要一次读取一组数据，ANSI C 标准提出设置这两个函数，用来读写一个数据块  2. 一般形式 1 2  fread(buffer, size, count, fp); fwrite(buffer, size, count, fp);   3. 说明   buffer: 一个指针\n 对 fread 来说，它是读入数据的存放（起始）地址 对 fwrite 来说，它是要输出数据的（起始）地址    size: 要读写的字节数\n  count: 要读写多少次 size 字节的数据像\n  fp: 文件型指针\n  如果文件以二进制形式打开，用 fread 和 fwrite 函数就可以读写任何类型的信息\n  4. 举例 例一 写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); float nums[5] = {11.0, 12.0, 13.0, 14.0, 15.0}; int fsize = sizeof(float); for (int i = 0; i \u0026lt; 5; i++) { if (fwrite(\u0026amp;nums[i], fsize, 1, fp) != 1) { printf(\u0026#34;file write error!\\n\u0026#34;); exit(0); } } fclose(fp); return 0; }   例二 读出 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); float nums[5]; int fsize = sizeof(float); for (int i = 0; i \u0026lt; 5; i++) { fread(\u0026amp;nums[i], fsize, 1, fp); printf(\u0026#34;%f\\n\u0026#34;, nums[i]); } fclose(fp); return 0; }   ps  上面的例子不用二进制 (wb, rb) 也能成功，但  一来，不推荐 二来，程序还是会以二进制运行    ","description":"","id":24,"section":"c","tags":null,"title":"04. fread() \u0026 fwrite()","uri":"https://yorkfish.github.io/review/c/file/04_fread_and_fwrite/"},{"content":"1. 多个实参的求值顺序  有的编译器自右向左 有的编译器自左向右 应当避免这种容易混淆的用法  2. 编译器的检查  只检查参数个数和参数类型，而不检查参数名 对形参数组大小不做检查，只是将实参数组的首元素的地址传给形参数组 不检查（数组）第一维的大小  ","description":"","id":25,"section":"c","tags":null,"title":"04. 函数的调用","uri":"https://yorkfish.github.io/review/c/function/04_function_call/"},{"content":"1. 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14  int arr1[3][4] = { {10, 11, 12, 13}, {14, 15, 16, 17}, {18, 19, 20, 21}}; int arr2[][4] = { {10, 11, 12, 13}, {14, 15, 16, 17}, {18, 19, 20, 21}}; int arr3[][4] = { {10}, {14, 15}, {18, 19, 20}};    Tip: 指针尽量用 p[i] 的形式，这样就省了下文的唠叨  2. 不同写法    表示形式 含义     arr 二维数组名，首行首地址   *arr, *(arr+0), arr[0], \u0026amp;*(arr[0] + 0), \u0026amp;arr[0][0] 首行首列地址   arr+1, \u0026amp;*(arr+1), \u0026amp;arr[1] 1 行首地址   *(arr+1), arr[1], \u0026amp;*(arr[1] + 0), \u0026amp;arr[1][0] 1 行首列地址   *(arr+1)+2, arr[1]+2, \u0026amp;*(arr[1]+2), \u0026amp;arr[1][2] 1 行 2 列元素 arr[1][2] 的地址   *(*(arr+1)+2), *(arr[1]+2), arr[1][2] 1 行 2 列元素 arr[1][2] 的值     Tip  *(arr+i) 等价于 arr[i] \u0026amp; 与 * 可以消掉    *(arr+1) 与 arr+1  *(arr+1) 就是 arr[1]，在二维数组中，它是一维数组名，是地址，指向 arr[1][0] arr+1 是二维数组 arr 中的 1 行首地址，也指向 arr[1][0]  指向行与指向列  二维数组名（如 arr）是指向行的 在指向行的指针之前加一个 *（如 *arr, *(arr+1)），就成了指向列的指针 在指向列的指针值前加一个 \u0026amp;（如 \u0026amp;*arr, \u0026amp;*(arr+1)），就成了指向行的指针  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int main() { int arr[][4] = { {10, 11, 12, 13}, {14, 15, 16, 17}, {18, 19, 20, 21}}; printf(\u0026#34;%p\\n\u0026#34;, arr); // 0061FEA0，每次编译分配的地址不一定相同  printf(\u0026#34;%p\\n\u0026#34;, *arr); // 0061FEA0  printf(\u0026#34;%p\\n\u0026#34;, arr[0]); // 0061FEA0, *arr \u0026gt; *(arr+0) \u0026gt; arr[0]  printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr[0]); // 0061FEA0, arr \u0026gt; \u0026amp;*(arr+0) \u0026gt; \u0026amp;arr[0]  printf(\u0026#34;%p\\n\u0026#34;, *(arr+0)+0); // 0061FEA0, arr[0]+0  printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr[0][0]); // 0061FEA0, \u0026amp;*(arr[0]+0) \u0026gt; \u0026amp;arr[0][0]  return 0; }    值一样，但概念不尽相同 不要把 \u0026amp;arr[i] 简单地理解为 arr[i] 单元的物理地址 对二维数组而言，并不存在 arr[i] 这样一个实际的变量 它只是一种地址的计算方法，能得到第 i 行的首地址  4. 说明  当 arr[i][j] 的 j 为 0 时，\u0026amp;arr[i] 和 arr[i] 值相等，即它们占同一地址 它们所指向的对象是不同的，即指针的基本类型是不同的 二维数组中，arr+i, arr[i], *(arr+i), \u0026amp;arr[i], \u0026amp;arr[i][0] 的值相等 *(*(arr+1)) 可以改写成 **(arr+1)  公式  arr[i][j] 在数组中相对位置的计算公式：i*m + j，m 为二维数组 arrnxm 的列数  arr[2][3] 可以用 *(arr + 2*m+3) 求得 arr[i][j] 的地址为 \u0026amp;arr[0][0] + sizeof(int)*(i*m+j)   由此可见，二维数组在计算机中是“一维连续”存储的  ","description":"","id":26,"section":"c","tags":null,"title":"04. 多维数组与指针","uri":"https://yorkfish.github.io/review/c/pointer/04_arrays_and_pointers-2/"},{"content":"1. 换行与回车  \\n 换行 \\r 回车  ps  以前的打字机，打满一行字后，先把纸往上卷（换行），再把纸往右拉（回车）  2. 八进制    八进制 十进制 ASCII     \\101 65 'A'    3. 字符与字符串  'a' 是字符常量，\u0026quot;a\u0026quot; 是字符串常量  字符   如果在字符变量中存放一个 128~255 间的值\n  由于在字节中最高位为 1，所以用 %d 格式符输出时，会得到负值\n1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { char c = 128; printf(\u0026#34;%d\\n\u0026#34;, c); // -128  return 0; }     字符串   C 规定以字符 '\\0' 作为字符串结束标志\n  ASCII 码为 0 的字符是 '\\0'，表示“空操作字符”\n  写字符串不必多加 '\\0'\n  字符串 \u0026quot;a\u0026quot; 实际上包含 2 个字符：'a' 和 '\\0'\n1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;a\u0026#34;; printf(\u0026#34;%d\\n\u0026#34;, strlen(str)); // 1  printf(\u0026#34;%d\\n\u0026#34;, sizeof(str)); // 2  return 0; }     ","description":"","id":27,"section":"c","tags":null,"title":"04. 字符型数据","uri":"https://yorkfish.github.io/review/c/basics/04_character_data/"},{"content":"1. 优点  采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间  2. 三种形式 形式一 1 2 3  #ifdef 标识符  // 程序段1 #endif   形式二 1 2 3 4 5  #ifdef 标识符  // 程序段1 #else  // 程序段2 #endif   形式三 1 2 3 4 5  #if 表达式  // 程序段1 #else  // 程序段2 #endif   ","description":"","id":28,"section":"c","tags":null,"title":"04. 条件编译","uri":"https://yorkfish.github.io/review/c/preprocessor/04_conditional_compilation/"},{"content":"1. 引用的方式 一般形式  结构体变量名.成员名 如：student1.num = 10010; . 是成员（分量）运算符，它在所有的运算符中优先级最高的  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef struct data { int num; } Data; typedef struct student { char name[20]; char gender; Data st_num; } Student; int main() { Student st1; strcpy(st1.name, \u0026#34;york\u0026#34;); st1.gender = \u0026#39;M\u0026#39;; st1.st_num.num = 1; printf(\u0026#34;%s\\n\u0026#34;, st1.name); printf(\u0026#34;%c\\n\u0026#34;, st1.gender); printf(\u0026#34;%d\\n\u0026#34;, st1.st_num.num); return 0; }   2. 指针的方式 一般形式  (*结构体变指针).成员名 或 结构体指针-\u0026gt;成员名 如：(*pStu).num = 10010; 或 pStu-\u0026gt;num = 10010; -\u0026gt; 是指向运算符  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef struct student { char name[20]; char gender; int num; } Student; void printInfo(Student* stu) { printf(\u0026#34;%s\\n\u0026#34;, (*stu).name); printf(\u0026#34;%c\\n\u0026#34;, stu-\u0026gt;gender); printf(\u0026#34;%d\\n\u0026#34;, stu-\u0026gt;num); } int main() { Student st1; strcpy(st1.name, \u0026#34;york\u0026#34;); st1.gender = \u0026#39;M\u0026#39;; scanf(\u0026#34;%d\u0026#34;, \u0026amp;st1.num); printInfo(\u0026amp;st1); return 0; }   ","description":"","id":29,"section":"c","tags":null,"title":"04. 结构体变量的使用","uri":"https://yorkfish.github.io/review/c/struct-union-enum/04_usage/"},{"content":"1. bulid  D:\\hugoblog\u0026gt;hugo --buildDrafts 上方命令会在博客根目录生成一个名为 public 的文件夹，里面是 hugo 生成的网页文件  ps  Hugo 与 MkDocs 不同  生成静态网页后，需要开启服务才有效果 在本地双击 index.html 能打开，但没有特效 上传到远程仓库，做好相应设置，就能正常显示了   zdoc 主题支持两种模式，我暂且称其为 docs 与 blogs  docs 模式更利于作知识的整理归纳 blogs 模式更适合写文章    2. 进入 public 文件夹  york$ git init york$ git add . york$ git commit -m \u0026quot;hugo-zdoc blog first commit\u0026quot; york$ git remote add origin git@github.com:YorkFish/review.git york$ git push -u origin master  3. 登录 github  https://github.com/YorkFish/review/settings GitHub Pages Branch -\u0026gt; /root -\u0026gt; Save  ","description":"github pages","id":30,"section":"hugo","tags":null,"title":"Deploy to the cloud","uri":"https://yorkfish.github.io/review/hugo/hugo_04/"},{"content":"1. 简介  与 scanf() 和 printf() 作用相仿 都是格式化读写函数  2. 一般调用方式 fscanf(文件指针, 格式字符串, 输出表列);\rfprintf(文件指针, 格式字符串, 输出表列);\r3. 举例 例一 写 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); fprintf(fp, \u0026#34;%d, %.2f\u0026#34;, 100, 100.5); fclose(fp); return 0; }   例二 读 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); int i; float f; fscanf(fp, \u0026#34;%d, %f\u0026#34;, \u0026amp;i, \u0026amp;f); printf(\u0026#34;%d, %f\\n\u0026#34;, i, f); fclose(fp); return 0; }   4. 说明  在输入时要将 ASCII 码转换为二进制形式 在输出时又要将二进制形式转换成字符 花费时间较多 在内存与磁盘频繁交换数据的情况下，最好使用 fread 和 fwrite  ","description":"","id":31,"section":"c","tags":null,"title":"05. fscanf() \u0026 fprintf()","uri":"https://yorkfish.github.io/review/c/file/05_fscanf_and_fprintf/"},{"content":"例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #include \u0026lt;stdio.h\u0026gt; void traverseArray(int (*arr)[5], int arrSize, int arrColSize){ for (int i = 0; i \u0026lt; arrSize; i++) { for (int j = 0; j \u0026lt; arrColSize; j++) { printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main() { int nums[][5] = { {11, 12, 13, 14, 15}, {16, 17, 18, 19, 20}, {21, 22, 23, 24, 25} }; int arrSize = 3; int arrColSize = 5; traverseArray(nums, arrSize, arrColSize); return 0; }   ps1   int (*arr)[5] 表示 arr 是一个指针变量，它指向包含 5 个整型元素的一维数组\n  *p;: 数的指针可以接一维数组 =\u0026gt; (*p)[5]: 一维数组的指针可以接二维数组\n  缺点：列数是固定的\n  注意：括号必不可少，不能写成 *arr[5]，因为 *arr[5] 相当于 *(arr[5])，是指针数组\n  ps2  *(p+2) 是 p[2]，是数组 2 行的起始地址，也是 p[2][0] 的地址 p+2 是数组 2 行的起始地址 *(p+2) 与 p+2 的值相同，但 *(p+2)+3 不能写成 (p+2)+3，因为 (p+2)+3 等价于 p+5  例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt; void traverseArray(int** arr, int arrSize, int* arrColSize){ for (int i = 0; i \u0026lt; arrSize; i++) { for (int j = 0; j \u0026lt; arrColSize[i]; j++) { printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main() { int nums[][5] = { {11, 12, 13, 14, 15}, {16, 17, 18, 19, 20}, {21, 22, 23, 24, 25} }; int* arr[] = {nums[0], nums[1], nums[2]}; int arrSize = 3; int arrColSize[] = {5, 5, 5}; traverseArray(arr, arrSize, arrColSize); return 0; }   ","description":"","id":32,"section":"c","tags":null,"title":"05. 二维数组传参","uri":"https://yorkfish.github.io/review/c/pointer/05_array_param_transfer/"},{"content":"1. 常见的情况  ! \u0026gt; 算术 \u0026gt; 关系 \u0026gt; 逻辑 \u0026gt; 赋值 \u0026gt; 逗号  算术：*, /, %, +, - 关系：\u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=, !=, == 逻辑：\u0026amp;\u0026amp;, || 赋值：= 及其扩展（如 +=） 逗号：,    2. 保险的做法  加括号  ","description":"","id":33,"section":"c","tags":null,"title":"05. 优先级","uri":"https://yorkfish.github.io/review/c/basics/05_priority/"},{"content":"1. 全局变量  全局变量“管”的是它定义之下的语句 不在必要时，不要使用全局变量 全局变量使用过多，会降低程序的清晰性  2. 局部变量  在同一个源文件中，若外部变量与局部变量同名，在局部变量的作用范围内，外部变量被“屏蔽”  3. 划分要求  在程序设计中在划分模块时要求  模块的“内聚性”强 与其他模块的“耦合性”弱   即，模块功能单一，与其他模块之间的影响小  ","description":"","id":34,"section":"c","tags":null,"title":"05. 全局变量与局部变量","uri":"https://yorkfish.github.io/review/c/function/05_global_var_and_local_var/"},{"content":"1. 定义 例一 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char name[20]; char gender; int num; } Student; int main() { Student stu[3]; return 0; }   例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; } stu1[3]; struct { char name[20]; char gender; int num; } stu2[3]; int main() { return 0; }   2. 初始化 例三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char name[20]; char gender; int num; } Student; int main() { Student stu[] = { {\u0026#34;york\u0026#34;, \u0026#39;M\u0026#39;, 1}, {\u0026#34;fish\u0026#34;, \u0026#39;M\u0026#39;, 2}, {\u0026#34;jessy\u0026#34;, \u0026#39;F\u0026#39;, 3} }; return 0; }   例四 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; } stu[3] = { {\u0026#34;york\u0026#34;, \u0026#39;M\u0026#39;, 1}, {\u0026#34;fish\u0026#34;, \u0026#39;M\u0026#39;, 2}, {\u0026#34;jessy\u0026#34;, \u0026#39;F\u0026#39;, 3} }; int main() { printf(\u0026#34;%s\\n\u0026#34;, stu[2].name); return 0; }   3. 指向结构体数组元素的指针 例五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char gender; char name[20]; int num; } Student; int main() { Student stu[3] = { {\u0026#39;M\u0026#39;, \u0026#34;york\u0026#34;, 1}, {\u0026#39;M\u0026#39;, \u0026#34;fish\u0026#34;, 2}, {\u0026#39;F\u0026#39;, \u0026#34;jessy\u0026#34;, 3} }; Student* pStu = (Student*)stu[0].name; printf(\u0026#34;%s\\n\u0026#34;, pStu+1); // fish  return 0; }    不要这样用  例六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char gender; char name[20]; int num; } Student; int main() { Student stu[3] = { {\u0026#39;M\u0026#39;, \u0026#34;york\u0026#34;, 1}, {\u0026#39;M\u0026#39;, \u0026#34;fish\u0026#34;, 2}, {\u0026#39;F\u0026#39;, \u0026#34;jessy\u0026#34;, 3} }; Student* pStu = (Student*)stu[0].num; printf(\u0026#34;%d\\n\u0026#34;, pStu); // 1  printf(\u0026#34;%d\\n\u0026#34;, pStu+1); // 29, 1 + sizeof(Student)  printf(\u0026#34;%d\\n\u0026#34;, pStu+2); // 57, 1 + sizeof(Student)*2  return 0; }    不要这样用  ","description":"","id":35,"section":"c","tags":null,"title":"05. 结构体数组","uri":"https://yorkfish.github.io/review/c/struct-union-enum/05_struct_array/"},{"content":"1. alert {{\u0026lt; alert theme=\u0026quot;warning\u0026quot; \u0026gt;}} # warning, success, info, danger\r**this** is a text\r{{\u0026lt; /alert \u0026gt;}}\rthis is \u0026ldquo;warning\u0026rdquo; this is \u0026ldquo;success\u0026rdquo; this is \u0026ldquo;info\u0026rdquo; this is \u0026ldquo;danger\u0026rdquo; 2. expand {{\u0026lt; expand \u0026quot;Expand me\u0026quot; \u0026gt;}}\rSome Markdown Contents\r{{\u0026lt; /expand \u0026gt;}}\r\r\rExpand me\r\rSome Markdown Contents\r\r 3. notice {{\u0026lt; notice success \u0026quot;This is title\u0026quot; \u0026gt;}} # success, info, warning, error\rsuccess\r{{\u0026lt; /notice \u0026gt;}}\rsuccess\r info\r warning\r error\r ","description":"主题自带的短代码","id":36,"section":"hugo","tags":null,"title":"Shortcodes","uri":"https://yorkfish.github.io/review/hugo/shortcodes/"},{"content":"1. 简介  大多数 C 编译系统都提供 getw 和 putw 用来对磁盘文件读写一个字（整数）  2. 举例 例一 使用自带的函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); putw(10, fp); fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); int i = getw(fp); printf(\u0026#34;%d\\n\u0026#34;, i); fclose(fp); return 0; }   例二 使用自定义的函数  putw 和 getw 不是 ANSI C 标准定义的函数，可以自己定义  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;stdio.h\u0026gt; int putw(int i, FILE* fp) { char* s = (char*)\u0026amp;i; putc(s[0], fp); // 指向 i 的第一个字节  putc(s[1], fp); putc(s[2], fp); putc(s[3], fp); return i; } int getw(FILE* fp) { int i; char* s = (char*)\u0026amp;i; // 使 s 指向 i 的起始地址  s[0] = getc(fp); s[1] = getc(fp); s[2] = getc(fp); s[3] = getc(fp); return i; } int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); putw(10, fp); fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); int i = getw(fp); printf(\u0026#34;%d\\n\u0026#34;, i); fclose(fp); return 0; }    int 的字节数与 char 对上就行  例三  定义一个向磁盘文件写一个实数（用二进制的方式）的函数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #include \u0026lt;stdio.h\u0026gt; void putfloat(float num, FILE* fp) { char* s = (char*)\u0026amp;num; int fsize = sizeof(float); for (int i = 0; i \u0026lt; fsize; i++) { putc(s[i], fp); // fputc  } } int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); putfloat(10.0, fp); fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); float f; fread(\u0026amp;f, sizeof(float), 1, fp); printf(\u0026#34;%f\\n\u0026#34;, f); fclose(fp); return 0; }   ","description":"","id":37,"section":"c","tags":null,"title":"06. getw() \u0026 putw()","uri":"https://yorkfish.github.io/review/c/file/06_getw_and_putw/"},{"content":"1. 两种角度  从变量的作用域（空间）角度来分  全局变量 局部变量   从变量值存在的时间（生存期）角度来分  静态存储方式 动态存储方式    2. 结构  用户区\r-----------\r| 程序区 |\r-----------\r| 静态存储区 |\r-----------\r| 动态存储区 |\r-----------\r3. 说明  自动变量：未加 static 声明的局部变量 每一个变量和函数都有两个属性  数据类型 数据的存储类别    ","description":"","id":38,"section":"c","tags":null,"title":"06. 变量的存储类别","uri":"https://yorkfish.github.io/review/c/function/06_storage_category_of_var/"},{"content":"1. 除法  如果除数或被除数中有一个为负值，则舍入的方向是不固定的 如 -5/3  有的系统：-1 （取整后向零靠拢） 有的系统：-2   C 一般是“取整后向零靠拢” Python 一般是另一种  例一 C 程序 1 2 3 4 5 6 7  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;-5 / 3 = %d ...... %d\\n\u0026#34;, -5/3, -5%-3); return 0; }    运行结果：-5 / 3 = -1 ...... -2  例二 Python 程序 1  print(\u0026#34;-5 / 3 = %d...... %d\u0026#34; % (-5//3, -5%3))    运行结果：-5 / 3 = -2 ...... 1  2. 加减乘除  如果参加四则运算的数中有 float 或 double 类型，则结果是 double 型 因为所有的 float 都按 double 进行运算  ","description":"","id":39,"section":"c","tags":null,"title":"06. 四则运算","uri":"https://yorkfish.github.io/review/c/basics/06_arithmetic/"},{"content":"1. 字符数组和字符指针变量  字符数组：只能单个更改 字符指针：只能整体更改  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { char str1[] = \u0026#34;york\u0026#34;; str1[0] = \u0026#39;Y\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, str1); char* str2 = \u0026#34;fish\u0026#34;; str2 = \u0026#34;Fish\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, str2); return 0; }   2. 指向函数的指针 一般定义形式  数据类型 (*指针变量名)(函数参数表列); 如：int (*p)(int, int);  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int max2(int a, int b) { return a\u0026lt;b? b: a; } int main() { int (*p)(int, int); p = max2; int a = 1, b = 2; int c = (*p)(a, b); printf(\u0026#34;%d\\n\u0026#34;, c); return 0; }   ps  () 优先级高于 * 函数名代表该函数的入口地址 函数指针可以用来存放函数的入口地址，它不固定指向某一函数 函数的调用可以通过函数名，也可以通过函数指针 给函数指针变量赋值时，只需给出函数名而不必给出参数 对于指向函数的指针变量，像 p+n, p++, p-- 等运算是无意义的  3. 用函数指针作函数参数 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;stdio.h\u0026gt; int max2(int a, int b) { return a\u0026lt;b? b: a; } int min2(int a, int b) { return a\u0026lt;b? a: b; } int process(int x, int y, int (*fun)(int, int)) { int res = (*fun)(x, y); return res; } int main() { int a = 1, b = 2; printf(\u0026#34;max(a, b) = %d\\n\u0026#34;, process(a, b, max2)); printf(\u0026#34;min(a, b) = %d\\n\u0026#34;, process(a, b, min2)); return 0; }   ps  这种方法是符合结构化程序设计方法原则的，是程序设计中常用的  4. 返回指针值的函数 一般定义形式  类型名* 函数名(参数表列); 如：int* test(int*, int);  ","description":"","id":40,"section":"c","tags":null,"title":"06. 字符串与指针","uri":"https://yorkfish.github.io/review/c/pointer/06_strings_and_pointers/"},{"content":"并不是简单地累加成员变量占用的大小 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include \u0026lt;stdio.h\u0026gt; struct test1 { char gender; }; struct test2 { char gender; int num; }; struct test3 { char gender; double score; }; struct test4 { char gender; int num; double score; }; struct test5 { char gender; char name[20]; }; int main() { printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test1)); // 1  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test2)); // 8  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test3)); // 16  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test4)); // 16  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test5)); // 21  return 0; }   ","description":"","id":41,"section":"c","tags":null,"title":"06. 结构体类型的大小","uri":"https://yorkfish.github.io/review/c/struct-union-enum/06_sizeof_struct/"},{"content":"1. 简介   链表可以根据需要开辟内存单元\n  链表有一个“头指针”变量\n 它存放一个地址 该地址指向一个元素    链表中每一个元素称为“结点”\n  每个结点都应包括两个部分\n 用户需要用的实际数据 下一个结点的地址    head 指向第一个元素\n  最后一个元素不再指向其他元素，它称为“表尾”，它的地址部分放一个 NULL\n  NULL 表示“空地址”，链表到此结束\n  一个指针类型的成员可以指向其他类型的结构体数据，也可以指向自己所在的结构体类型数据\n  只定义结构体，不分配存储空间，只有定义了结构体变量才分配内存单元\n  静态链表\n 所有结点都是在程序中定义的 不是临时开辟的 不能用完后释放    2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;stdio.h\u0026gt; typedef struct node { int val; struct node* next; } Node, *pNode; void traverse(pNode head) { if (head == NULL) return; while (head) { printf(\u0026#34;%d \u0026#34;, head-\u0026gt;val); head = head-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } int main() { Node n1, n2, n3; n1.val = 1; n2.val = 2; n3.val = 3; n1.next = \u0026amp;n2; n2.next = \u0026amp;n3; n3.next = NULL; traverse(\u0026amp;n1); return 0; }   ","description":"","id":42,"section":"c","tags":null,"title":"06. 链表","uri":"https://yorkfish.github.io/review/c/struct-union-enum/06_linked_list/"},{"content":"1. 关键字  auto  2. 说明  “自动变量”是函数中的局部变量 关键字可以省略，若省略，则隐含确定为“自动存储类别” 属于动态存储方式，数据存储在动态存储区中 如果不专门声明为 static 存储类别，都是动态地分配存储空间 调用该函数时，系统会给这些变量分配存储空间 调用结束时会自动释放这些存储空间  3. 举例  函数中的形参 函数中定义的变量 复合语句中定义的变量  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;stdio.h\u0026gt; // 执行完 test 函数，自动释放 num, start, stop 所占的存储单元 int test(int num) { auto int start; auto int stop = 3; for (start = 0; start \u0026lt; stop; start++) { num++; } return num; } int main() { int res = test(0); printf(\u0026#34;%d\\n\u0026#34;, res); // 3  return 0; }   ","description":"","id":43,"section":"c","tags":null,"title":"07. auto","uri":"https://yorkfish.github.io/review/c/function/07_auto/"},{"content":"1. 简介  fgets: 从指定文件读取一个字符串 fputs: 向指定文件写进一个字符串  2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); fputs(\u0026#34;China\u0026#34;, fp); // 把字符串 \u0026#34;China\u0026#34; 输出到 fp 指向的文件  fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); char str[6]; // str[5] 放 \u0026#39;\\0\u0026#39;  fgets(str, 6, fp); printf(\u0026#34;%s\\n\u0026#34;, str); fclose(fp); return 0; }   3. 说明   fputs 函数中的第一个参数可以是\n 字符串常量 字符数组 字符型指针    fgets 操作后的字符串，其末尾的 '\\0' 不输出\n 若输出成功，函数值为 0 若输出失败，函数值为 EOF    与 gets 和 puts 类似1\n gets: 输入字符串 puts: 输出字符串    fgets 和 fputs 可以指定文件\n   basic 12. gets() \u0026amp; puts() \u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":44,"section":"c","tags":null,"title":"07. fgets() \u0026 fputs()","uri":"https://yorkfish.github.io/review/c/file/07_fgets_and_fputs/"},{"content":"1. 一般定义形式 union 共用体 {\r成员表列\r} 变量表列;\r2. 说明  使几种不同的变量共占同一段内存的结构，称为“共用体” 共用体与结构体的定义形式相似，但它们的含义是不同的 结构体变量所占内存长度是各成员占的内存长度之和，每个成员分别占有其自己的内存单元 共用体变量所占内存长度等于最长的成员的长度 不能引用共用体变量，只能引用共用体变量的成员  3. 举例 例一 1 2 3 4 5 6 7  union data { int i; char ch; float f; }; union data a, b, c;   例二 1 2 3 4 5  union data { int i; char ch; float f; } a, b, c;   例三 1 2 3 4 5  union { int i; char ch; float f; } a, b, c;   ","description":"","id":45,"section":"c","tags":null,"title":"07. 共用体概述","uri":"https://yorkfish.github.io/review/c/struct-union-enum/07_overview_of_union/"},{"content":"1. 指针数组的概念 一般定义形式  类型名 * 数组名[数组长度]; 如：int * p[4];  ps  [] 比 * 优先级高 字符串比较应当用 strcmp 函数  2. 指向指针的指针 举例 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt; int main() { char* name[] = {\u0026#34;york\u0026#34;, \u0026#34;fish\u0026#34;}; char** p = name + 1; printf(\u0026#34;%p\\n\u0026#34;, name[1]); // 00404049，每次编译分配的地址不一定相同  printf(\u0026#34;%08x\\n\u0026#34;, (int)*p); // 00404049  printf(\u0026#34;%s\\n\u0026#34;, *p); // fish  return 0; }   ps  char** p; * 运算符的结合默认是从右到左，因此 **p 相当于 *(*p) 指针数组的元素只能存放地址  3. 指针数组作主函数的形参  实际上，主函数是可以有参数的，如：int main(int argc, char* argv[]) 命令行输入的形式：命令名 参数1 参数2 ... 参数n  举例 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { for (int i = 1; i \u0026lt; argc; i++) { printf(\u0026#34;%s\\n\u0026#34;, argv[i]); } return 0; }     编译命令：gcc main.c -o main\n  Input: main york fish\n  Output\nyork\rfish\r  ps  argc 是自动统计的 argv 把执行程序名也算在内  ","description":"","id":46,"section":"c","tags":null,"title":"07. 指针数组和指针的指针","uri":"https://yorkfish.github.io/review/c/pointer/07_pointer_array_and_pointer_to_pointer/"},{"content":"不推荐下文例子中的写法 1. 右结合性  即“自右向左”结合  例一  如 -i++ \u0026gt; -(i++)  1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { int i = 10; printf(\u0026#34;%d\\n\u0026#34;, -i++); // -10  printf(\u0026#34;%d\\n\u0026#34;, i); // 11  return 0; }    “负号”与 ++ 同级，默认右结合  例二 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; void func(int a, int b) { printf(\u0026#34;%d, %d\\n\u0026#34;, a, b); } int main() { int i = 10; func(i, i++); // 11, 10  return 0; }    函数的参数，从右向左“生成”  2. 左结合性  即“自左向右”结合  例三  如 i+++j \u0026gt; (i++) + j  1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { int i = 10; int j = 20; printf(\u0026#34;%d\\n\u0026#34;, i+++j); // 30  printf(\u0026#34;%d\\n\u0026#34;, i); // 11  printf(\u0026#34;%d\\n\u0026#34;, j); // 20  return 0; }    组成运算符时，尽可能多地左结合 标识符、关键字也遵循这个原则  ","description":"","id":47,"section":"c","tags":null,"title":"07. 结合方向","uri":"https://yorkfish.github.io/review/c/basics/07_combination_direction/"},{"content":"1. rewind 简介  使位置指针重新返回文件的开头 此函数没有返回值  作用  文件的位置指针重新定位于开头 feof 的值恢复为 0（假）  2. fseek 简介  对流式文件可以进行顺序读写，也可以进行随机读写 此函数可以实现改变文件的位置指针 一般用于二进制文件，因为文本文件要发生字符转换，计算位置时往往会发生混乱 可以借助此函数实现随机读写  一般形式  fseek(文件类型指针, 位移量, 起始点);     起始点 名字 代表数字     文件开始 SEEK_SET 0   当前位置 SEEK_CUR 1   文件末尾 SEEK_END 2     位移量：以“起始点”为基点，向前移动的字节数  ANSI C 和大多数 C 版本要求位移量是 long 型数据 如此，当文件的长度大于 64kb 时，不致于出问题    举例 fseek(fp, 100L, 0); // 将位置指针移到离文件头 100 个字节处\rfseek(fp, 50L, 1); // 将位置指针移到离当前位置 50 个字节处\rfseek(fp, -10L, 2); // 将位置指针从文件末尾处向后退 10 个字节\r3. ftell 简介  得到流式文件中的当前位置，用相对于文件开头的位移量来表示 如果 ftell 返回的是 -1L，表示出错  4. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); float nums[5] = {11.0, 12.0, 13.0, 14.0, 15.0}; int fsize = sizeof(float); for (int i = 0; i \u0026lt; 5; i++) { fwrite(\u0026amp;nums[i], fsize, 1, fp); } fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); float temp; long addr = ftell(fp); printf(\u0026#34;addr: %ld\\n\u0026#34;, addr); // addr: 0  fread(\u0026amp;temp, fsize, 1, fp); printf(\u0026#34;num: %f\\n\u0026#34;, temp); // num: 11.000000  fseek(fp, 12L, 1); addr = ftell(fp); printf(\u0026#34;addr: %ld\\n\u0026#34;, addr); // addr: 16  fread(\u0026amp;temp, fsize, 1, fp); printf(\u0026#34;num: %f\\n\u0026#34;, temp); // num: 15.000000  rewind(fp); addr = ftell(fp); printf(\u0026#34;addr: %ld\\n\u0026#34;, addr); // addr: 0  fread(\u0026amp;temp, fsize, 1, fp); printf(\u0026#34;num: %f\\n\u0026#34;, temp); // num: 11.000000  fclose(fp); return 0; }   ","description":"","id":48,"section":"c","tags":null,"title":"08. rewind, fseek, ftell","uri":"https://yorkfish.github.io/review/c/file/08_rewind-fseek-ftell/"},{"content":"1. 关键字  static  2. 说明  若希望函数中的局部变量在函数调用结束后继续存在，即其占用的存储单元不释放，需要用到静态局部变量 若之前调用过静态局部变量，则使用时默认为上次结束时的值 若非必要，不要多用静态变量  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; void test() { static int num = 1; printf(\u0026#34;%d\\n\u0026#34;, num); num++; } int main() { test(); // 1  test(); // 2  return 0; }   ","description":"","id":49,"section":"c","tags":null,"title":"08. static","uri":"https://yorkfish.github.io/review/c/function/08_static/"},{"content":"1. 说明  每一瞬时，只有一个成员起作用 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后，原有的成员就失效 共用体变量的地址和它的各成员的地址都是同一地址  不可行的操作  不能对共用体变量名赋值 不能企图引用变量名来得到一个值 不能在定义共用体变量时对它初始化 不能把共用体变量作为函数参数 不能使函数返回共用体变量  可行的操作  可以使用指向共用体变量的指针（与结构体变量这种用法相仿） 共用体类型可以出现在结构体类型定义中 结构体类型可以出现在共用体类型定义中 可以定义共用体数组 数组可以作为共用体的成员  2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;stdio.h\u0026gt; typedef union data { int i; char c; } Data, *pData; int main() { Data test; pData pTest = \u0026amp;test; printf(\u0026#34;%d\\n\u0026#34;, sizeof(test)); // 4  test.i = 10; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;test.i); // 0061FEC8，每次编译分配的地址不一定相同  printf(\u0026#34;%d\\n\u0026#34;, test.i); // 10  test.c = \u0026#39;y\u0026#39;; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;test.c); // 0061FEC8  printf(\u0026#34;%c\\n\u0026#34;, test.c); // y  printf(\u0026#34;%c\\n\u0026#34;, pTest-\u0026gt;c); // y  return 0; }   ","description":"","id":50,"section":"c","tags":null,"title":"08. 共用体的特点与使用","uri":"https://yorkfish.github.io/review/c/struct-union-enum/08_characteristics_of_union/"},{"content":"1. malloc 函数原型 void * malloc(unsigned int size);\n作用  在内存的动态存储区中分配一个长度为 size 的连续空间 此函数的值（即返回值），是一个分配域的起始地址，类型为 void 如果此函数未能成功执行（如内存空间不足），则返回空指针 NULL  2. calloc 函数原型 void * calloc(unsigned n, unsigned size);\n作用   在内存的动态存储中分配 n 个长度为 size 的连续空间\n  函数返回一个指向分配域起始位置的指针\n  如果分配不成功，返回 NULL\n  calloc 函数可以为一维数组开辟动态存储空间，n 为数组元素个数，每个元素长度为 size\n  3. realloc 函数原型 void *realloc(void *p, unsigned size)\n作用  重新分配由 p 指向的动态存储区 函数返回一个指向分配域起始位置的指针 如果分配不成功，返回 NULL  4. free 函数原型 void free(void * p);\n作用  释放由 p 指向的动态存储区 使这部分内存区能被其他内存使用 p 是最近一次调用 calloc 或 malloc 函数时返回的值 free 函数无返回值  5. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int** initNums(int numsSize, int* numsColSize) { int** nums = malloc(numsSize * sizeof(int*)); for (int i = 0; i \u0026lt; numsSize; i++) { nums[i] = calloc(numsColSize[i], sizeof(int)); } return nums; } void printNums(int** nums, int numsSize, int* numsColSize) { for (int i = 0; i \u0026lt; numsSize; i++) { for (int j = 0; j \u0026lt; numsColSize[i]; j++) { printf(\u0026#34;%d \u0026#34;, nums[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } void resizeNums(int** nums, int row, int resize) { realloc(nums[row], resize); } void freeNums(int** nums, int numsSize) { for (int i = 0; i \u0026lt; numsSize; i++) { free(nums[i]); } free(nums); } int main() { int numsSize = 3; int numsColSize[] = {5, 5, 5}; int** nums = initNums(numsSize, numsColSize); printNums(nums, numsSize, numsColSize); printf(\u0026#34;=========\\n\u0026#34;); numsColSize[1]++; resizeNums(nums, numsSize, numsColSize[1]); printNums(nums, numsSize, numsColSize); freeNums(nums, 3); return 0; }   ","description":"","id":51,"section":"c","tags":null,"title":"08. 动态分配内存与释放","uri":"https://yorkfish.github.io/review/c/pointer/08_malloc_calloc_realloc_free/"},{"content":"常用格式    符号 释义     %o 八进制整型数   %d 十进制整型数，%i 也行   %Ld 十进制长整型数   %u 无符号整型数   %Lu 无符号长整型数   %x 十六进制整型数   %mc 字符占 m 个宽度，右对齐   %-mc 字符占 m 个宽度，左对齐   %f 以小数形式输出单、双精度数，隐含输出 6 位小数   %e 一般，输出占 13 列   %g 根据数值的大小，自动选 f 格式或 e 格式\n选择输出占宽度较小的一种，且不输出无意义的零    ","description":"","id":52,"section":"c","tags":null,"title":"08. 输出格式","uri":"https://yorkfish.github.io/review/c/basics/08_format/"},{"content":"1. ferror 简介  除了在 getc, putc, fread, fwrite 等函数出错时有用 还可以主动使用以检查  一般形式 ferror(fp);\n说明  若返回值为 0，表示未出错 若返回一个非零值，表示出错 同一个文件每次调用输入输出函数，均产生一个新的 ferror 函数值 在调用一个输入输出函数后，应立即检查，否则信息会丢失  2. clearerr 作用  将文件错误标志和文件结束标志置为 0  说明   假设在调用一个输入输出函数时出现错误，ferror 函数值为一个非零值\n  在调用 clearerr(fp) 后，ferror(fp) 的值变为 0\n  只要出现错误标志，就一直保留，直到出现如下情况\n 对同一文件调用 clearerr 函数 对同一文件调用 rewind 函数 使用任何其他一个输入输出函数    3. 举例 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); fputs(\u0026#34;YorkFish\u0026#34;, fp); printf(\u0026#34;%d\\n\u0026#34;, ferror(fp)); // 0  fclose(fp); return 0; }   ","description":"","id":53,"section":"c","tags":null,"title":"09. ferror() \u0026 clearerr()","uri":"https://yorkfish.github.io/review/c/file/09_ferror_and_clearerr/"},{"content":" 无条件转向语句  1. 形式  goto 语句标号;  语句标号：用标识符表示，命名规则与标识符相同（字母、数字、下划线，不用数字开头） 如：goto label_1;    2. 使用  一般不用，以下两种情形可以考虑  与 if 语句构成循环结构 从循环体中跳转到循环体外  因为有 break 与 continue，goto 的使用机会不多 需要从多重循环的内层跳转到循环的外层，可以使用 goto 即使是跳出多重循环，一般也不采用 goto      3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { int i = 1, sum = 0; loop: if (i \u0026lt;= 100) { sum += i; i++; goto loop; } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; }   ","description":"","id":54,"section":"c","tags":null,"title":"09. goto","uri":"https://yorkfish.github.io/review/c/basics/09_goto/"},{"content":"1. 结论  实际上，用 register 声明变量是不必要的 如今优化的编译系统能够识别频繁的变量，从而自动地将这些变量放在寄存器中  2. 了解  由于对寄存器的存取速度远高于对内存的存取速度，因此这样做可以提高执行效率 如果需要重复运算的 n 很大，使用 register 可以节约许多执行时间 一个计算机系统中的寄存器数目是有限的 有的系统只允许将 int, char 和指针型变量定义为寄存器 局部静态变量不能定义为寄存器变量 register static int a, b, c;  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int factorial(long n) { register long ans = 1; for (int i = 2; i \u0026lt;= n; i++) { ans *= i; } return ans; } int main() { int res = factorial(19); printf(\u0026#34;%d\\n\u0026#34;, res); // 109641728  return 0; }   ","description":"","id":55,"section":"c","tags":null,"title":"09. register","uri":"https://yorkfish.github.io/review/c/function/09_register/"},{"content":"1. 常见的数据类型    定义 含义     int i 定义整型变量   int * p p 为指向整型数据的指针变量   int a[n] 定义整型数组 a，它有 n 个元素   int * p[n] 定义指针数组 p，它由 n 个指向整型数据的指针元素组成   int (*p)[n] p 为指向含 n 个元素的一维数组的指针变量   int f() f 为返回整型函数值的函数   int * p() p 为返回一个指针的函数，该指针指向整型数据   int (*p)() p 为指向函数的指针，该函数返回一个整型值   int **p p 是一个指针变量，它指向一个指向整型数据的指针变量    2. 指针运算 指针变量加减一个整数  p++ p-- p+i p-i p += i p -= i  指针变量赋值   p = \u0026amp;arr;\n  p = arr;\n  p = \u0026amp;arr[i];\n  p = max;\n  p1 = p2;\n  不应把一个整数赋给指针变量\n  不应把指针变量的值赋给一个整型变量\n  指针变量可以有空值  NULL 是整数 0，它的存储单元中所有二进位均为 0 一般，NULL 是这样定义的：#define NULL 0 系统保证 NULL 不作他用（不存放有效数据），即有效数据的指针不指向 0 单元 int* p = NULL; 与 int* p; 是两个不同的概念 任何指针变量或地址都可以与 NULL 作相等或不相等的比较  两个指针变量可以相减  两个指针变量之差是两个指针之间的元素的个数 p1 + p2 是没有意义的  两个指针变量的比较  若两个指针指向同一个数组的元素，则可以进行比较 指向前面的指针变量“小于”指向后面元素的指针变量  3. void 指针类型  (void *)p1: 将 p1 的值转换成 void * 类型 将一个函数定义为 void * 类型  函数返回的是一个地址，它指向“空类型” 可以对该函数调用得到的地址进行强制类型转换，如 char* p2 = (char*)func(str, n);    ","description":"","id":56,"section":"c","tags":null,"title":"09. 小结","uri":"https://yorkfish.github.io/review/c/pointer/09_summary/"},{"content":"1. 使用场景  如果一个变量只有几种可能的值，则可以定义为枚举类型 变量的值只限于列举出来的值的范围  2. 一般定义形式 enum weekday {sun, mon, tue, wed, thu, fri, sat};\n3. 用法 例一  C 编译中，对枚举元素按常量处理，故称枚举常量 因为是常量，所以不能像变量那样对它们赋值 枚举元素作为常量是有值的，按顺序，默认为 0, 1, 2, \u0026hellip;  1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; enum weekday {sun, mon, tue, wed, thu, fri, sat}; int main() { enum weekday weekend, workday; weekend = sun; workday = mon; printf(\u0026#34;%d, %d\\n\u0026#34;, weekend, workday); // 0, 1  return 0; }   例二  可以改变枚举元素的值  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; enum weekday { sun = 7, mon = 1, tue, wed, thu, fri, sat } weekend, workday; // tue = 2, ...  int main() { weekend = sun; workday = tue; printf(\u0026#34;%d, %d\\n\u0026#34;, weekend, workday); // 7, 2  return 0; }   例三  枚举值可以用来作判断比较 一个整数不能直接赋给一个枚举变量，需要先进行强制类型转换  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt; typedef enum weekday { sun = 7, mon = 1, tue, wed, thu, fri, sat } Weekday; int main() { Weekday weekend = sun; Weekday workday1 = (Weekday)1; // 相当于 \u0026#34;workday = tue;\u0026#34;  Weekday workday2 = (Weekday)(5-3); if (workday1) { printf(\u0026#34;%d, %d\\n\u0026#34;, weekend, workday2); // 7, 2  } return 0; }   ","description":"","id":57,"section":"c","tags":null,"title":"09. 枚举","uri":"https://yorkfish.github.io/review/c/struct-union-enum/09_enum/"},{"content":"1. 声明外部变量  一般的做法：将外部变量的定义放在引用它的所有函数之前 类型名可写可不写  写：extern int A, B; 不写：extern A, B;，会有 warning    2. 编译时的顺序  先在文本中找外部变量的定义  如果找到，就在文本文件中扩展作用域 如果找不到，就在连接时从其他文件中找外部变量的定义   若从其他文件中找外部变量的定义  如果从其他文件中找到了，就将作用域扩展到本文件 如果再找不到，就按出错处理    3. 举例 例一   main.c\n1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; extern int count; int main() { printf(\u0026#34;%d\\n\u0026#34;, count); return 0; }     test.c\n1  int count = 100;     编译命令：gcc main.c test.c -o main\n  运行结果：100\n  例二   更改例一的 test.c\n1  static int count = 100;     其他不变\n  编译结果\n undefined reference to `count'\r   解释\n 用 static 声明，只能用于本文件 这种外部变量称为“静态外部变量”    4. 使用  若干个人独立地在其设计的文件中使用相同的外部变量名，若要不受影响，就在每个文件中的外部变量前加上 static 如果其他文件不需要引用本文件的外部变量，可以对本文件中的外部变量都加上 static，成为静态外部变量，以免被其他文件误用  5. 说明   静态存储方式（存放在静态存储区中）\n  动态存储方式（存放在动态存储区中）\n  不要误认为对外部变量加 static 声明后才是静态存储方式，而不加 static 的是动态存储\n 其实加与不加都是静态存储方式 只是作用范围不同而已 都是在编译时分配内存的    ","description":"","id":58,"section":"c","tags":null,"title":"10. extern","uri":"https://yorkfish.github.io/review/c/function/10_extern/"},{"content":"1. 说明  若格式中有两个空格，应对应给到两个或更多的空格 输入数据时，遇到以下情况，认为结束  遇空格、回车、跳格键 超过指定宽度 非法输入    2. 举例 例一 因空格中断输入 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { char str[13]; scanf(\u0026#34;%s\u0026#34;, str); printf(\u0026#34;%s\\n\u0026#34;, str); return 0; }    Input: How are you? Output: How  例二 因设定值中断输入 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { char str[13]; scanf(\u0026#34;%6s\u0026#34;, str); printf(\u0026#34;%s\\n\u0026#34;, str); return 0; }    Input: How_are_you? Output: How_ar  例三 因格式不符导致结果有误 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { int a, b, c; scanf(\u0026#34;%d, %d, %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); printf(\u0026#34;a = %d, b = %d, c = %d\\n\u0026#34;, a, b, c); return 0; }    Input: 1,2,3 Output: a = 1, b = 30, c = 0 Explain: 没有按照 scanf() 中的设定输入，少了空格  ","description":"","id":59,"section":"c","tags":null,"title":"10. scanf","uri":"https://yorkfish.github.io/review/c/basics/10_scanf/"},{"content":"   分类 函数名 功能     打开文件 fopen() 打开文件   关闭文件 fclose() 关闭文件   文件定位 fseek() 改变文件位置指针的位置    rewind() 使文件位置指针重新至于文件开头    ftell() 返回文件位置指针的当前值   文件读写 fgetc(), getc() 从指定文件取得一个字符    fputc(), putc() 把字符输出到指定文件    fgets() 从指定文件读取字符串    fputs() 把字符串输出到指定文件    getw() 从指定文件读取一个字 int    putw() 把一个字 int 输出到指定文件    fread() 从指定文件中读取数据项    fwrite() 把数据项写到指定文件    fscanf() 从指定文件按格式输入数据    fprintf() 按指定格式将数据写到指定文件中   文件状态 feof() 若到文件末尾，函数值为真（非 0）    ferror() 若对文件操作出错，函数值为真    clearerr() 使 ferror 和 feof 函数值置零    ","description":"","id":60,"section":"c","tags":null,"title":"10. 小结","uri":"https://yorkfish.github.io/review/c/file/10_summary/"},{"content":"1. getchar() 说明  字符输入函数 从终端或系统隐含指定的输入设备，输入一个字符  举例 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { char c; c = getchar(); printf(\u0026#34;%c\\n\u0026#34;, c); return 0; }    Input: y Output: y  2. putchar() 说明  字符输出函数 向终端输出一个字符  举例 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { char s1 = \u0026#39;A\u0026#39;; putchar(s1); putchar(\u0026#39;B\u0026#39;); putchar(\u0026#39;\\103\u0026#39;); putchar(68); putchar(\u0026#39;\\n\u0026#39;); return 0; }     运行结果\nABCD\r  ","description":"","id":61,"section":"c","tags":null,"title":"11. getchar() \u0026 putchar()","uri":"https://yorkfish.github.io/review/c/basics/11_getchar_and_putchar/"},{"content":"1. 简介 组成  一个函数一般由两部分组成  声明部分 执行语句    声明与定义   函数的声明是函数的原型\n  函数的定义是函数的本身\n  int a; 既是声明，也是定义\n  extern a; 是声明，但不是定义\n  int a;\nstatic a; // 这样会被认为是重新定义\r 2. static 声明变量的作用  局部变量用 static 声明，则使该变量在整个程序执行期间不释放，为其分配的空间始终存在 全局变量用 static 声明，则该变量的作用域只限于本文件模块（即被声明的文件中）  3. 小结   对一个数据的定义，需要指定两种属性\n 数据类型 存储类别    使用两个关键字，如\n auto char c; static int a; register int d;    用 extern 声明变量为已定义的外部变量\n extern b; —— 声明 b 是一个已被定义的外部变量    ","description":"","id":62,"section":"c","tags":null,"title":"11. 变量的声明与定义","uri":"https://yorkfish.github.io/review/c/function/11_declaration_and_definition/"},{"content":"1. gets(字符数组) 说明  只针对一个字符串 从终端输入一个字符串到字符数组，并得到一个函数值 该函数值是字符数组的起始地址  举例 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { char str[80]; int num; printf(\u0026#34;please input a string: \u0026#34;); num = gets(str); printf(\u0026#34;\u0026gt;\u0026gt;\u0026gt; str: %s\\n\u0026#34;, str); printf(\u0026#34;\u0026gt;\u0026gt;\u0026gt; num: %d\\n\u0026#34;, num); return 0; }     运行结果\nplease input a string: york fish\r\u0026gt;\u0026gt;\u0026gt; str: york fish\r\u0026gt;\u0026gt;\u0026gt; num: 6422140\r  2. puts(字符数组) 说明  只针对一个字符串 将一个字符串（以 '\\0' 结束的字符序列）输出到终端 因为有 printf()，所以 puts() 用到不多 用 puts() 输出的字符串中可以包含转义字符 可以在输出时将字符串结束标志 '\\0' 转换成 '\\n'，即输出完字符串后换行  举例 1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { puts(\u0026#34;hello world\u0026#34;); puts(\u0026#34;york\\nfish\u0026#34;); return 0; }     运行结果\nhello world\ryork\rfish\r  ","description":"","id":63,"section":"c","tags":null,"title":"12. gets() \u0026 puts()","uri":"https://yorkfish.github.io/review/c/basics/12_gets_and_puts/"},{"content":"1. 内部函数   如果一个函数只能被本文件中其他函数所调用，它称为内部函数\n  在定义内部函数时，在函数名和函数类型的前面加 static，即\n static 类型标识符 函数名(形参表); static int fun(int a, int b);    内部函数又称静态函数\n  在不同的文件中有同名的内部函数，互不干扰\n  2. 外部函数   形如 extern int fun(int a, int b);\n  C 语言规定，如果在定义函数时省略 extern，则隐含为外部函数\n  用 extern 对函数作声明，表示该函数是其他文件中定义的外部函数\n  函数在本质上是外部的，在程序中经常要调用外部函数\n 为方便编程，C 语言允许在声明函数时省写 extern 一般也都是省写    3. 例外  如，三角函数 三角函数不是由用户在本文件中定义的，而是存放在数学函数库中的 在本文件中使用（如 sin 函数），必须写出函数的原型（如 double sin(double x);）  例一 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt; #define PI 3.14159265  double sin(double x); // sin() 函数的参数是弧度  int main() { printf(\u0026#34;%lf\\n\u0026#34;, sin(30.0 * PI/180)); // 0.500000  return 0; }    程序设计者在调用库函数时，需要先从手册中查出所用的库函数的原型 不过可以简化，如，使用头文件 math.h  例二 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;math.h\u0026gt; #define PI 3.14159265  int main() { printf(\u0026#34;%lf\\n\u0026#34;, sin(30.0 * PI/180)); return 0; }   ","description":"","id":64,"section":"c","tags":null,"title":"12. 内部函数和外部函数","uri":"https://yorkfish.github.io/review/c/function/12_internal_and_external_functions/"},{"content":"strcat(字符数组1, 字符数组2) 简介  string catenate 把“字符串2”接到“字符串1”的后面  使用 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[] = \u0026#34;abcde\u0026#34;; char str2[] = \u0026#34;123\u0026#34;; strcpy(str1, str2); printf(\u0026#34;%s\\n\u0026#34;, str1); // abcde123  return 0; }   ","description":"","id":65,"section":"c","tags":null,"title":"13. strcat()","uri":"https://yorkfish.github.io/review/c/basics/13_strcat/"},{"content":"1. strcpy(字符数组1, 字符串2) 简介  string copy 字符串赋值函数 将“字符串2”复制到“字符数组1”中去  注意事项   “字符数组1”必须定义得足够大，以便容纳被复制的字符串\n  “字符数组1”必须写成数组名形式，“字符串2”可以是字符数组名，也可以是字符串常量\n  复制时，“字符串2”连带它末尾的 '\\0' 一并复制\n  不能用赋值语句将一个字符串常量或字符数组直接给一个字符数组，如\n1 2 3  char str1[10], str2[10]; str1 = \u0026#34;China\u0026#34;; str2 = str1; // error!     使用 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[] = \u0026#34;abcde\u0026#34;; char str2[] = \u0026#34;123\u0026#34;; strcpy(str1, str2); printf(\u0026#34;%s\\n\u0026#34;, str1); // 123  return 0; }   2. strncpy(str1, str2, n) 简介  将 str2 中前 n 个字符复制到 str1 中去 strncpy(str1, str2, 2)  将 str2 中最前面 2 个字符复制到 str1 中，取代 str1 中原有的最前面的 2 个字符    注意事项  复制的字符个数 n 不应多于 str1 中原有的字符（不包括 '\\0'）  使用 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[10] = \u0026#34;abcde\u0026#34;; char str2[10] = \u0026#34;12345\u0026#34;; strncpy(str1, str2, 3); printf(\u0026#34;%s\\n\u0026#34;, str1); // 123de  return 0; }   ","description":"","id":66,"section":"c","tags":null,"title":"14. strcpy() \u0026 strncpy()","uri":"https://yorkfish.github.io/review/c/basics/14_strcpy_and_strncpy/"},{"content":"strcmp(字符串1, 字符串2) 简介  string compare 比较“字符串1”与“字符串2”  比较规则  若出现不同字符，以第一个不相同的字符的比较结果为准 str1 == str2 返回 0 str1 \u0026gt; str2 返回某正整数 str1 \u0026lt; str2 返回某负整数  使用 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;york\u0026#34;, \u0026#34;york\u0026#34;)); // 0  printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;york\u0026#34;, \u0026#34;fish\u0026#34;)); // 1  printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;fish\u0026#34;, \u0026#34;york\u0026#34;)); // -1  printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;york\u0026#34;, \u0026#34;yorkfish\u0026#34;)); // -1  return 0; }   ","description":"","id":67,"section":"c","tags":null,"title":"15. strcmp()","uri":"https://yorkfish.github.io/review/c/basics/15_strcmp/"},{"content":"strlen(字符数组) 简介  string length 测试字符串长度  注意事项  函数的值位字符串的实际长度，不包括 '\\0'  使用 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[] = \u0026#34;york\u0026#34;; char str2[10] = \u0026#34;fish\u0026#34;; printf(\u0026#34;%d\\n\u0026#34;, strlen(str1)); // 4  printf(\u0026#34;%d\\n\u0026#34;, sizeof(str1)); // 5  printf(\u0026#34;%d\\n\u0026#34;, strlen(str2)); // 4  printf(\u0026#34;%d\\n\u0026#34;, sizeof(str2)); // 10  return 0; }   ","description":"","id":68,"section":"c","tags":null,"title":"16. strlen()","uri":"https://yorkfish.github.io/review/c/basics/16_strlen/"},{"content":"1. strlwr(字符串)  string lowercase 将字符串中的大写字母换成小写字母  2. strupr(字符车)  string uppercase 将字符串中的小写字母换成大写字母  3. 使用 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;YorkFish\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, strlwr(str)); // yorkfish  printf(\u0026#34;%s\\n\u0026#34;, strupr(str)); // YORKFISH  return 0; }   ","description":"","id":69,"section":"c","tags":null,"title":"17. strlwr() \u0026 strupr()","uri":"https://yorkfish.github.io/review/c/basics/17_strlwr_and_strupr/"},{"content":"1. 拷贝文档  在 content 文件夹下新建 blog 文件夹 将 root/themes/zdoc/exampleSite/content/en/blog/_index.md 拷贝过来  2. 新建文档   在 blog 文件夹下新建文档\n  在文档开头写入如下语句\n+++\rauthor = \u0026quot;YorkFish\u0026quot;\rtitle = \u0026quot;Usage\u0026quot;\rdate = \u0026quot;2020-09-10\u0026quot;\r# description = \u0026quot;zdoc blog quick start\u0026quot;\rtags = [\r\u0026quot;zdoc\u0026quot;,\r]\rimage = \u0026quot;\u0026quot;\r+++\r  3. 修改配置文件   打开 root/config/_default/menus.zh.toml\n  在合适的位置加入如下语句\n[[main]]\ridentifier = \u0026quot;blog\u0026quot;\rname = \u0026quot;Blog\u0026quot;\rurl = \u0026quot;blog\u0026quot;\rweight = 3\r  修改几个 weight 值\n ","description":"","id":70,"section":"blog","tags":["zdoc"],"title":"Usage","uri":"https://yorkfish.github.io/review/blog/01_usage/"},{"content":"1. 二进制转十进制 例一 0b101.11  整数部分：1 * 22 + 0 * 21 + 1 * 20 小数部分：1 * 2-1 + 1 * 2-2   0b101.11 = 4 + 1 + 0.5 + 0.25 = 5.75  2. 十进制转二进制 例二 0.125   0.125 * 2 = 0.25, 取整数部分 0\n  0.25 * 2 = 0.5, 取整数部分 0\n  0.5 * 2 = 1, 取整数部分 1（到 1 为止）\n  0.125 = 0b0.001\n  例三 0.6875   0.6875 * 2 = 1.375, 取整数部分 1（整数取走就剩 0.375 了）\n  0.375 * 2 = 0.75, 取整数部分 0\n  0.75 * 2 = 1.5, 取整数部分 1\n  0.5 * 2 = 1, 取整数部分 1\n  0.6875 = 0b0.1011\n ","description":"","id":71,"section":"blog","tags":["basics"],"title":"进制转换","uri":"https://yorkfish.github.io/review/blog/02_binary-decimal_conversion/"},{"content":"  博客：不求全，方便自己快速回忆\n  本人：在网上东学一点，西学一点的非科班菜鸟\n  ","description":"YorkFish about page","id":72,"section":"","tags":null,"title":"About","uri":"https://yorkfish.github.io/review/about/"}]