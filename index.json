[{"content":"1. 目录  用法：在首行写 [TOC] 说明：TOC 取自 Table of Content 的首字母 效果：见右侧  2. 标题  用法：一般是 n 个井号 + 1 个空格 + 标题 说明：1 \u0026lt;= n \u0026lt;= 6  示例与效果   示例\n# 一级标题\r## 二级标题\r### 三级标题\r#### 四级标题\r##### 五级标题\r###### 六级标题\r  效果\n一级标题 二级标题 三级标题 四级标题 五级标题 六级标题   补充   前两级标题有如下写法\n  示例\n一级标题\r========\r二级标题\r--------\r  效果\n一级标题 二级标题   ","description":"","id":0,"section":"markdown","tags":null,"title":"01. 目录与标题","uri":"https://yorkfish.github.io/review/markdown/01-toc-and-title/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  % 单行注释与matlab一样，一个百分号搞定 % utf-8编码 A4纸 12号字 文档样式为ctexart \\documentclass[UTF8,a4paper,12pt]{ctexart} % 导入geometry包调整边距 \\usepackage[left=2.50cm,right=2.50cm,top=2cm,bottom=2cm]{geometry} % 这里是导言区 \\title{文章的标题} \\author{YorkFish} % \\date{} 表示不显示日期 \\date{\\today} \\begin{document} % 显示标题  \\maketitle % 生成目录 需要编译两次或更多  \\tableofcontents \\begin{abstract} 这是一个摘要 \\end{abstract} \\section{引言} 这是引言 \\section{章节} 这是一个章节 \\subsection{子章节} 这是一个子章节 \\subsubsection{三级章节} 这是一个三级章节 \\end{document}   ","description":"大致结构","id":1,"section":"latex","tags":null,"title":"01. General Structure","uri":"https://yorkfish.github.io/review/latex/01-general-structure/"},{"content":"说明  官方文档：\u0026gt;\u0026gt;\u0026gt; 传送门 下载地址：\u0026gt;\u0026gt;\u0026gt; 传送门 两个版本  开发版本（不妨先下载这个） 生产版本（删去了报错信息）    先写个轮廓 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;outline\u0026lt;/title\u0026gt; \u0026lt;!-- 记得导入下载的 vue.js --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- * --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 1 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; \u0026lt;!-- 2 --\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   例1 step1 1 2 3 4  \u0026lt;!-- 在轮廓的 1 处创建容器 --\u0026gt; \u0026lt;div id=\u0026#34;app1\u0026#34;\u0026gt; {{msg}} \u0026lt;/div\u0026gt;   step2 1 2 3 4 5 6 7  // 在轮廓的 2 处创建 Vue 实例 new Vue({ el: \u0026#34;#app1\u0026#34;, // el 是挂载点，用来挂载元素  data: { // 模板  msg: \u0026#34;你好\u0026#34; } });   几个概念  挂载点：Vue 只处理挂载点的内容 模板：挂载点里面的内容 实例  new Vue() 自动结合模板和数据，生成内容，将生成的内容发到挂载点    例2 step1 1 2 3 4  \u0026lt;!-- 在轮廓的 1 处，紧跟在 id=\u0026#34;app1\u0026#34; 下面 --\u0026gt; \u0026lt;div id=\u0026#34;app2\u0026#34;\u0026gt; {{msg}} \u0026lt;/div\u0026gt;   step2 1 2 3 4 5 6 7  // 在轮廓的 2 处，紧跟着上一个 Vue 实例 var vm = new Vue({ el: \u0026#34;#app2\u0026#34;, data: { msg: \u0026#34;数据\u0026#34; } });   控制台 输入 \u0026gt; vm.msg = \u0026quot;姓名\u0026quot;;\r返回 \u0026lt;· \u0026quot;姓名\u0026quot;\r 与此同时，页面的第二行，原来的“数据”变为了“姓名” 双向绑定：模板与视图中的数据会互相影响  ","description":"初识","id":2,"section":"web","tags":null,"title":"01. Overview","uri":"https://yorkfish.github.io/review/web/vue/01-overview/"},{"content":" 官网：\u0026gt;\u0026gt;\u0026gt; 传送门  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --\u0026gt; \u0026lt;title\u0026gt;Bootstrap 101 Template\u0026lt;/title\u0026gt; \u0026lt;!-- Bootstrap --\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --\u0026gt; \u0026lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --\u0026gt; \u0026lt;!--[if lt IE 9]\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;![endif]--\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;你好，世界！\u0026lt;/h1\u0026gt; \u0026lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   ","description":"基本模板","id":3,"section":"web","tags":null,"title":"01. Basic Template","uri":"https://yorkfish.github.io/review/web/bootstrap/01-basic-template/"},{"content":" AJAX 是一种“艺术”，是在不重新加载整个页面的情况下与服务器交换数据并更新部分网页的艺术 网上是这样说的  AJAX 指异步 JavaScript 及 XML (Asynchronous JavaScript And XML) AJAX 是一种在 2005 年由 Google 推广开来的编程模式 AJAX 不是一种新的编程语言，而是一种使用现有标准的新方法 通过 AJAX，你可以创建更好、更快以及更友好的 Web 应用程序 AJAX 基于 JavaScript 和 HTTP 请求 (HTTP requests) 通过 HTTP 请求加载远程数据   jQuery 底层对 AJAX 实现进行了封装，这使得我们在进行 AJAX 操作时，不必像原生 JS 中那么复杂 $.get(), $.post(), $.ajax()  返回其创建的 XMLHttpRequest 对象 多数情况下我们不需要去操作返回的对象    ","description":"简介","id":4,"section":"web","tags":null,"title":"01. Introduce","uri":"https://yorkfish.github.io/review/web/ajax/01-introduce/"},{"content":"说明  官网：\u0026gt;\u0026gt;\u0026gt; 传送门 jQuery 是一个是免费、开源的 Javascript 库，也是目前使用最广泛的 Javascript 函数库  作用  jQuery 极大地方便使用者完成前端的相关操作，例如  节点操作 元素操作 事件绑定 ajax 操作   jQuery 还解决了大多数的兼容性问题  版本  jQuery 的版本分为 1.x 系列、2.x 系列和 3.x 系列  1.x 系列兼容低版本的浏览器 2.x、3.x 系列放弃支持低版本浏览器 目前使用最多的是 1.x 系列    使用  页面用 script 标签引入这个 js 文件就可以使用  1  \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;js/jquery-1.8.3.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   ","description":"简介","id":5,"section":"web","tags":null,"title":"01. Introduce","uri":"https://yorkfish.github.io/review/web/jquery/01-introduce/"},{"content":"定位  JS 是运行在浏览器端的脚本语言  关于浏览器  JS 由浏览器解释执行 JS 通常被直接嵌入 HTML 页面  关于脚本语言  JS 是客户端脚本语言 JS 是轻量级编程语言 JS 是解释性语言  功能  主要解决前端与用户交互的问题，如  使用交互 数据交互    特点  弱类型 基于对象 安全 兼容性  ","description":"简介","id":6,"section":"web","tags":null,"title":"01. Introduce","uri":"https://yorkfish.github.io/review/web/javascript/01-introduce/"},{"content":" c_str() empty() clear() size(), length() begin(), end(), rbegin(), rend() front(), back() push_back(), pop_back() erase() find(), rfind() substr(起始索引[, 子串长度])   1. 定义与输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt; using namespace std; int main() { string s1; // 默认的空字符串  string s2 = s1; // s2 是 s1 的一个副本  string s3 = \u0026#34;york\u0026#34;; // s3 是字符串字面值的一个副本  string s4(10, \u0026#39;c\u0026#39;); // 可以看成是 Python 的 \u0026#39;c\u0026#39; * 10  printf(\u0026#34;%s\\n\u0026#34;, s3.c_str()); // 函数 c_str() 返回的是 s3 的首地址  printf(\u0026#34;%s\\n\u0026#34;, s4.c_str()); return 0; }   \u0026gt;\u0026gt;\u0026gt;\nyork\rcccccccccc\rps  GNU 的编译器不导入 \u0026lt;string\u0026gt; 也能使用它，微软的编译器需要导入 string 可以用 printf() 输出，但不能用 scanf() 读入  2. 读入一行 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string str; getline(cin, str); // 用 getline 读一行到 string 里（不会被空格打断）  cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; return 0; }     输入\n york fish\n   输出\n york fish\n   3. 判空与长度  empty() size(), length()  两者都是 \u0026ldquo;Return length of string\u0026rdquo; 并不是像 strlen() 那样用一次计算一次，而是有一个变量存字符串的大小 两者的值是一样的，可以在理解上作细微区别  size() 一般用作返回容器大小的方法 length() 一般用作返回一个序列的长度   s1 \u0026gt; s2, s1 \u0026lt; s2, s1 == s2, s1 \u0026gt;= s2, s1 \u0026lt;= s2, s1 != s2 六种比较方式可以直接用 string 可以和 \u0026quot;.\u0026quot; 这种字符串比较，但不可以和 '.' 这种字符比较    1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string s = \u0026#34;york\u0026#34;; cout \u0026lt;\u0026lt; s.empty() \u0026lt;\u0026lt; endl; // return bool  cout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s.length() \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n0\r4\r4\r4. 相加  string 可以加 char，但反过来的不行，因为 string 有相加功能，char 没有  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string s1 = \u0026#34;york\u0026#34;, s2 = \u0026#34;fish\u0026#34;; string s; s1 += s2; s = s1 + \u0026#34; c++\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\nyorkfish c++\r5. 遍历 for each  C++11 标准中新增的功能 这种写法和 Java 一模一样 也很像 for ch in strings  1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string name = \u0026#34;york\u0026#34;; for (char c : name) cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; // c 是一个副本，改变 c 无法影响 name  // for (char \u0026amp;c : name) cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; // 使用“引用”可以影响 name  return 0; }   \u0026gt;\u0026gt;\u0026gt;\ny\ro\rr\rk\rfor_each  需要导入 \u0026lt;algorithm\u0026gt; 写法挺灵活的，下面列举一种  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; void print(char c) { cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; } int main() { string s = \u0026#34;york\u0026#34;; for_each(s.begin(), s.end(), print); return 0; }   \u0026gt;\u0026gt;\u0026gt;\ny\ro\rr\rk\r迭代器 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string s = \u0026#34;york\u0026#34;; for (string::iterator it = s.begin(); it != s.end(); it ++ ) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; // * 是解引用  return 0; }   \u0026gt;\u0026gt;\u0026gt;\ny\ro\rr\rk\rps  可以把迭代器看成指针 可以认为 s.end() 指向 '\\0' 这里的 for 中使用 it \u0026lt; s.end() 也行，不过 != 比较保险，下面的不能用 \u0026lt;  \u0026lt;set\u0026gt;, \u0026lt;map\u0026gt;，因为它们的 -- 与 ++ 找的是前驱与后继 \u0026lt;unordered_set\u0026gt;, \u0026lt;unordered_map\u0026gt;，因为它们是无序的   类型名比较长时，可以使用 auto，如 for 中的 it 可以定义成 auto it auto 也是 C++11 增加的，可以把它当作是 golang 的自动推导  6. back \u0026amp; pop_back  C++11 标准中新增的功能  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string s = \u0026#34;york\u0026#34;; cout \u0026lt;\u0026lt; s.back() \u0026lt;\u0026lt; endl; // 返回字符串的最后一个字符  s.pop_back(); // 删去字符串最后一个字符  cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\nk\ryor\r7. erase 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string s = \u0026#34;yorkfish\u0026#34;; s.erase(s.begin()); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; s.erase(-- s.end()); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\norkfish\rorkfis\r8. find \u0026amp; rfind  Python 也是这个效果  默认从左往右找，r 表示从右往左找 还可以指定起始位置    1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string s = \u0026#34;york kroy\u0026#34;; cout \u0026lt;\u0026lt; s.find(\u0026#39;o\u0026#39;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s.find(\u0026#39;o\u0026#39;, 2) \u0026lt;\u0026lt; endl; // 从 index=2 开始往后查找  cout \u0026lt;\u0026lt; s.rfind(\u0026#39;o\u0026#39;) \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1\r7\r7\r9. substr  与 Python 的切片不一样  默认：从开头到结尾 一个参数，表示起点：从起点到结尾 两个参数  起点与步长：从起点开始，共取步长个字符 若第二个参数是负数，不是 Python 那样反着数，均表示“到结尾”      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string s = \u0026#34;yorkfish\u0026#34;; cout \u0026lt;\u0026lt; s.substr() \u0026lt;\u0026lt; endl; // s[:]  cout \u0026lt;\u0026lt; s.substr(4) \u0026lt;\u0026lt; endl; // s[4:]  cout \u0026lt;\u0026lt; s.substr(4, -1) \u0026lt;\u0026lt; endl; // s[4:]  cout \u0026lt;\u0026lt; s.substr(4, -5) \u0026lt;\u0026lt; endl; // s[4:]  cout \u0026lt;\u0026lt; s.substr(2, 4) \u0026lt;\u0026lt; endl; // s[2:2 + 4]  return 0; }   \u0026gt;\u0026gt;\u0026gt;\nyorkfish\rfish\rfish\rfish\rrkfi\r10. 字符串与数字的转换 字符串转数字 方式一  atoi(), stoi()  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char num1[] = \u0026#34;123\u0026#34;; cout \u0026lt;\u0026lt; atoi(num1) \u0026lt;\u0026lt; endl; string num2 = \u0026#34;456\u0026#34;; cout \u0026lt;\u0026lt; atoi(num2.c_str()) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; stoi(num2) \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n123\r456\r456\r方式二  见 sstream 的例三  数字转字符串 方式一  to_string()  1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int num = 12345; cout \u0026lt;\u0026lt; to_string(num) \u0026lt;\u0026lt; endl; // C++11 新增  return 0; }   \u0026gt;\u0026gt;\u0026gt;\n12345\r方式二  见 sstream 的例四  11. sstream 例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #include \u0026lt;iostream\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char str[1000], name[100]; int width, height; double area; fgets(str, 1000, stdin); sscanf(str, \u0026#34;%d%s%d%lf\u0026#34;, \u0026amp;width, name, \u0026amp;height, \u0026amp;area); cout \u0026lt;\u0026lt; width \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; height \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; area \u0026lt;\u0026lt; endl; return 0; }     输入\n 11 york 22 33.3\n   输出\n 11\n22\nyork\n33.3\n   例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;iostream\u0026gt;#include \u0026lt;sstream\u0026gt; using namespace std; int main() { string s, word; getline(cin, s); stringstream ssin(s); // 字符流，这一句与下面两句一个意思  // stringstream ssin;  // ssin \u0026lt;\u0026lt; s;  while (ssin \u0026gt;\u0026gt; word) // 当 cin 用  { if (word == \u0026#34;york\u0026#34;) break; else cout \u0026lt;\u0026lt; word \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; }     输入\n fish1 fish2 fish3 york\n   输出\n fish1 fish2 fish3\n   例三 字符串转数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;iostream\u0026gt;#include \u0026lt;sstream\u0026gt; using namespace std; int main() { string s = \u0026#34;12345\u0026#34;; stringstream ssin; ssin \u0026lt;\u0026lt; s; int num; ssin \u0026gt;\u0026gt; num; cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n12345\r例四 数字转字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;iostream\u0026gt;#include \u0026lt;sstream\u0026gt; using namespace std; int main() { int num = 12345; stringstream ssin; ssin \u0026lt;\u0026lt; num; string out; ssin \u0026gt;\u0026gt; out; cout \u0026lt;\u0026lt; out \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n12345\r","description":"可变字符串","id":7,"section":"cpp","tags":null,"title":"01. string","uri":"https://yorkfish.github.io/review/cpp/stl/01-string/"},{"content":"第一个 C++ 程序 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; endl; return 0; }   ","description":"Hello World","id":8,"section":"cpp","tags":null,"title":"01. preview","uri":"https://yorkfish.github.io/review/cpp/01-preview/"},{"content":" 皇览揆余初度兮，肇锡余以嘉名。名余曰正则兮，字余曰灵均。\n——屈原《离骚》\n 1. 说明  上面是无意间发现的巧合 “正则表达式”(Regular Expression)是用来做“模式配对”(Pattern matching)的 几乎所有程序设计语言都支持正则 命令行也或多或少地支持正则 正则的规则是通用的，只是不同的工具在使用上有细微差别  2. 测试方式  使用在线的正则测试工具 使用专门测试正则的软件 若有装 Python，可以写一段代码测试 若有装 Cmder 或 Git，可以使用 awk 或 grep 命令测试 若上面的都没有，有浏览器也行，可以建一个 HTML 文件，用 Javascript 代码测试  ","description":"写在开头","id":9,"section":"regex","tags":null,"title":"01. preview","uri":"https://yorkfish.github.io/review/regex/01-preview/"},{"content":"线程替代方案   subprocess\n 完全跳过线程，使用进程 是派生进程的主要替代方案 Python 2.4 后引入    multiprocessiong\n 使用 threadiing 接口派生，使用子进程 允许为多核或者多 CPU 派生进程，接口跟 threading 非常相似 Python 2.6 后引入    concurrent.futures\n 新的异步执行模块 任务级别的操作 Python 3.2 后引入    多进程  进程间通讯(InterprocessCommunication, IPC) 生产者消费者模型 \u0026hellip;  ","description":"历史信息","id":10,"section":"python","tags":null,"title":"01. preview","uri":"https://yorkfish.github.io/review/python/multiprocessing/01-preview/"},{"content":"例一 三个查看状态的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; import threading \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; threading.active_count() # 被激活的线程数 1 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; threading.enumerate() # 列出所有线程 [\u0026lt;_MainThread(MainThread, started 16928)\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; threading.current_thread() # 当前使用的线程 \u0026lt;_MainThread(MainThread, started 16928)\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; threading.current_thread().isAlive() # 线程运行状态 True \u0026gt;\u0026gt;\u0026gt;   例二 添加与启动 - 方式一 1 2 3 4 5 6 7 8 9 10 11 12 13 14  import threading def thread_job(): print(\u0026#34;This is an added Thread, number is %s\u0026#34; % threading.current_thread()) def main(): added_thread = threading.Thread(target=thread_job) added_thread.start() if __name__ == \u0026#34;__main__\u0026#34;: main()   \u0026gt;\u0026gt;\u0026gt;\nThis is an added Thread, number is \u0026lt;Thread(Thread-1, started 7144)\u0026gt;\r例三 添加与启动 - 方式二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  import threading import time # 类需要继承自 threading.Thread class MyThread(threading.Thread): def __init__(self, arg): super(MyThread, self).__init__() self.arg = arg # 必须重写 run 方法，run 方法代表的是真正执行的功能 def run(self): time.sleep(0.5) print(\u0026#34;arg:\u0026#34;, self.arg) if __name__ == \u0026#34;__main__\u0026#34;: t1 = MyThread(1) t2 = MyThread(2) t1.start() t2.start() t1.join() t2.join() print(\u0026#34;all done.\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\narg: 1\rarg: 2\rall done.\r说明  结果不唯一，也可能是  arg: 2\rarg: 1\rall done.\r例四 线程间的执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import threading import time def thread_job(): time.sleep(1) print(threading.current_thread()) def main(): for _ in range(5): added_thread = threading.Thread(target=thread_job) added_thread.start() if __name__ == \u0026#34;__main__\u0026#34;: main()   \u0026gt;\u0026gt;\u0026gt;\n\u0026lt;Thread(Thread-1, started 7668)\u0026gt;\r\u0026lt;Thread(Thread-5, started 12108)\u0026gt;\r\u0026lt;Thread(Thread-4, started 16136)\u0026gt;\r\u0026lt;Thread(Thread-2, started 16260)\u0026gt;\r\u0026lt;Thread(Thread-3, started 10156)\u0026gt;\r说明  结果不唯一，打印的排版也可能参差不齐 多线程之间执行是无序的，主要看 CPU 的调度  ","description":"初识","id":11,"section":"python","tags":null,"title":"01. preview","uri":"https://yorkfish.github.io/review/python/threading/01-preview/"},{"content":"1. 最简易的窗口 1 2 3 4  import tkinter as tk window = tk.Tk() window.mainloop()   ps  默认标题：tk 默认大小：200x200  2. 更多设置  自定义标题内容：window.title(\u0026quot;YorkFish\u0026quot;) 自定义窗口大小：window.geometry(\u0026quot;300x200\u0026quot;) 自定义窗口位置：window.geometry(\u0026quot;+200+100\u0026quot;) 同时设置大小与位置：window.geometry(\u0026quot;300x200+200+100\u0026quot;)  1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"窗口","id":12,"section":"python","tags":null,"title":"01. window","uri":"https://yorkfish.github.io/review/python/tkinter/01-window/"},{"content":"1. 说明  __call__ 可以让实例对象能够像函数一样加小括号进行调用  2. 举例 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; class Test(object): ... def __init__(self): ... pass ... def __call__(self, *args, **kwargs): ... print(\u0026#34;Hello, I am YorkFish.\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; t() Hello, I am YorkFish. \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":13,"section":"python","tags":null,"title":"01. __call__","uri":"https://yorkfish.github.io/review/python/class/01-call/"},{"content":"1. 说明  复数在数学上没有绝对值这个概念 abs() 对复数使用时，是求模 一个复数的模 = sqrt(实部2 + 虚部2)  2. 举例 1 2 3  \u0026gt;\u0026gt;\u0026gt; abs(3 + 4j) 5.0 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":14,"section":"python","tags":null,"title":"01. abs()","uri":"https://yorkfish.github.io/review/python/bif/01-abs/"},{"content":"1. 两组运算符  and, or \u0026amp;, |  2. 四种情况 情况一  当运算对象（本质）为 True, False 时，两组运算符没有差别  1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; 1\u0026lt;2 and 3\u0026lt;4 True \u0026gt;\u0026gt;\u0026gt; 1\u0026lt;2 \u0026amp; 3\u0026lt;4 True \u0026gt;\u0026gt;\u0026gt;   情况二  当运算对象为数值变量（不止 0 与 1）时，有区别 \u0026amp;, | 进行二进制的按位逻辑运算  1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; 1 and 2 2 \u0026gt;\u0026gt;\u0026gt; 1 \u0026amp; 2 # 0001 \u0026amp; 0010 0 \u0026gt;\u0026gt;\u0026gt; 1 | 2 # 0001 | 0010 3 \u0026gt;\u0026gt;\u0026gt;   情况三  and + or 可以做“三目运算”  1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; 123 \u0026gt; 0 and 1 or -1 1 \u0026gt;\u0026gt;\u0026gt; 123 \u0026lt; 0 and 1 or -1 -1 \u0026gt;\u0026gt;\u0026gt;   情况四  两组运算符混合使用时  and, or 按正常逻辑进行返回 \u0026amp;, | 先把 True, False 转为 1, 0，再进行逻辑“与或”运算    1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; -3\u0026lt;-2\u0026lt;-1\u0026lt;False and True True \u0026gt;\u0026gt;\u0026gt; True | 2 # 0001 | 0010 = 0011 3 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":15,"section":"python","tags":null,"title":"01. add, or, \u0026, |","uri":"https://yorkfish.github.io/review/python/basics/01-and-or/"},{"content":"例一 1 2 3 4 5 6 7  def add2(x, y): return x + y new_func = add2 print(new_func is add2) # True print(new_func(3, 4)) # 7   例二  就像列表名表示列表地址，函数名也表示函数地址  1 2 3 4 5 6 7 8 9  def add2(x, y): return x + y def test(x, y, func): return func(x, y) print(test(3, 4, add2)) # 7   例三  闭包 = 函数块 + 创建它时的环境 当内层函数调用外层函数作用域中的变量时，外层函数调用结束后，会把内层函数涉及到的变量“送”给内层函数，以保证其正常运行  1 2 3 4 5 6 7 8 9 10 11  def add2(x, y): return x + y def test(x, y): def sum2(): return x + y return sum2 print(test(3, 4)()) # 7   ","description":"","id":16,"section":"python","tags":null,"title":"01. function","uri":"https://yorkfish.github.io/review/python/decorator/01-function/"},{"content":"1. Python 环境变量  因为 python 支持多版本安装，所以现在安装时默认没有勾选“添加到环境变量” 若只装一个版本，直接勾就好 若装了多个版本，想在命令行启动哪个，就在装那个时勾上  对比 Anaconda  有 Documentation 有 IDLE（Anaconda 也有，但需要设置） 有 test suit，这个可以不勾 有 py launcher  装了就可以用 py 代替 python 启动 方便多版本使用    注意  install for all user 需要提权 若自动添加环境变量，会添加三个  python 的 python scripts 的 py launcher 的    技巧   在命令行使用 where 命令可以查看路径，如\n C:\\Users\\York\u0026gt;where python    pip --version 查看的是 pip 包的路径\n  查看位数\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; import platform \u0026gt;\u0026gt;\u0026gt; platform.architecture() (\u0026#39;64bit\u0026#39;, \u0026#39;WindowsPE\u0026#39;) \u0026gt;\u0026gt;\u0026gt;     说明  安装目录下  doc 文件夹里面是说明文档 Lib 文件夹里面是 Python 自带的库（标准库）、包、模块 Lib\\site-packages 里面是安装的第三方库 Scripts 里面是用 Python 实现的脚本的入口程序，如 pip Tools 里面有一些用 Python 写的脚本、Demo   安装目录的上级目录  因为 py launcher 要管理多个版本，所以不能在某一个 python 目录中，而是在上级目录 py --list 列出所有安装的 Python py -0 效果同 py --list py -0p 显示完整路径    2. Anaconda 手动添加环境变量  若安装时没勾上“添加到环境变量”，则进行如下操作 左下角搜索“环境变量”并打开 选择用户的 Path 打开 新建“环境变量” 一路确定  我添加的具体路径  我的 Anaconda 装在 D:\\anaconda3，所以 添加 D:\\anaconda3 添加 D:\\anaconda3\\Library\\bin 添加 D:\\anaconda3\\Library\\mingw-w64\\bin 添加 D:\\anaconda3\\Scripts  若命令行无法启动  将 %USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps 下移至最下方 谁在前就优先调用谁 把 Python 相关放在上面，就调用它们 虚拟环境也是这个原理  ","description":"","id":17,"section":"python","tags":null,"title":"01. install","uri":"https://yorkfish.github.io/review/python/operation/01-install/"},{"content":"numpy 的用处  数学计算 形状计算 各种排序 傅里叶变换 线性代数计算 统计计算\n……  ","description":"","id":18,"section":"python","tags":null,"title":"01. 概述","uri":"https://yorkfish.github.io/review/python/numpy/01-overview/"},{"content":"1. 与 \u0026amp;  若参加与运算的是负数，则以补码形式表示二进制，然后“按位与”  作用  清零 取出数中指定位 保留数中指定位  2. 或 |  对一个数据的某些位定值为 1  3. 异或 ^ 作用  使特定位翻转  说明  XOR 也是异或的意思 与 0 异或，保留原值  举例   交换两个值，不用临时变量，不担心溢出\n1 2 3  a = a ^ b; b = b ^ a; a = a ^ b;     4. 取反 作用  使某数最后一位为零，如 a = a \u0026amp; ~1;  说明  ~ 优先级比算术运算符、关系运算符、逻辑运算符（! 除外）、其他位运算符都高  5. 左移 作用  左移 n 位，即乘以 22  说明  有的 C 编译程序自动将“乘二”运算用左移实现  6. 右移  对无符号数，高位补 0 对有符号数，高位补的数与编译方式有关  移入 0 的称为“逻辑右移” 移入 1 的称为“算术右移”，C/C++ 一般是这种     正数高位补 0 负数高位补 1   7. 不同长度的数据进行位运算  系统会将二者进行右端对齐 将短的正数左端补 0  例 短的负数左端补什么 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { short a = -1; // 1000 0000 0000 0001  int b = 0; // 0000 0000 0000 0000 0000 0000 0000 0000  int c = a|b; char d[32]; itoa(c, d, 2); // 将 c 的 2 进制写入 d  printf(\u0026#34;%s\\n\u0026#34;, d); // 1111 1111 1111 1111 1111 1111 1111 1111  return 0; }    负数是以补码的形式存储的，所以需要转换 转换后的原码：0b1000 0000 0000 0000 0000 0000 0000 0001 由此可见，是把符号位移到新的最高位，然后补 0  ","description":"","id":19,"section":"c","tags":null,"title":"01 位运算简介","uri":"https://yorkfish.github.io/review/c/bit/01-overview/"},{"content":"1. 一般形式  #define 标识符 字符串 如 #define PI 3.1415926  2. 一些约定  宏名一般习惯用大写字母表示 宏定义是用宏名代替一个字符串，也就是作简单的置换，不作正确性检查 宏定义不是 C 的语句，不必在行末加分号，如果加了分号，会连分号一起进行置换 通常，#define 命令写在文件开头，函数之前，作为文件一部分，在此文件范围内有效  3. 注意事项   可以用 #undef 命令终止宏定义的作用域\n1 2 3 4 5 6 7 8 9 10 11  #define G 9.8  void main() { // ... } #undef  void f1() { // ... }     进行宏定义时可以引用已定义的宏名，可以层层置换\n  对程序中用双引号括起来的字符串内的字符，即使与宏名相同，也不进行置换\n  宏定义是专门用于预处理命令的一个专用名词，它与定义变量的含义不同，只作字符替换，不分配内存空间\n  ","description":"","id":20,"section":"c","tags":null,"title":"01. 不带参宏定义","uri":"https://yorkfish.github.io/review/c/preprocessor/01-with-no-arguments/"},{"content":"1. 简介  一个 C 程序由一个或多个程序模块组成 每个程序模块作为一个源程序文件 一个源程序文件由一个或多个函数以及其他有关内容（如命令行、数据定义等）组成 C 程序的执行，从 main 函数开始，在 main 函数中结束 所有函数都是平行的，即在定义函数时是分别进行的，是相互独立的  2. 两种角度  从用户的角度看，函数有两种  标准函数 用户自定义的函数   从函数的形式看，函数分两类  无参函数 有参函数    ","description":"","id":21,"section":"c","tags":null,"title":"01. 函数概述","uri":"https://yorkfish.github.io/review/c/function/01-overview/"},{"content":"1. 优势  正确而灵活地运用指针，可以  有效地表示复杂的数据结构 动态分配内存 方便地使用字符串 有效而方便地使用数组 调用函数时，获得一个以上的结果 直接处理内存单元地址 。。。    2. 名词解释  指针\n一个地址  能找到以它的值为地址的内存单元 一个变量的地址称为该变量的指针   指针变量  存放地址的变量 它的值是地址    ","description":"","id":22,"section":"c","tags":null,"title":"01. 指针概述","uri":"https://yorkfish.github.io/review/c/pointer/01-overview/"},{"content":"1. 分类  基本类型 构造类型 指针类型 空类型  2. 常用的基本类型    类型名 写法 缩写     短整型 short int short   整型 int /   长整型 long int long   长整型 long long int long long     一般  sizeof(short) \u0026lt; sizeof(long) sizeof(short) \u0026lt;= sizeof(int) 或 sizeof(int) \u0026lt;= sizeof(long)    ","description":"","id":23,"section":"c","tags":null,"title":"01. 数据类型","uri":"https://yorkfish.github.io/review/c/basics/01-data-type/"},{"content":"1. 简介  每个被使用的文件都在内存中开辟一个区，用来存放文件的有关信息 这些信息是保存在一个结构体变量中的 该结构体类型是由系统定义的，取名为 FILE  2. stdio.h 中的文件类型声明 1 2 3 4 5 6 7 8 9 10 11 12 13  #ifndef _FILE_DEFINED  struct _iobuf { char *_ptr; // 指向文件输入的下一个位置  int _cnt; // 当前缓冲区的相对位置  char *_base; // 文件的起始位置  int _flag; // 文件状态标志  int _file; // 用于文件的有效性验证  int _charbuf; // 检查缓冲区状况，若无缓冲区，则不读取  int _bufsiz; // 缓冲区的大小  char *_tmpfname; // 临时文件名  }; typedef struct _iobuf FILE; #define _FILE_DEFINED   ","description":"","id":24,"section":"c","tags":null,"title":"01. 文件概述","uri":"https://yorkfish.github.io/review/c/file/01-overview/"},{"content":"一般声明形式 struct 结构体名 {\r成员列表\r};\r举例 1 2 3 4 5 6 7 8  struct student { char name[20]; char addr[30]; char gender; int age; int num; float score; };   ps   不要忽略最后的分号\n  “结构体名”用作结构体类型的标志，又称“结构体标记” structure tag\n  “成员列表” member list 又称“域表” field list\n  每一个成员也称为结构体中的一个域\n  ","description":"","id":25,"section":"c","tags":null,"title":"01. 结构体概述","uri":"https://yorkfish.github.io/review/c/struct-union-enum/01-overview-of-struct/"},{"content":"官方文档：\u0026gt;\u0026gt;\u0026gt; 传送门\n1. 类型表    Type Code C Type Python Type Minimum size (bytes)     b signed char int 1   B unsigned char int 1   u Py_UNICODE Unicode character;\ndeprecated since Python 3.3 2   h signed short int 2   H unsigned short int 2   i signed int int 2   I unsigned int int 2   l signed long int 4   L unsigned long int 4   q signed long long int 8   Q unsigned long long int 8   f float float 4   d double float 8    2. 举例 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; from array import array \u0026gt;\u0026gt;\u0026gt; arr = array(\u0026#39;q\u0026#39;, (100, 200, 300)) \u0026gt;\u0026gt;\u0026gt; arr array(\u0026#39;q\u0026#39;, [100, 200, 300]) \u0026gt;\u0026gt;\u0026gt; arr[0] = 150 \u0026gt;\u0026gt;\u0026gt; arr array(\u0026#39;q\u0026#39;, [150, 200, 300]) \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":26,"section":"python","tags":null,"title":"01. array","uri":"https://yorkfish.github.io/review/python/module/01-array/"},{"content":"0. 注释  用法：用 \u0026lt;!-- 与 --\u0026gt; 将需要注释的内容包起来即可 如：\u0026lt;!-- 注释的内容 --\u0026gt;  1. 结构 基本结构 = 声明 + `html` 标签\r||\r`head` 头 + `body` 体\r2. 示例与效果 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;!-- 声明文档，告诉浏览器解析 html 代码的版本 --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;!-- html 是网页当中最大的标签，与闭合标签配对 --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- head 头，一般是对网页进行设置 --\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;!-- 设置网页的编码格式 --\u0026gt; \u0026lt;title\u0026gt;网页的标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- body 体，主要用于写显示在页面中的内容 --\u0026gt; hello html \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   效果 \r\r网页的标题\r\r\rhello html\r\r\r3. 补充   \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\n 将此页面定义为英文网页 可以不设置 lang，因为默认 lang=\u0026quot;en\u0026quot; 如果要定义成中文页面：lang=\u0026quot;zh\u0026quot;    \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\n charset=\u0026quot;UTF-8\u0026quot; 或 charset=\u0026quot;utf-8\u0026quot; 均可    ","description":"基本结构","id":27,"section":"web","tags":null,"title":"01. Basic Structure","uri":"https://yorkfish.github.io/review/web/html/01-basic-structure/"},{"content":"例一 Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // filename: main.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void* test(void* args) { printf(\u0026#34;Hello World\\n\u0026#34;); return NULL; // 对应 void* } int main() { pthread_t th; pthread_create(\u0026amp;th, NULL, test, NULL); return 0; }   编译命令 gcc main.c -lpthread -o main  线程函数编译时需要连接库函数，而 pthread 不是系统默认的库 加上 -lpthread 可以在连接时调用静态库 libpthread.a  运行结果  没有结果  结果分析 main th\r| |\r------\u0026gt;\r| |\rover 来不及运行，因为 main 结束了，程序也就结束了\rpthread_create  pthread_create 是类 Unix 操作系统的创建线程的函数 我偷懒了，是在 Win10 下用 gcc 测试的   1 2 3 4  int pthread_create(pthread_t *thread, const pthread attr_t *attr, void *(*start_routine)(void *), void *arg);    函数功能：创建线程（确定调用该线程函数的入口点） thread: 指向线程标识符的指针 attr: 线程属性设置 start_routine: 线程函数的起始地址 arg: 传递给 start_routine 的参数 返回值  0: 成功 -1: 出错    例二 Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void* test(void* args) { printf(\u0026#34;Hello World\\n\u0026#34;); return NULL; } int main() { pthread_t th; pthread_create(\u0026amp;th, NULL, test, NULL); pthread_join(th, NULL); // wait for \u0026#34;th\u0026#34;  return 0; }   编译命令 gcc main.c -lpthread -o main 运行结果 Hello World\r结果分析 main th\r| |\r------\u0026gt;\r| |\r\u0026lt;------\r|\rover\rpthread_join 1  int pthread_join __P (pthread_t __th, void **__thread_return);    第一个参数：被等待的线程标识符（不是指针） 第二个参数：由用户定义的指针，用来存储被等待线程的返回值 返回值  0: 成功 非零错误号: 出错    ","description":"创建","id":28,"section":"c","tags":null,"title":"01. Create","uri":"https://yorkfish.github.io/review/c/thread/01-create/"},{"content":"外链式   在 HTML 文档的 head 头部分添加如下语句\n1  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./xxx.css\u0026#34;\u0026gt;     在当前目录下新建一个 xxx.css\n  在 xxx.css 中写相应的程序代码\n  嵌入式   在 HTML 文档的 head 头部分使用 \u0026lt;style\u0026gt; 标签\n1 2 3 4 5 6 7  \u0026lt;style\u0026gt; div{ width: 200px; height: 200px; background-color: yellow; } \u0026lt;/style\u0026gt;     内联式   在html 文档的 body 体中使用 \u0026lt;div\u0026gt; 标签\n1  \u0026lt;div style=\u0026#34;width:200px;height:200px;background-color:green;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;     三种方法的比较  实际应用中，外链式较多 同时存在两种或两种以上的方式时  自顶向下，后加载的覆盖先加载的 一般地，离元素越近，优先级越高    ","description":"三种页面引入的方法","id":29,"section":"web","tags":null,"title":"01. Page Introduction","uri":"https://yorkfish.github.io/review/web/css/01-3-page-introduction-methods/"},{"content":"1. 引用  用法：\u0026gt; + 1 个空格 + 引用内容 说明  引用又称“块注释” 可以嵌套    示例与效果 单行   示例\n\u0026gt; markdown\n  效果\n markdown\n   嵌套   示例\n\u0026gt; 那个春天，你站在那株粉色桃树下，粉色的花丛中是你温暖的一袭红衣。让我想起《诗经》中的\r\u0026gt;\r\u0026gt; \u0026gt; 逃之夭夭，灼灼其华\r\u0026gt;\r\u0026gt; 后来我才知道，那一刻，你心里想的是\r\u0026gt;\r\u0026gt; \u0026gt; 之子于归，宣其室家\r\u0026gt;\r\u0026gt; —— 《在唐诗里孤独漫步》\r  效果\n 那个春天，你站在那株粉色桃树下，粉色的花丛中是你温暖的一袭红衣。让我想起《诗经》中的\n 逃之夭夭，灼灼其华\n 后来我才知道，那一刻，你心里想的是\n 之子于归，宣其室家\n —— 《在唐诗里孤独漫步》\n   2. 标记  用法：用两个反引号包框住 说明：`~ 就是 Tab 上面的那个“波浪键”  示例与效果  示例  `标记`   效果  标记    ","description":"","id":30,"section":"markdown","tags":null,"title":"02. 引用与标记","uri":"https://yorkfish.github.io/review/markdown/02-quote-and-sign/"},{"content":"方式一  使用 \\iffalse 与 \\fi 包含  1 2 3 4 5 6 7 8 9 10 11 12  \\documentclass[UTF8]{ctexbook} \\begin{document} \\iffalse 多行注释 第一行 第二行 第三行 \\fi \\end{ducument}   方式二  导入 verbatim 包  1 2 3 4 5 6 7 8 9 10 11 12 13 14  \\documentclass[UTF8]{ctexbook} \\usepackage{verbatim} \\begin{document} \\begin{comment} 多行注释 第一行 第二行 第三行 \\end{comment} \\end{ducument}   ","description":"多行注释","id":31,"section":"latex","tags":null,"title":"02. Multiline Comment","uri":"https://yorkfish.github.io/review/latex/02-multiline-comment/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;outline\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{msg}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{str}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{obj}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{arr}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{1+1}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{1\u0026gt;0?\u0026#39;Y\u0026#39;:\u0026#39;N\u0026#39;}}\u0026lt;/p\u0026gt; \u0026lt;!-- \u0026lt;p\u0026gt;{{var n = 1;}}\u0026lt;/p\u0026gt; [Vue warn]: Error compiling template: ... --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { msg: 12, str: \u0026#34;34\u0026#34;, obj: { name: \u0026#34;zhangsan\u0026#34;, age: 18 }, arr: [5, 6, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   说明  模板中可以写的数据类型：字符串、对象、数组、简单运算 不能写的：表达式  ","description":"模板语法","id":32,"section":"web","tags":null,"title":"02. Template Syntax","uri":"https://yorkfish.github.io/review/web/vue/02-template-syntax/"},{"content":"1. 选择器 简介  jQuery 用法思想：选择某个网页元素，然后对它进行某种操作 jQuery 选择器：可以快速地选择元素，其选择规则和 CSS 样式相同  基础选择器 1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 1. 通过 id 来获取元素，类似 document.getElementById(); $(\u0026#39;#logo\u0026#39;).css(\u0026#39;border\u0026#39;, \u0026#39;solid 2px red\u0026#39;); // 2. 通过 class 类名获取元素 $(\u0026#39;.w\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 3. 通过标签名来获取元素 $(\u0026#39;li\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 4. 逗号 并列获取 $(\u0026#39;#logo, #menu\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 5. 空格 层级获取 $(\u0026#39;#images li\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;);   2. 过滤获取 1 2 3 4 5 6 7 8 9 10 11 12 13  // 1. 获取首尾元素 $(\u0026#39;ul li:first\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); $(\u0026#39;ul li:last\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 2. 获取指定索引的元素，索引从 0 开始 $(\u0026#39;li:eq(7)\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); $(\u0026#39;li\u0026#39;).eq(7).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 此法可以避免字符串的转换  // 3. 获取包含指定文本的元素 $(\u0026#39;li:contains(国)\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 4. 通过包含指定属性来获取元素，通过属性来获取 $(\u0026#39;li[name=y]\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;);   3. 父子关系获取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 1. 获取所有的子元素 $(\u0026#39;#images\u0026#39;).children().css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 2. 获取第一个子元素 $(\u0026#39;ul li:first-child\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 3. 获取最后一个子元素 $(\u0026#39;ul li:last-child\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 4. 获取指定个数的子元素个数，从 1 开始 $(\u0026#39;ul li:nth-child(3)\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 5. 获取元素上一个同级元素 $(\u0026#39;#f\u0026#39;).prev().css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 6. 获取元素下一个同级元素 $(\u0026#39;#f\u0026#39;).next().css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 7. 获取同辈元素 (同辈元素不包含自己) $(\u0026#39;#f\u0026#39;).siblings().css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 8. 获取父级元素 $(\u0026#39;#f\u0026#39;).parent().css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;); // 9. 获取先辈级元素 $(\u0026#39;#f\u0026#39;).parents(\u0026#39;#all\u0026#39;).css(\u0026#39;border\u0026#39;, \u0026#39;solid 1px red\u0026#39;); // 10. 在父级元素中查找指定的子元素 $(\u0026#39;#images\u0026#39;).find(\u0026#39;.w\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;#369\u0026#39;);   ","description":"简单操作","id":33,"section":"web","tags":null,"title":"02. Easy Operation","uri":"https://yorkfish.github.io/review/web/jquery/02-easy-operation/"},{"content":"说明  Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统 随着屏幕或视口(viewport)尺寸的增加，系统会自动分为最多 12 列 它包含了易于使用的预定义类 还有强大的mixin 用于生成更具语义的布局  简介  栅格系统用于通过一系列的行(row)与列(column)的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。 下面就介绍一下 Bootstrap 栅格系统的工作原理  “行”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列(aligment)和内补(padding) 通过“行”在水平方向创建一组“列” 你的内容应当放置于“列”内，并且，只有“列”可以作为“行”的直接子元素，类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局 Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局 通过为“列”设置 padding 属性，从而创建列与列之间的间隔(gutter) 通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行”所包含的“列”抵消掉了padding 负值的 margin 就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建 如果一“行”中包含了的“列”大于 12，多余的“列”所在的元素将被作为一个整体另起一行排列 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类 因此，在元素上应用任何 .col-md-* 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类 因此，在元素上应用任何 .col-lg-* 不存在，也影响大屏幕设备   通过研究后面的实例，可以将这些原理应用到你的代码中  栅格参数  通过下表可以详细查看 Bootstrap 的栅格系统是如何在多种屏幕设备上工作的      超小屏幕 手机 (\u0026lt;768px) 小屏幕 平板 (≥768px) 中等屏幕 桌面显示器 (≥992px) 大屏幕 大桌面显示器 (≥1200px)     栅格系统行为 总是水平排列 开始是堆叠在一起的，当大于这些阈值时将变为水平排列C     .container 最大宽度 None （自动） 750px 970px 1170px   类前缀 .col-xs- .col-sm- .col-md- .col-lg-   列数 12      最大列宽 自动 ~62px ~81px ~97px   槽(gutter)宽 30px （每列左右均有 15px）      可嵌套 是      偏移(Offsets) 是      列排序 是       实例：从堆叠到水平排列  使用单一的一组 .col-md-* 栅格类，就可以创建一个基本的栅格系统 在手机和平板设备上一开始是堆叠在一起的（超小屏幕到小屏幕这一范围） 在桌面（中等）屏幕设备上变为水平排列 所有“列必须放在 ” .row 内  \r\r从堆叠到水平排列\r\r\r\r\rcol-md-1\rcol-md-1\rcol-md-1\rcol-md-1\rcol-md-1\rcol-md-1\rcol-md-1\rcol-md-1\rcol-md-1\rcol-md-1\rcol-md-1\rcol-md-1\r\r\rcol-md-8\rcol-md-4\r\r\rcol-md-4\rcol-md-4\rcol-md-4\r\r\rcol-md-6\rcol-md-6\r\r\r\r后面见官方文档  移动设备和桌面屏幕 列偏移 嵌套列 列排序 \u0026hellip;  ","description":"栅格系统","id":34,"section":"web","tags":null,"title":"02. Grid System","uri":"https://yorkfish.github.io/review/web/bootstrap/02-grid-system/"},{"content":"使用 AJAX 技术  首先，得有 Web 服务器 如，能够通过浏览器去执行 HTML 和 Python   之前写的 HTML，直接在浏览器打开时，使用的是 file 协议 而 AJAX 是基于 HTTP 请求的，所以需要 HTML 能够使用 HTTP 的协议打开 如果能用 HTTP 协议打开 HTML，并且能够正常显示，那就表示 Web 服务器搭建成功   $.get() 1 2 3 4 5 6 7 8  /* 发送 ajax 请求 1. url 2. 可选 发送 get 请求时携带的参数 3. 可选 回调函数，请求完之后做什么事 4. 可选 返回的数据类型 json */ $.get(url, {请求的参数}, function(data){}, \u0026#34;json\u0026#34;);   $.post() 1  $.post(url, {请求的参数}, function(data){}, \u0026#34;json\u0026#34;);   $.ajax() 1 2 3 4 5 6 7 8 9 10 11 12 13 14  $.ajax({ url: \u0026#34;/cgi-bin/5.py\u0026#34;, // 当前请求的 url 地址  type: \u0026#34;get\u0026#34;, // 当前请求的方式 get 或 post  data: {id: 100, username: \u0026#34;zhangsan\u0026#34;}, // 请求时发送的参数  dataType: \u0026#34;json\u0026#34;, // 返回的数据类型  success: function(data) { // ajax 请求成功后执行的代码  console.log(data); }, error: function() { // ajax 执行失败后执行的代码  alert(\u0026#34;ajax 执行错误\u0026#34;); }, timeout: 2000, // 设置当前请求的超时时间毫秒，必须是异步请求才会生效  async: true // 是否异步，true 为异步，false 为同步 });   异步与同步 1 2 3 4 5 6  /* 设置 ajax 的全局配置 async: false 设置当前请求为同步 */ $.ajaxSetup({ async: false // 一般不必写这句 });     async\n 默认是 true，所有请求均为异步请求 如果需要发送同步请求，需将此选项设置为 false    同步请求：发 AJAX 请求发出去后必须等待它的结果，返回后才能继续往下执行\n  一般情况下，都使用异步操作就行\n  除非有特殊情况，如，必须等 AJAX 的结果返回后才能做处理的，才用同步\n  注意  AJAX 是无刷新请求服务器，所以我们在浏览器中感觉不到，也看不到 AJAX 的具体请求和执行情况，因此，我们需要借助浏览器的调试工具 F12 进行查看 AJAX 的请求是基于 HTTP 协议的，这就需要在打开带有 AJAX 的 HTML 时使用 HTTP 协议 关于返回的数据类型  get(), post(), ajax() 都可以设置返回的数据类型 json 如果要求返回 json 格式数据，那么就必须返回 json 如果返回的格式与设置的不匹配  get 和 post 方法将拿不到 data 中返回的数据 AJAX 方法则会走 error 函数     在 Python 中返回 json 格式数据  引入 json 模块 json.dumps(数据)，使用 json_dumps 方法进行 json 格式的编码转换   AJAX 方法，会创建一个对象 XMLHttpRequest，在 AJAX 的方法中使用的 $(this) 代表 AJAX 的对象  ","description":"使用","id":35,"section":"web","tags":null,"title":"02. Usage","uri":"https://yorkfish.github.io/review/web/ajax/02-usage/"},{"content":"1. 外链式  在 body 体中使用 script 标签，并在其中增加 src=\u0026quot;./xxx.js\u0026quot;  1 2 3  \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./static/JS/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt;    之后，需在对应的 .js 文件中写相应代码 script 标签中的 type=\u0026quot;text/javascript\u0026quot; 可以不写，因为这是默认值  2. 嵌入式  在 body 体中使用 script 标签嵌入  1 2 3 4 5 6  \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var a = \u0026#34;你好！\u0026#34;; alert(a); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt;   3. 行间样式  主要用于事件  1 2 3 4  \u0026lt;body\u0026gt; \u0026lt;a href=\u0026#34;javascript:alert(\u0026#39;行间样式生效1\u0026#39;)\u0026#34;\u0026gt;点我\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;javascript:void(0)\u0026#34; onclick=\u0026#34;alert(\u0026#39;行间样式生效2\u0026#39;)\u0026#34;\u0026gt;再点\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt;    href=\u0026quot;javascript:void(0)\u0026quot; 这种形式用得多  ","description":"嵌入页面的方式","id":36,"section":"web","tags":null,"title":"02. Embed a Page","uri":"https://yorkfish.github.io/review/web/javascript/02-embed-a-page/"},{"content":"1. 说明  “标题标签”是“块级标签” “块级标签”也被称为“块元素”  2. 简介  标题标签是常用的有语义的块级元素 有默认样式 独占一行 有 h1 ~ h6 六个级别  3. 示例与效果 示例 1 2 3 4 5 6  \u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;二级标题\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;三级标题\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;四级标题\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;五级标题\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;六级标题\u0026lt;/h6\u0026gt;   效果 一级标题\r二级标题\r三级标题\r四级标题\r五级标题\r六级标题\r","description":"标题标签","id":37,"section":"web","tags":null,"title":"02. Title Label","uri":"https://yorkfish.github.io/review/web/html/02-title-label/"},{"content":"1. 万能头文件  #include \u0026lt;bits/stdc++.h\u0026gt;  2. iostream   包含了许多常用的工具\n cin, cout max(), min()    string\n 有的编译器必须要导入 \u0026lt;string\u0026gt;    scanf(), printf()\n 使用它们的话，最好还是添加一下 \u0026lt;cstdio\u0026gt;    3. cstdio  scanf(), printf()  比 cin, cout 快 scanf() 在有 %c 时，会读空格，此时使用 cin 比较方便 格式化输入，scanf() 比较方便 格式化输出、有精度要求，printf() 比较方便 cout 与 printf() 不要混用   转到定义处可以看到，\u0026lt;cstdio\u0026gt; 导入了 \u0026lt;stdio.h\u0026gt;  4. cstring  strlen(), strcpy(), strcmp() 转到定义处可以看到，\u0026lt;cstring\u0026gt; 导入了 \u0026lt;string.h\u0026gt;  5. cmath  sqrt() 转到定义处可以看到，\u0026lt;cmath\u0026gt; 导入了 \u0026lt;math.h\u0026gt;  ","description":"头文件","id":38,"section":"cpp","tags":null,"title":"02. header file","uri":"https://yorkfish.github.io/review/cpp/02-header-file/"},{"content":" [], at() empty() clear() size() begin(), end() rbegin(), rend() front(), back() push_back(), pop_pack() insert()  insert(p, t) insert(p, n, t) insert(p, i, j)   erase(p) erase(t, k)   1. 简介  vector 是动态数组，使用前需导入 \u0026lt;vector\u0026gt; 支持随机访问，不支持在任意位置 O(1) 插入，即在非末尾插入或删除是线性的时间复杂度 元素的增删一般应该在末尾进行 可以按照字典序比较  2. 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; struct rectangle { int x, y; }; int main() { vector\u0026lt;int\u0026gt; a; // 相当于一个长度动态变化的 int 数组  vector\u0026lt;int\u0026gt; b[233]; // 相当于第一维固定，第二维可变的 int 二维数组  vector\u0026lt;rectangle\u0026gt; c; // 支持自定义的结构体类型  vector\u0026lt;int\u0026gt; d(5); // 定义一个大小为 5 的 vector，默认初值为 0，即 {0, 0, 0, 0, 0}  vector\u0026lt;int\u0026gt; e(3, 6); // 定义一个大小为 3 的 vector，初值为 6，即 {6, 6, 6}  vector\u0026lt;int\u0026gt; f({1, 2, 3}); cout \u0026lt;\u0026lt; f[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f.at(0) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *f.begin() \u0026lt;\u0026lt; endl; vector\u0026lt;int\u0026gt; g{1, 2, 3}; vector\u0026lt;int\u0026gt; h(g.begin(), g.end()); vector\u0026lt;int\u0026gt; i = {g.rbegin(), g.rend()}; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1\r1\r1\r3. 遍历 方式一 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; a{1, 2, 3, 4, 5}; for (unsigned i = 0; i \u0026lt; a.size(); i ++ ) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 4 5 ps   用 int 与 a.size() 比较会有如下 warning\nwarning: comparison of integer expressions of different signedness: 'int' and 'std::vector\u0026lt;int\u0026gt;::size_type' {aka 'unsigned int'} [-Wsign-compare]\r  方式二 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; a{1, 2, 3, 4, 5}; for (vector\u0026lt;int\u0026gt;::iterator i = a.begin(); i != a.end(); i ++ ) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 4 5 方式三 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; a{1, 2, 3, 4, 5}; for (int x : a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 4 5 4. 判空、长度、重置与清空 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; a{1, 2, 3, 4, 5}; cout \u0026lt;\u0026lt; a.empty() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a.size() \u0026lt;\u0026lt; endl; a.resize(10); // 重置并补零  for (int num : a) cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; a.clear(); // 清空  cout \u0026lt;\u0026lt; a.empty() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a.size() \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n0\r5\r1 2 3 4 5 0 0 0 0 0\r1\r0\r5. front \u0026amp; back 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; a{1, 2, 3, 4, 5}; cout \u0026lt;\u0026lt; a.front() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a[0] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; *a.begin() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a.back() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a[a.size() - 1] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; * -- a.end() \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1 1 1\r5 5 5\r6. push_back \u0026amp; pop_back 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; a{1, 2, 3, 4, 5}; a.push_back(6); // 扩容时是倍增扩容  for (int x : a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; a.pop_back(); for (int x : a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 4 5 6 1 2 3 4 5 7. 把迭代器当指针用 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; a{1, 2, 3, 4, 5}; vector\u0026lt;int\u0026gt;::iterator it = a.begin(); cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(it + 1) \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1\r2\r8. insert 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; void print_vector(vector\u0026lt;int\u0026gt;\u0026amp; arr) { for (int x : arr) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; } int main() { vector\u0026lt;int\u0026gt; a{1, 2, 3, 4, 5}; a.insert(a.begin(), 10); print_vector(a); a.insert(a.begin() + 1, 3, 6); print_vector(a); vector\u0026lt;int\u0026gt; b{11, 22, 33}; a.insert(a.end(), b.begin(), b.end()); print_vector(a); a.insert(a.end(), {66, 88}); print_vector(a); return 0; }   \u0026gt;\u0026gt;\u0026gt;\n10 1 2 3 4 5 10 6 6 6 1 2 3 4 5 10 6 6 6 1 2 3 4 5 11 22 33 10 6 6 6 1 2 3 4 5 11 22 33 66 88 9. erase 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; void print_vector(vector\u0026lt;int\u0026gt;\u0026amp; arr) { for (int x : arr) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; } int main() { vector\u0026lt;int\u0026gt; a{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; a.erase(a.begin() + 4, a.begin() + 7); // del [begin+4, begin+7)  print_vector(a); a.erase(a.begin() + 3); // 删除指向的那个元素  print_vector(a); return 0; }   \u0026gt;\u0026gt;\u0026gt;\n0 1 2 3 7 8 9 0 1 2 7 8 9 ","description":"可变数组","id":39,"section":"cpp","tags":null,"title":"02. vector","uri":"https://yorkfish.github.io/review/cpp/stl/02-vector/"},{"content":"1. 常用    符号 匹配对象     . 除 \\n, \\r 外的任意字符   \\d 数字   \\s 空白符，如 \\t, \\n, \\r, \\f, \\v   \\w 字母、数字、下划线（C# 还可以匹配汉字）     \\s, \\w 为小写 数字仅指“阿拉伯数字”   2. 反义    符号 匹配对象     \\D \\d 以外   \\S \\s 以外   \\W \\w 以外    ","description":"原子","id":40,"section":"regex","tags":null,"title":"02. atom","uri":"https://yorkfish.github.io/review/regex/02-atom/"},{"content":"例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import multiprocessing as mp def job(q): res = 0 for i in range(1000): res += i + i**2 + i**3 q.put(res) if __name__ == \u0026#34;__main__\u0026#34;: q = mp.Queue() p1 = mp.Process(target=job, args=(q,)) p2 = mp.Process(target=job, args=(q,)) p1.start() p2.start() p1.join() p2.join() res1 = q.get() res2 = q.get() print(res1 + res2) # 499667166000   例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import multiprocessing import time class ClockProcess(multiprocessing.Process): def __init__(self, interval): super().__init__() self.interval = interval def run(self): while True: ft = time.strftime(\u0026#34;%H:%M:%S\u0026#34;, time.localtime()) print(\u0026#34;The time is \u0026#34; + ft) time.sleep(self.interval) if __name__ == \u0026#34;__main__\u0026#34;: p = ClockProcess(3) p.start() while True: print(\u0026#34;sleeping ...\u0026#34;) time.sleep(1)   \u0026gt;\u0026gt;\u0026gt;\nsleeping ...\rThe time is 10:30:01\rsleeping ...\rsleeping ...\rsleeping ...\rThe time is 10:30:04\rsleeping ...\rsleeping ...\rsleeping ...\rThe time is 10:30:07\r# 后面内容省略\r","description":"创建","id":41,"section":"python","tags":null,"title":"02. create","uri":"https://yorkfish.github.io/review/python/multiprocessing/02-create/"},{"content":"例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import threading import time def thread_job(): print(\u0026#34;start job\\n\u0026#34;) time.sleep(1) print(\u0026#34;finish job\\n\u0026#34;) def main(): added_thread = threading.Thread(target=thread_job, name=\u0026#34;T1\u0026#34;) print(f\u0026#34;{added_thread.name=}, {added_thread.ident=}\u0026#34;) added_thread.start() print(f\u0026#34;{added_thread.name=}, {added_thread.ident=}\u0026#34;) added_thread.join() print(\u0026#34;all done\\n\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main()   \u0026gt;\u0026gt;\u0026gt;\nadded_thread.name='T1', added_thread.ident=None\rstart job\radded_thread.name='T1', added_thread.ident=17000\rfinish job\rall done\r说明  name: 线程名，一般不用说明 ident: 操作系统给的 id  例二  setName() 与 getName()  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import threading import time def thread_job(): print(\u0026#34;start job\\n\u0026#34;) time.sleep(1) print(\u0026#34;finish job\\n\u0026#34;) def main(): added_thread = threading.Thread(target=thread_job) added_thread.start() added_thread.setName(\u0026#34;T1\u0026#34;) print(added_thread.getName()) print(added_thread.name) added_thread.join() print(\u0026#34;all done\\n\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main()   \u0026gt;\u0026gt;\u0026gt;\nstart job\rT1\rT1\rfinish job\rall done\r","description":"线程名与 ID","id":42,"section":"python","tags":null,"title":"02. name and ident","uri":"https://yorkfish.github.io/review/python/threading/02-name-and-ident/"},{"content":"例一 创建两条线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void* test(void* args) { int i; for (i = 0; i \u0026lt; 100; i++) { printf(\u0026#34;%d\\n\u0026#34;, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, test, NULL); pthread_create(\u0026amp;th2, NULL, test, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; }   例二 给线程传参 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; void* test(void* args) { int i; char* name = (char*)args; for (i = 0; i \u0026lt; 100; i++) { printf(\u0026#34;%s: %d\\n\u0026#34;, name, i); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, test, \u0026#34;th1\u0026#34;); pthread_create(\u0026amp;th2, NULL, test, \u0026#34;th2\u0026#34;); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; }   例三 分工  把 5000 个随机数均分给两条线程作相加  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int array[5000]; int sum1 = 0; int sum2 = 0; void* test1(void* args) { int i; for (i = 0; i \u0026lt; 2500; i++) { sum1 += array[i]; } return NULL; } void* test2(void* args) { int i; for (i = 2500; i \u0026lt; 5000; i++) { sum2 += array[i]; } return NULL; } int main() { int i; for (i = 0; i \u0026lt; 5000; i++) { array[i] = rand() % 50; } pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, test1, NULL); pthread_create(\u0026amp;th2, NULL, test2, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); printf(\u0026#34;sum1 = %d\\n\u0026#34;, sum1); printf(\u0026#34;sum2 = %d\\n\u0026#34;, sum2); printf(\u0026#34;sum1 + sum2 = %d\\n\u0026#34;, sum1+sum2); return 0; }   例四 合并  改进例三，合并 test1 与 test2  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; typedef struct { int first; int last; } MY_ARGS; int array[5000]; void* test(void* args) { int i; int sum = 0; MY_ARGS* my_args = (MY_ARGS*)args; int first = my_args-\u0026gt;first; int last = my_args-\u0026gt;last; for (i = first; i \u0026lt; last; i++) { sum += array[i]; } printf(\u0026#34;sum = %d\\n\u0026#34;, sum); return NULL; } int main() { int i; for (i = 0; i \u0026lt; 5000; i++) { array[i] = rand() % 50; } pthread_t th1; pthread_t th2; MY_ARGS args1 = {0, 2500}; MY_ARGS args2 = {2500, 5000}; pthread_create(\u0026amp;th1, NULL, test, \u0026amp;args1); pthread_create(\u0026amp;th2, NULL, test, \u0026amp;args2); pthread_join(th1, NULL); pthread_join(th2, NULL); return 0; }   例五  继续改进，使得结果可以回传  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; typedef struct { int first; int last; int result; } MY_ARGS; int array[5000]; void* test(void* args) { int i; int sum = 0; MY_ARGS* my_args = (MY_ARGS*)args; int first = my_args-\u0026gt;first; int last = my_args-\u0026gt;last; for (i = first; i \u0026lt; last; i++) { sum += array[i]; } my_args-\u0026gt;result = sum; return NULL; } int main() { int i; for (i = 0; i \u0026lt; 5000; i++) { array[i] = rand() % 50; } pthread_t th1; pthread_t th2; MY_ARGS args1 = {0, 2500, 0}; MY_ARGS args2 = {2500, 5000, 0}; pthread_create(\u0026amp;th1, NULL, test, \u0026amp;args1); pthread_create(\u0026amp;th2, NULL, test, \u0026amp;args2); pthread_join(th1, NULL); pthread_join(th2, NULL); int sum1 = args1.result; int sum2 = args2.result; printf(\u0026#34;sum1 = %d\\n\u0026#34;, sum1); printf(\u0026#34;sum2 = %d\\n\u0026#34;, sum2); printf(\u0026#34;sum1 + sum2 = %d\\n\u0026#34;, sum1+sum2); return 0; }   ","description":"传参、分工与合作","id":43,"section":"c","tags":null,"title":"02. 两条线程","uri":"https://yorkfish.github.io/review/c/thread/02-two-threads/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. 添加一个 label 1 2 3  l = tk.Label(window, text=\u0026#34;This is Label!\u0026#34;, bg=\u0026#34;green\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), width=20, height=2) l.pack()   ps  一般地，tkinter 的 width, height 的单位是“字符”  3. 字符串可以使用变量 1 2 3 4 5  string = tk.StringVar() string.set(\u0026#34;This is Label!\u0026#34;) l = tk.Label(window, textvariable=string, bg=\u0026#34;green\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 216), width=20, height=2) l.pack()   1 2 3 4 5 6 7 8 9 10 11 12 13  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) string = tk.StringVar() string.set(\u0026#34;This is Label!\u0026#34;) l = tk.Label(window, textvariable=string, bg=\u0026#34;green\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), width=20, height=2) l.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"标签控件","id":44,"section":"python","tags":null,"title":"02. Label","uri":"https://yorkfish.github.io/review/python/tkinter/02-label/"},{"content":"1. 简介  __dict__ 属性可以让用户查看类中包含的属性 __dict__ 可以用类名调用，也可以用类的实例对象调用     调用者 输出     类名 该类中所有类属性组成的字典   类的实例对象 该类中所有实例属性组成的字典    2. 举例 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; class Hero(object): ... def __init__(self, name, slogan): ... self.name = name ... self.slogan = slogan ... \u0026gt;\u0026gt;\u0026gt; Hero.__dict__ mappingproxy({\u0026#39;__module__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__init__\u0026#39;: \u0026lt;function Hero.__init__ at 0x000002325ADBE550\u0026gt;, \u0026#39;__dict__\u0026#39;: \u0026lt;attribute \u0026#39;__dict__\u0026#39; of \u0026#39;Hero\u0026#39; objects\u0026gt;, \u0026#39;__weakref__\u0026#39;: \u0026lt;attribute \u0026#39;__weakref__\u0026#39; of \u0026#39;Hero\u0026#39; objects\u0026gt;, \u0026#39;__doc__\u0026#39;: None}) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; lijing = Hero(\u0026#34;lijing\u0026#34;, \u0026#34;My hands, you will!\u0026#34;) \u0026gt;\u0026gt;\u0026gt; lijing.__dict__ {\u0026#39;name\u0026#39;: \u0026#39;lijing\u0026#39;, \u0026#39;slogan\u0026#39;: \u0026#39;My hands, you will!\u0026#39;} \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":45,"section":"python","tags":null,"title":"02. __dict__","uri":"https://yorkfish.github.io/review/python/class/02-dict/"},{"content":"1. 说明  any(), all() 都可以批量判断可迭代对象里的参数是否等价于 True 简单地说  any() : 有人 True，那就 True all() : 大家 True，才是 True    2. 举例 any   可以这样理解 any()\n1 2 3 4 5  def any(iterable): for element in iterable: if element: return True return False     0, '', False, None, [], (), {}, set() 均视作 False\n1 2 3  \u0026gt;\u0026gt;\u0026gt; any([0, \u0026#39;\u0026#39;, False, None, [], (), {}, set()]) False \u0026gt;\u0026gt;\u0026gt;     all   可以这样理解 all()\n1 2 3 4 5  def all(iterable): for element in iterable: if not element: return False return True     ","description":"","id":46,"section":"python","tags":null,"title":"02. any() \u0026 all()","uri":"https://yorkfish.github.io/review/python/bif/02-any-all/"},{"content":"1. 说明  若函数形如 test(arg, *args, **kwargs)，则  arg: 接收第一个参数 args: 若有，凑成元组 kwargs: 若有，凑成字典    2. 举例 1 2 3 4 5  def test(arg, *args, **kwargs): print(f\u0026#34;{arg=}, {args=}, {kwargs=}\u0026#34;) test(1, 2, student=\u0026#34;Tom\u0026#34;, teacher=\u0026#34;Jerry\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\narg=1, args=(2,), kwargs={'student': 'Tom', 'teacher': 'Jerry'}\r","description":"","id":47,"section":"python","tags":null,"title":"02. arg, args, kwargs","uri":"https://yorkfish.github.io/review/python/basics/02-arg-args-kwargs/"},{"content":"举例思路  不加装饰器 加装饰器  无参函数 带参函数  参数个数确定 参数个数不确定   装饰器带参 多个装饰器    例一 不加装饰器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def out(func): def inn(): start = perf_counter() func() stop = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; function\u0026#39;s run time:\u0026#34;, stop - start) return inn def append_str(): lst = [] for i in range(10000): lst.append(\u0026#34;YorkFish\u0026#34;) return None func = out(append_str) func()   例二 修改例一  装饰器就是在不改变函数原有功能且不改变原有代码逻辑下，增加函数的功能  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  from time import perf_counter def out(func): def inn(): start = perf_counter() func() stop = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; function\u0026#39;s run time:\u0026#34;, stop - start) return inn # 有顺序，要写在 out() 下面 @out def append_str(): lst = [] for i in range(10000): lst.append(\u0026#34;YorkFish\u0026#34;) return None append_str()   例三 不加 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from time import perf_counter def test(): lst = [] for _ in range(10000): lst.append(\u0026#34;YorkFish\u0026#34;) return None def cal_time(func): start = perf_counter() func() stop = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; function\u0026#39;s run time:\u0026#34;, stop - start) return None cal_time(test)   例四 加-无参函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  from time import perf_counter def cal_time(func): def inn(): start = perf_counter() func() stop = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; function\u0026#39;s run time:\u0026#34;, stop - start) return inn @cal_time def test(): lst = [] for _ in range(10000): lst.append(\u0026#34;YorkFish\u0026#34;) return None test()   例五 加-带参函数-参数个数确定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from time import perf_counter_ns def cal_time(func): def inn(x, y): start = perf_counter_ns() func(x, y) stop = perf_counter_ns() print(f\u0026#34;run time: {stop - start}ns\u0026#34;) return inn @cal_time def add2(x, y): print(x + y) return None add2(3, 4)   例六 加-带参函数-参数个数不确定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  from time import perf_counter_ns def cal_time(func): def inn(*args): start = perf_counter_ns() func(*args) stop = perf_counter_ns() print(f\u0026#34;run time: {stop - start}ns\u0026#34;) return inn @cal_time def add(*args): print(sum(args)) add(1, 2, 3, 4, 5)   例七 加-装饰器带参 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  from time import perf_counter_ns def out(num): print(\u0026#34;\u0026gt;\u0026gt; num =\u0026#34;, num) def cal_time(func): print(\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt; func =\u0026#34;, func) def inn(*args): print(\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; args =\u0026#34;, args) start = perf_counter_ns() func(*args) stop = perf_counter_ns() print(f\u0026#34;run time: {stop - start}ns\u0026#34;) return inn return cal_time @out(0) def add(*args): print(sum(args)) return None add(1, 2, 3, 4, 5)   例八 加多个装饰器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def deco1(func): print(\u0026#34;\u0026gt;\u0026gt; run decorator1\u0026#34;) def inn(): print(\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt; decorator1\u0026#39;s in\u0026#34;) func() return inn def deco2(func): print(\u0026#34;\u0026gt;\u0026gt; run decorator2\u0026#34;) def inn(): print(\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt; decorator2\u0026#39;s in\u0026#34;) func() return inn @deco2 # 西装 @deco1 # 衬衫 def test(): print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; run test\u0026#34;) return None test()   \u0026gt;\u0026gt;\u0026gt;\n\u0026gt;\u0026gt; run decorator1\r\u0026gt;\u0026gt; run decorator2\r\u0026gt;\u0026gt;\u0026gt;\u0026gt; decorator2's in\r\u0026gt;\u0026gt;\u0026gt;\u0026gt; decorator1's in\r\u0026gt;\u0026gt;\u0026gt; run test\r","description":"","id":48,"section":"python","tags":null,"title":"02. decorator-function","uri":"https://yorkfish.github.io/review/python/decorator/02-decorator-for-func/"},{"content":"1. 说明  n dimension array 简单地说，就是多维数组  2. 操作 导入 1  import numpy as np   创建 整数 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3, 4]) \u0026gt;\u0026gt;\u0026gt; a array([1, 2, 3, 4]) \u0026gt;\u0026gt;\u0026gt; print(a) [1 2 3 4] \u0026gt;\u0026gt;\u0026gt;   复数 1 2 3  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3, 4], dtype=complex) \u0026gt;\u0026gt;\u0026gt; print(a) [1.+0.j 2.+0.j 3.+0.j 4.+0.j]   二维 方式一 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3, 4], dtype=complex).reshape((2, 2)) \u0026gt;\u0026gt;\u0026gt; print(a) [[1.+0.j 2.+0.j] [3.+0.j 4.+0.j]] \u0026gt;\u0026gt;\u0026gt;   方式二 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; b = np.array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; print(b) [[1 2 3] [4 5 6]] \u0026gt;\u0026gt;\u0026gt;   “0 矩阵” 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = np.zeros((2, 2)) \u0026gt;\u0026gt;\u0026gt; print(a) [[0. 0.] [0. 0.]] \u0026gt;\u0026gt;\u0026gt;   “1 矩阵” 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = np.ones((2, 2)) \u0026gt;\u0026gt;\u0026gt; print(a) [[1. 1.] [1. 1.]] \u0026gt;\u0026gt;\u0026gt;   空矩阵 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = np.empty((2, 3)) \u0026gt;\u0026gt;\u0026gt; print(a) [[0. 0. 0.] [0. 0. 0.]] \u0026gt;\u0026gt;\u0026gt;   单位矩阵 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.eye(3) \u0026gt;\u0026gt;\u0026gt; print(a) [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] \u0026gt;\u0026gt;\u0026gt;   arange  用法与 range 相似  整数 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = np.arange(0, 10, 2) \u0026gt;\u0026gt;\u0026gt; print(a) [0 2 4 6 8] \u0026gt;\u0026gt;\u0026gt;   浮点数  由于有限的浮点精度，获得的元素个数可能与预期有些出入  1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.arange(0, 3, 0.2) \u0026gt;\u0026gt;\u0026gt; print(a) [0. 0.2 0.4 0.6 0.8 1. 1.2 1.4 1.6 1.8 2. 2.2 2.4 2.6 2.8] \u0026gt;\u0026gt;\u0026gt; type(a[0]) \u0026lt;class \u0026#39;numpy.float64\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;   均分 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = np.linspace(0, 3, 10) \u0026gt;\u0026gt;\u0026gt; print(a) [0. 0.33333333 0.66666667 1. 1.33333333 1.66666667 2. 2.33333333 2.66666667 3. ] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":49,"section":"python","tags":null,"title":"02. ndarray build","uri":"https://yorkfish.github.io/review/python/numpy/02-ndarray-build/"},{"content":"1. 查看配置文件地址 C:\\Users\\York\u0026gt;pip config list -v\rFor variant 'global', will try loading 'C:\\ProgramData\\pip\\pip.ini'\rFor variant 'user', will try loading 'C:\\Users\\York\\pip\\pip.ini'\rFor variant 'user', will try loading 'C:\\Users\\York\\AppData\\Roaming\\pip\\pip.ini'\rFor variant 'site', will try loading 'c:\\users\\york\\appdata\\local\\programs\\python\\python38\\pip.ini'\r answer: C:\\Users\\York\\AppData\\Roaming\\pip\\pip.ini  2. 使用命令写入文件 C:\\Users\\York\u0026gt;pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/\rWriting to C:\\Users\\York\\AppData\\Roaming\\pip\\pip.ini\r3. 使用命令查看内容  C:\\Users\\York\u0026gt;pip config edit --editor notepad  此时，记事本会打开 pip.ini    4. 更改镜像源   阿里镜像站：\u0026gt;\u0026gt;\u0026gt; 传送门 \n  选择 pypi\n  复制提供的命令，覆盖 pip.ini 的内容\n[global]\rindex-url = https://mirrors.aliyun.com/pypi/simple/\r[install]\rtrusted-host=mirrors.aliyun.com\r  ","description":"","id":50,"section":"python","tags":null,"title":"02. pip","uri":"https://yorkfish.github.io/review/python/operation/02-pip/"},{"content":"例一 随机数 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.random() # [0, 1.0) 0.010390541410120413 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; random.uniform(1, 10) # [1.0, 10.0) 2.2700210248026065 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; random.randrange(1, 10) # [1, 10) 3 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; random.randint(1, 10) # [1, 10] 8 \u0026gt;\u0026gt;\u0026gt;   ps   randint 其实是调用 randrange\n1 2  def randint(self, a, b): return self.randrange(a, b+1)     例二 抽取 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; menus = [\u0026#34;煲仔饭\u0026#34;, \u0026#34;黄焖鸡米饭\u0026#34;, \u0026#34;牛肉盖浇饭\u0026#34;, \u0026#34;排骨饭\u0026#34;, \u0026#34;芝士焗饭\u0026#34;] \u0026gt;\u0026gt;\u0026gt; random.choice(menus) \u0026#39;黄焖鸡米饭\u0026#39; \u0026gt;\u0026gt;\u0026gt; random.choices(menus, [1, 2, 3, 4, 5]) # choices; 加权 [\u0026#39;排骨饭\u0026#39;] \u0026gt;\u0026gt;\u0026gt; random.choices(menus, [1, 2, 3, 4, 5], k=2) # 别漏 \u0026#34;k=\u0026#34; [\u0026#39;排骨饭\u0026#39;, \u0026#39;排骨饭\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   ps  random.choices(population,weights=None,*,cum_weights=None,k=1) weights=[1, 2, 3, 4, 5], P(煲仔饭) = 1/(1+2+3+4+5) = 1/15  例三 抽取 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; menus = [\u0026#34;煲仔饭\u0026#34;, \u0026#34;黄焖鸡米饭\u0026#34;, \u0026#34;牛肉盖浇饭\u0026#34;, \u0026#34;排骨饭\u0026#34;, \u0026#34;芝士焗饭\u0026#34;] \u0026gt;\u0026gt;\u0026gt; random.sample(menus, k=2) # k \u0026lt;= len(menus) [\u0026#39;芝士焗饭\u0026#39;, \u0026#39;牛肉盖浇饭\u0026#39;] \u0026gt;\u0026gt;\u0026gt; random.sample(menus, 2) # 可省 \u0026#34;k=\u0026#34; [\u0026#39;排骨饭\u0026#39;, \u0026#39;牛肉盖浇饭\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   例四 打乱 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; random.shuffle(a) \u0026gt;\u0026gt;\u0026gt; a [3, 1, 4, 2, 5] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":51,"section":"python","tags":null,"title":"02. random","uri":"https://yorkfish.github.io/review/python/module/02-random/"},{"content":"1. 打开文件 fopen 一般形式 FILE * fp;\rfp = fopen(\u0026quot;filename\u0026quot;, \u0026quot;usemode\u0026quot;);\r打开模式    文件使用方式 含义     \u0026quot;r\u0026quot; 读，打开   \u0026quot;w\u0026quot; 写，打开   \u0026quot;a\u0026quot; 追加，打开   \u0026quot;rb\u0026quot; 读，二进制打开   \u0026quot;wb\u0026quot; 写，二进制打开   \u0026quot;ab\u0026quot; 追加，二进制打开   \u0026quot;r+\u0026quot; 读写，打开   \u0026quot;w+\u0026quot; 读写，新建   \u0026quot;a+\u0026quot; 读写，打开   \u0026quot;rb+\u0026quot; 读写，二进制打开   \u0026quot;wb+\u0026quot; 读写，二进制新建   \u0026quot;ab+\u0026quot; 读写，二进制打开    说明   输入文件：从文件读数据\n  输出文件：向文件写数据\n  如果不能实现“打开”的任务，fopen 函数将会带回一个出错信息，并返回空指针值 NULL\n  出错原因可能是\n 用 \u0026quot;r\u0026quot; 方式打开一个并不存在的文件 磁盘出故障 磁盘已满，无法建立新文件 。。。    有的版本只能用 \u0026quot;r\u0026quot;, \u0026quot;w\u0026quot;, \u0026quot;a\u0026quot;\n  有的版本用 \u0026quot;rw\u0026quot;, \u0026quot;wr\u0026quot;, \u0026quot;ar\u0026quot; 代替 \u0026quot;r+\u0026quot;, \u0026quot;w+\u0026quot;, \u0026quot;a+\u0026quot;\n  在向计算机输入文本文件时，回车换行会转换为一个换行符\n  在输出时，把换行符转换成为回车和换行两个字符\n  用二进制文件时，不进行这种转换\n  在程序开始运行时，系统自动打开三个标准文件\n 标准输入 stdin 标准输出 stdout 标准出错输出 stderr    2. 关闭文件 fclose 一般形式 fclose(fp);\n说明  先把缓冲区中的数据输出到磁盘文件，然后才释放文件指针变量  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; int main() { char* filename = \u0026#34;test.txt\u0026#34;; FILE* fp = fopen(filename, \u0026#34;r\u0026#34;); if (fp == NULL) { printf(\u0026#34;cannot open %s!\\n\u0026#34;, filename); printf(\u0026#34;let me help you to build it...\\n\u0026#34;); fp = fopen(filename, \u0026#34;w\u0026#34;); } fclose(fp); return 0; }   ","description":"","id":52,"section":"c","tags":null,"title":"02. fopen() \u0026 fclose()","uri":"https://yorkfish.github.io/review/c/file/02-fopen-and-fclose/"},{"content":"例一 取某几位数  求整数 a 右端的 4~7 位  原码：xxxx ... xxxx xxxx\r位数：xxxx ... 7654 3210\r1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { short a = 666; // 0b0000 0010 1001 1010  short b = (a\u0026gt;\u0026gt;4) \u0026amp; ~(~0 \u0026lt;\u0026lt; 4); char c[4]; itoa(b, c, 2); printf(\u0026#34;%s\\n\u0026#34;, c); // 1001  return 0; }   例二 循环移位  将 a 进行右循环移位 4 位  移位前：xxxx ... xxxx x???\r移位后：???x ... xxxx xxxx\r1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { unsigned short a = 666; // 0b0000 0010 1001 1010  unsigned short b = a\u0026lt;\u0026lt;(16-4) | a\u0026gt;\u0026gt;4; char c[16]; itoa(b, c, 2); printf(\u0026#34;%s\\n\u0026#34;, c); // 1010 0000 0010 1001  return 0; }   例三 改变字节中 n 个二进制位  将整数 a 右端的 4~7 位改为 1101  1 2 3  data = (data \u0026amp; ~(15\u0026lt;\u0026lt;4)) | (n\u0026amp;15)\u0026lt;\u0026lt;4 -------- ------ 1111 ... 0000 1111 0 \u0026lt;= n\u0026#39; \u0026lt;= 15   1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { short a = 666; // 0b0000 0010 1001 1010  short b = 0b1101; short c = (a \u0026amp; ~(15\u0026lt;\u0026lt;4)) | (b\u0026amp;15)\u0026lt;\u0026lt;4; char d[16]; itoa(c, d, 2); printf(\u0026#34;%s\\n\u0026#34;, d); // 0000 0010 1101 1010  return 0; }   ","description":"","id":53,"section":"c","tags":null,"title":"02. 举例","uri":"https://yorkfish.github.io/review/c/bit/02-examples/"},{"content":"1. 默认类型  如果在定义函数时不指定函数类型，系统会隐含指定函数类型为 int 不推荐这样做  2. 空函数   形式\n1 2  void dummy() { }     调用此函数时，什么工作也不做，没有任何实际作用\n  等以后扩充函数功能时补上\n  ","description":"","id":54,"section":"c","tags":null,"title":"02. 函数定义","uri":"https://yorkfish.github.io/review/c/function/02-general-form/"},{"content":"1. 一般形式  #define 宏名(参数表) 字符串 如  定义：#define S(a,b) a*b 使用：area = S(3, 2); // 矩形边长    2. 两个注意点 坑一 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; #define S(a,b) a*b  int main() { int area = S(5, 5+10); // 5 X 15  printf(\u0026#34;%d\\n\u0026#34;, area); // 35  return 0; }     解释\n area = S(5, 5+10); -\u0026gt; area = 5*5+10; -\u0026gt; area = 35;    改正\n #define S(a,b) (a)*(b)    坑二 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; #define S (a,b) a*b // S 后多了个空格  int main() { int area = S(5, 5+10); // 报错  printf(\u0026#34;%d\\n\u0026#34;, area); return 0; }    解释  宏名与带参数的括号之间不应加空格 第一个空格以后的字符都放会作为代替字符串 int area = S(5, 5+10); -\u0026gt; int area = (a,b) a*b(5, 5+10); -\u0026gt; 报错    3. 说明  函数调用时，先求出实参表达式的值，再带入形参 函数调用是在程序运行时处理的，为形参分配临时的内存单元 宏展开是在编译前进行的，展开时并不分配内存空间，不进行值的传递，也没有返回值的概念 对函数中的实参和形参都要定义类型，二者要求一致，如不一致，应进行类型转换 宏不存在类型问题，宏名无类型，它的参数也无类型，只是一个符号代表 展开时代入指定的字符串即可 宏定义时，字符串可以是任何类型的数据  字符：#define CHAR1 CHINA 数值：#define a 3.6 。。。    4. 取舍  通过宏展开可以得到若干个结果 使用宏次数多时，宏展开后源程序变长，因为每展开一次都使得程序增长 函数调用不会使源程序变长 宏替换不占用运行时间，只占用编译时间 函数调用占运行时间（分配单元、保留现场、值传递、返回） 一般用宏来代表简短的表达式比较合适 有些问题，用宏和函数都可以  5. 补充  可以写出各种输入输出的格式，如  单精度浮点型、双精度浮点型 长整型 十六进制整数、八进制整数 字符型 。。。   把它们单独编成一个文件，相当一个“格式库” 用 #include 命令“包括”到自己所编的程序中  ","description":"","id":55,"section":"c","tags":null,"title":"02. 带参宏定义","uri":"https://yorkfish.github.io/review/c/preprocessor/02-with-parameters/"},{"content":"1. 定义 1 2 3  int i; int * pointer_1; pointer_1 = \u0026amp;i;    将变量 i 的地址存放到指针变量 pointer_1 中，pointer_1 “指向”了变量 i 指针变量中只能存放地址（指针）  2. 两个运算符  \u0026amp;: 取地址运算符 *: 指针运算符，取指针所指向的对象的内容  ps   \u0026amp;, *, ++ 优先级相同，一般按“自右而左”方向结合\n  参照\n1 2  int num = 10; int* p = \u0026amp;num;     下方左右写法等价\n     左 右     \u0026amp;*p \u0026amp;num   *\u0026amp;num num   (*p)++ num++   *p++ *(p++)    3. 反例 例一 1 2 3 4 5 6  void swap(int* p1, int* p2) { int* temp; *temp = *p1; // 这句有问题，因为 temp 没有指向某片地址  *p1 = *p2; *p2 = *temp; }   例二 1 2 3 4 5 6  void swap(int a, int b) { int t; t = a; a = b; b = t; }    这是“单向传递”的“值传递”方式 形参值的改变不能使实参的值随之改变  例三 1 2 3 4 5 6  void swap(int* p1, int* p2) { int *p; p = p1; p1 = p2; p2 = p; }    swap 中，指针的指向对调了，但不改变实参的地址 这里不要多想，直接通过地址改值就行  ","description":"","id":56,"section":"c","tags":null,"title":"02. 指针的定义与使用","uri":"https://yorkfish.github.io/review/c/pointer/02-definition-and-use-of-pointer/"},{"content":" ANSI C 标准没有规定标识符的长度（字符个数） C 标准建议至少应能识别 31 个字符 若两个标识符很长，但不同之处在头部的可识别范围内，则编译器可辨别  ","description":"","id":57,"section":"c","tags":null,"title":"02. 标识符长度","uri":"https://yorkfish.github.io/review/c/basics/02-length-of-identifier/"},{"content":"1. 标签选择器  影响范围大 建议尽量应用在层级选择器中  1 2  \u0026lt;!-- body 体中的 div --\u0026gt; \u0026lt;div\u0026gt;box...\u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8  /* style 中的设置 */ *{ margin: 0; /* 边距属性 */ padding: 0; /* 内边距 */ } div{ color: red; /* 设置文本颜色 */ }    上方的语句，如 padding: 0; color: red; 末尾可以不加分号，因为它们在各自的最后一行 不过推荐加分号  2. id 选择器  通过 id 名来选择元素 元素的 id 名不能重复 一般不推荐使用 id 作为选择器  1 2 3  \u0026lt;!-- body 体中的 div --\u0026gt; \u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt;box...\u0026lt;/div\u0026gt;   1 2 3 4  /* style 中的设置 */ #box{ color: red; }   3. 类选择器  影响范围相对较小 通过类名来选择元素 一个类可应用于多个元素 一个元素上也可以使用多个类 是 CSS 中应用最多的一种选择器  1 2 3 4  \u0026lt;!-- body 体中的 div 等 --\u0026gt; \u0026lt;div class=\u0026#34;div_box\u0026#34;\u0026gt;div_box...\u0026lt;/div\u0026gt; \u0026lt;h1 class=\u0026#34;h1_box\u0026#34;\u0026gt;h1_box...\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;p_box\u0026#34;\u0026gt;p_box...\u0026lt;/p\u0026gt;   1 2 3 4 5 6 7 8 9 10  /* style 中的设置 */ .div_box{ color: red; } .h1_box{ font-size: 20px; /* 字体大小 */ } .p_box{ margin-top: 10px; /* 设置元素的上外边距 */ }   4. 层级选择器  主要应用在  选择父元素下的子元素 子元素下面的子元素   可与标签元素结合使用，减少命名 可以通过层级，防止命名冲突 可以和多种选择器混合使用  1 2 3 4 5 6 7  \u0026lt;!-- body 体中的 div 等 --\u0026gt; \u0026lt;div class=\u0026#34;div_box\u0026#34;\u0026gt; \u0026lt;span\u0026gt;span...\u0026lt;/span\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;a_h_box\u0026#34;\u0026gt;a...\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h3 class=\u0026#34;a_h_box\u0026#34;\u0026gt;h3...\u0026lt;/h3\u0026gt;   1 2 3 4 5 6 7 8 9 10  /* style 中的设置 */ .div_box span{ color: red; } .div_box .a_h_box{ color: blue; } .a_h_box{ color: green; }   5. 组织选择器  多个选择器，如果有同样的样式设置，可以使用组选择器 也称为并列选择器  1 2 3 4  \u0026lt;!-- body 体中的 div --\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;box3...\u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* style 中的设置 */ .box1, .box2, .box3{ width: 100px; height: 100px; } .box1{ background: blue; } .box2{ background: green; } .box2{ background: yellow; }   6. 伪类选择器  hover 是常用的伪类选择器，表示鼠标悬浮在元素上时的状态  1 2  \u0026lt;!-- body 体中的 div --\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;box...\u0026lt;/div\u0026gt;   1 2 3 4  /* style 中的设置 */ .box:hover{ /* 此处的冒号前后不要加空格 */ color: red; }   7. 伪元素选择器  before 和 after 是伪元素选择器，它们可以通过样式在元素中插入内容  1 2 3 4  \u0026lt;!-- body 体中的 div --\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;a\u0026gt;123\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  /* style 中的设置 */ a:hover{ color: red; text-decoration: underline; /* 加下划线 */ } /* 鼠标在该元素上时 */ a:before{ content:\u0026#34;Hello\u0026#34;; } /* 在每个 \u0026lt;a\u0026gt; 元素之前插入 Hello */ a:after{ content:\u0026#34;World\u0026#34;; } /* 在每个 \u0026lt;a\u0026gt; 元素之后插入 World */   选择器的优先级  影响范围越大的选择器优先级最低 打个不太恰当的比喻  左冷禅（如标签选择器）是五岳盟主，执五岳令旗，霸权五岳剑派 岳不群（如类选择器）是华山派掌门，虽说要听那个左盟主的号令，但华山派的事还是自己说了算 令狐冲（如 id 选择器）是华山派首徒，平时是可以“为所欲为”的    ","description":"七种常见的选择器","id":58,"section":"web","tags":null,"title":"02. Common Selectors","uri":"https://yorkfish.github.io/review/web/css/02-7-common-selectors/"},{"content":"1. 先声明，再定义 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; }; int main() { struct student st1; return 0; }   2. 声明的同时定义 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; } st1; int main() { return 0; }   3. 直接定义 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; struct { char name[20]; char gender; int num; } st1; int main() { return 0; }   ps   类型与变量是不同的概念\n  结构体中的成员，即域，可以单独使用\n  成员也可以是一个结构体变量\n1 2 3 4 5 6 7 8 9 10 11 12  struct date { int year; int month; int day; }; struct student { char name[20]; char gender; int num; struct date birthday; };     成员名可以与程序中的变量名相同，二者不代表同一对象\n  ","description":"","id":59,"section":"c","tags":null,"title":"02. 定义方法","uri":"https://yorkfish.github.io/review/c/struct-union-enum/02-define/"},{"content":"1. 用法 用法一  缩进 + 程序代码  缩进是 n 个 Tab，一般比上一层缩进多一    用法二  ``` + [语言名] + 程序代码 + ```  用法三  借助 HTML 的标签 \u0026lt;code\u0026gt;  需要配合换行标签 \u0026lt;br\u0026gt;    2. 说明  代码中有 ``` 时，可以考虑方法一 有些符号需要转义，放到代码块中可以省去些麻烦  3. 示例与效果 用法一   示例\n print(\u0026quot;Markdown\u0026quot;)\rprint('1')\rprint('2')\r  效果\n print(\u0026quot;Markdown\u0026quot;)\rprint('1')\rprint('2')\r   用法二   示例\n ```python\rprint(\u0026quot;Markdown\u0026quot;)\rprint('1')\rprint('2')\r​```\r   效果\n1 2 3  print(\u0026#34;Markdown\u0026#34;) print(\u0026#39;1\u0026#39;) print(\u0026#39;2\u0026#39;)     用法三   示例\n\u0026lt;code\u0026gt;\rprint(\u0026quot;Markdown\u0026quot;) \u0026lt;br\u0026gt;\rprint('1') \u0026lt;br\u0026gt;\rprint('2')\r\u0026lt;/code\u0026gt;\r  效果\n\rprint(\"Markdown\") print('1') print('2')\r\r  ","description":"","id":60,"section":"markdown","tags":null,"title":"03. 代码块","uri":"https://yorkfish.github.io/review/markdown/03-code-blocks/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \\documentclass[UTF8]{ctexbook} \\begin{document} % 更大的章节  \\part{第一卷} \\chapter{第一章 \\LaTeX 简介} % 字体  \\textbf{加粗} \\textit{斜体} \\underline{下划线} % 添加新的段落需要使用两个换行符  \\end{ducument}   ","description":"书籍结构","id":61,"section":"latex","tags":null,"title":"03. Book Structure","uri":"https://yorkfish.github.io/review/latex/03-book-structure/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;outline\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p v-html=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p v-text=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { msg: \u0026#34;\u0026lt;h1\u0026gt;你好\u0026lt;/h1\u0026gt;\u0026#34; } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   说明  v-html 可以解析标签 v-text 不能解析标签  ","description":"文本指令","id":62,"section":"web","tags":null,"title":"03. Text Instruction","uri":"https://yorkfish.github.io/review/web/vue/03-text-instruction/"},{"content":"可以通过 jQuery 操作控制元素的样式、文本、属性等 1. 样式操作  CSS 操作行内样式  1 2 3 4 5 6 7 8  // 1. 获取 div 的样式 $(\u0026#34;div\u0026#34;).css(\u0026#34;width\u0026#34;); $(\u0026#34;div\u0026#34;).css(\u0026#34;color\u0026#34;); // 2. 设置 div 的样式 $(\u0026#34;div\u0026#34;).css(\u0026#34;width\u0026#34;, \u0026#34;30px\u0026#34;); $(\u0026#34;div\u0026#34;).css(\u0026#34;height\u0026#34;, \u0026#34;30px\u0026#34;); $(\u0026#34;div\u0026#34;).css({fontSize: \u0026#34;30px\u0026#34;, color: \u0026#34;red\u0026#34;});    选择器获取多个元素的信息时，获取的是第一个元素的信息 如 $(\u0026quot;div\u0026quot;).css(\u0026quot;width\u0026quot;) 获取的是第一个 div 的 width   2. 类名 class 操作  操作样式类名  1 2 3 4  $(\u0026#34;#div1\u0026#34;).addClass(\u0026#34;divClass2\u0026#34;) // 给 id=div1 的对象追加样式 divClass2 $(\u0026#34;#div1\u0026#34;).removeClass(\u0026#34;divClass\u0026#34;) // 移除 id=div1 的对象的 class=divClass 的样式 $(\u0026#34;#div1\u0026#34;).removeClass(\u0026#34;divClass divClass2\u0026#34;) // 移除多个样式 $(\u0026#34;#div1\u0026#34;).toggleClass(\u0026#34;anotherClass\u0026#34;) // 重复切换 anotherClass 样式   3. 文本操作 html() 1 2 3 4 5  // 取出 html 内容 var $htm = $(\u0026#39;#div1\u0026#39;).html(); // 设置 html 内容 $(\u0026#39;#div1\u0026#39;).html(\u0026#39;\u0026lt;span\u0026gt;添加文字\u0026lt;/span\u0026gt;\u0026#39;);   text() 1 2 3 4 5  // 取出文本内容 var $htm = $(\u0026#39;#div1\u0026#39;).text(); // 设置文本内容 $(\u0026#39;#div1\u0026#39;).text(\u0026#39;\u0026lt;span\u0026gt;添加文字\u0026lt;/span\u0026gt;\u0026#39;);   4. 属性操作 attr() 1 2 3 4 5 6 7 8 9 10 11  // 取出图片的地址 var Src = $(\u0026#39;#img1\u0026#39;).attr(\u0026#39;src\u0026#39;); // 设置图片的地址和 alt 属性 $(\u0026#39;#img1\u0026#39;).attr({src: \u0026#34;test.jpg\u0026#34;, alt: \u0026#34;Test Image\u0026#34; }); // 设置 class 属性 $(\u0026#39;#abc\u0026#39;).attr(\u0026#39;class\u0026#39;, \u0026#39;all\u0026#39;) // 自定义属性 $(\u0026#39;#abc\u0026#39;).attr(\u0026#39;love\u0026#39;, \u0026#39;iloveyou\u0026#39;)   removeattr() 1 2 3  // 删除属性 $(\u0026#39;#abc\u0026#39;).removeattr(\u0026#39;class\u0026#39;) $(\u0026#39;#abc\u0026#39;).removeattr(\u0026#39;love\u0026#39;)   ","description":"元素操作","id":63,"section":"web","tags":null,"title":"03. Element Operation","uri":"https://yorkfish.github.io/review/web/jquery/03-element-operation/"},{"content":"说明  json(JavaScript Object Notation)，意为 JS 对象表示法 这里说的 josn 指的是类似于 JS 对象的一种数据格式 目前这种数据格式比较流行，逐渐替换掉了传统的 XML 数据格式  JS 对象字面量 1 2 3 4  var tom = { name: \u0026#39;tom\u0026#39;, age: 18 };   json 格式的数据  与 json 对象/JS 对象不同的是  json 数据格式的属性名称需要用双引号引起来 用单引号或者不用引号均会导致数据读取错误    1 2 3 4  { \u0026#34;name\u0026#34;: \u0026#39;tom\u0026#39;, \u0026#34;age\u0026#34;: 18 }    json 的另外一个数据格式是数组，和 JS 中的数组字面量相同  1  [\u0026#39;tom\u0026#39;, 18, \u0026#39;programmer\u0026#39;]   ","description":"json 格式数据","id":64,"section":"web","tags":null,"title":"03. json","uri":"https://yorkfish.github.io/review/web/ajax/03-json/"},{"content":"说明  为了加快对移动设备友好的页面开发工作，利用媒体查询功能并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容 另外还包含了针对打印机显示或隐藏内容的工具类 有针对性的使用这类工具类，从而避免为同一个网站创建完全不同的版本 相反，通过使用这些工具类可以在不同设备上提供不同的展现形式  可用的类  通过单独或联合使用以下列出的类，可以针对不同屏幕尺寸隐藏或显示页面内容      超小屏幕手机 (\u0026lt;768px) 小屏幕平板 (≥768px) 中等屏幕桌面 (≥992px) 大屏幕桌面 (≥1200px)     .visible-xs-* 可见 隐藏 隐藏 隐藏   .visible-sm-* 隐藏 可见 隐藏 隐藏   .visible-md-* 隐藏 隐藏 可见 隐藏   .visible-lg-* 隐藏 隐藏 隐藏 可见   .hidden-xs 隐藏 可见 可见 可见   .hidden-sm 可见 隐藏 可见 可见   .hidden-md 可见 可见 隐藏 可见   .hidden-lg 可见 可见 可见 隐藏     从 v3.2.0 版本起，形如 .visible-*-* 的类针对每种屏幕大小都有了三种变体 每个针对 CSS 中不同的 display 属性，列表如下     类组 CSS display     .visible-*-block display: block;   .visible-*-inline display: inline;   .visible-*-inline-block display: inline-block;     因此，以超小屏幕（xs）为例，可用的 .visible-*-* 类是  .visible-xs-block .visible-xs-inline .visible-xs-inline-block   .visible-xs, .visible-sm, .visible-md, .visible-lg 类也同时存在 但是从 v3.2.0 版本开始不再建议使用 除了 \u0026lt;table\u0026gt; 相关的元素的特殊情况外，它们与 .visible-*-block 大体相同  ","description":"响应式工具","id":65,"section":"web","tags":null,"title":"03. Responsive Tools","uri":"https://yorkfish.github.io/review/web/bootstrap/03-responsive-tools/"},{"content":"注释  JS 语句以 ; 结尾 JS 注释与 C 一样  1 2 3 4 5 6 7  // 单行注释  /* 多行注释 1、... 2、... */   命名规范  由数字、字母、下划线和 $ 组成 不能以数字开头 不能使用关键字 大小写敏感  ","description":"注释与命名规范","id":66,"section":"web","tags":null,"title":"03. Comments and Nomenclature","uri":"https://yorkfish.github.io/review/web/javascript/03-comments-and-nomenclature/"},{"content":"颜色名  red 红色 green 绿色 blue 蓝色 \u0026hellip;  十六进制数值    常见颜色 正常表示 缩写表示     红色 #ff0000 #f00   绿色 #00ff00 #0f0   蓝色 #0000ff #00f   黑色 #000000 #000 / 0   白色 #ffffff #fff    a~f 大小写不敏感\r RGB  background-color: rgb(n1, n2, n3); n1, n2, n3 取 0~255  RGBA  A: 透明度 background-color: rgba(n1, n2, n3, n4); n1, n2, n3 取 0~255 n4 取 [0, 1] —— [透明, 原色]  ","description":"颜色的表示方法","id":67,"section":"web","tags":null,"title":"03. Representation of Color","uri":"https://yorkfish.github.io/review/web/css/03-representation-of-color/"},{"content":"1. 简介  p 标签就是段落标签 对于段落等，用 \u0026lt;p\u0026gt; 和 \u0026lt;/p\u0026gt; 将其包裹即可  2. 示例与效果 示例 \u0026lt;p\u0026gt;和风熏柳，花香醉人，正是南国春光漫烂季节。\u0026lt;/p\u0026gt;\n效果 和风熏柳，花香醉人，正是南国春光漫烂季节。\n","description":"段落标签","id":68,"section":"web","tags":null,"title":"03. Paragraph Label","uri":"https://yorkfish.github.io/review/web/html/03-paragraph-label/"},{"content":"1. 精度    类型 有效数字     float 6~ 7 位   double 15~16 位   long double 18~19 位    1 2 3 4 5 6 7 8 9  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt; int main() { printf(\u0026#34;a = %.20f\\n\u0026#34;, sqrt(3) * sqrt(3)); return 0; }   \u0026gt;\u0026gt;\u0026gt;\na = 2.99999999999999955591\rps  一般两数之差小于 1e-6，就认为两数相等 可以定义一个常量用于比较，如 const double eps = 1e-6;  2. double \u0026amp; long double 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;cstdio\u0026gt; int main() { double a = 123.123456; long double b = 123456789.123456; printf(\u0026#34;a = %f\\n\u0026#34;, a); printf(\u0026#34;a = %lf\\n\u0026#34;, a); // lf 也行  printf(\u0026#34;a = %.f\\n\u0026#34;, a); // 不保留小数  printf(\u0026#34;b = %Lf\\n\u0026#34;, b); // L 必须大写  return 0; }   \u0026gt;\u0026gt;\u0026gt;\na = 123.123456\ra = 123.123456\ra = 123\rb = 123456789.123456\r3. 格式输出 1 2 3 4 5 6 7 8 9  #include \u0026lt;cstdio\u0026gt; int main() { printf(\u0026#34;A%05dA\\n\u0026#34;, 123); // 十进制输出，靠右，占 5 格，没占满补 0  printf(\u0026#34;A%-5dA\\n\u0026#34;, 123); // 十进制输出，靠左，占 5 格，默认补空格  return 0; }   \u0026gt;\u0026gt;\u0026gt;\nA00123A\rA123 A\r","description":"精度与格式化输出","id":69,"section":"cpp","tags":null,"title":"03. accuracy and output","uri":"https://yorkfish.github.io/review/cpp/03-accuracy-and-format-output/"},{"content":" empty() size() front(), back() push(), pop()    empty() size() push(), pop() top()   1. 简介 队列  队列是用堆实现的 队列底层是用 deque 与 vector 实现的 是一个配适器类 不允许随机访问元素 不能遍历队列 元素只能先进先出 (FIFO)  优先队列  另一个配适器类，与 queue 基本一样 它的最大元素被自动移动到队首  2. 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt; using namespace std; struct rect1 { int x, y; }; int main() { // 1. 循环队列  queue\u0026lt;int\u0026gt; q1; queue\u0026lt;double\u0026gt; q2; queue\u0026lt;rect1\u0026gt; q3; // 2. 优先队列  priority_queue\u0026lt;int\u0026gt; q4; // 大根堆  priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q5; // 小根堆  priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q6; return 0; }   3. 大根堆与小根堆 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt; using namespace std; struct rect2 { int x, y; bool operator\u0026lt; (const rect2\u0026amp; t) const // 优先队列（大根堆）中使用结构体，需要重载 \u0026lt;  { return x \u0026lt; t.x; } }; struct rect3 { int x, y; bool operator\u0026gt; (const rect3\u0026amp; t) const // 优先队列（小根堆）中使用结构体，需要重载 \u0026gt;  { return x \u0026gt; t.x; } }; int main() { priority_queue\u0026lt;rect2\u0026gt; q2; rect2 r2 = {1, 2}; q2.push(r2); priority_queue\u0026lt;rect3, vector\u0026lt;rect3\u0026gt;, greater\u0026lt;rect3\u0026gt;\u0026gt; q3; rect3 r3 = {1, 2}; q3.push(r3); return 0; }   4. 循环队列的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt; using namespace std; int main() { queue\u0026lt;int\u0026gt; q; q.push(1); // 插入一个元素到队尾  q.push(2); q.push(3); cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; endl; // 返回队首  cout \u0026lt;\u0026lt; q.back() \u0026lt;\u0026lt; endl; // 返回队尾  q.pop(); // 出队，不返回值  cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; // 队列、优先队列、栈没有 clear()，其他的都有  q = queue\u0026lt;int\u0026gt;(); // 可以用初始化的方式清空队列  return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1\r3\r2\r2\r5. 优先队列的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt; using namespace std; int main() { priority_queue\u0026lt;int\u0026gt; q; // 大根堆  q.push(1); // 插入一个数  q.push(3); q.push(5); cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; endl; // 取最大值  q.pop(); // 删除最大值  cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n5\r3\r","description":"队列","id":70,"section":"cpp","tags":null,"title":"03. queue","uri":"https://yorkfish.github.io/review/cpp/stl/03-queue/"},{"content":"元字符：修饰原子的符号 1. 常用    符号 匹配对象     [] 原子列表，自定义原子范围   [^] 排除列表，自定义排除范围   ^ 匹配开头   $ 匹配结尾   ` `   \\b 词边界（对中文无效）   \\B 非词边界    2. 重复匹配    符号 匹配对象     ? 指定原子可有可无   + 至少一个指定原子   * 任意个指定原子   {m} 刚好 m 个   {m,} 至少 m 个   {m,n} 最少 m 个，最多 n 个   {,n} 最少 0 个，最多 n 个     \\A: 匹配开头，忽略“多行”标记，即无视 re.M \\Z: 匹配结尾，忽略“多行”标记，即无视 re.M    Version3.3 新增 \\u, \\U Version3.8 新增 \\N   ","description":"元字符","id":71,"section":"regex","tags":null,"title":"03. metacharacter","uri":"https://yorkfish.github.io/review/regex/03-metacharacter/"},{"content":"例一 未加锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; int s = 0; void* test(void* args) { int i; for (i = 0; i \u0026lt; 100000; i++) { s++; } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_create(\u0026amp;th1, NULL, test, NULL); pthread_create(\u0026amp;th2, NULL, test, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); printf(\u0026#34;s = %d\\n\u0026#34;, s); return 0; }     运行结果\n 可能会是 20 0000，但大概率小于这个数 几乎每次结果都不同 增大循环次数更明显 这种情况称为 race condition    原因\n 不妨设某一时刻，s=100 th1 拿到 s 进行运算，还没写入时，th2 拿到 s th1 将 s 变为 101，th2 也将 s 变为 101 如此，跳过了一次运算    例二 加锁-方式一  每次运算前后都加锁、解锁  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; pthread_mutex_t lock; int s = 0; void* test(void* args) { int i; for (i = 0; i \u0026lt; 100000; i++) { pthread_mutex_lock(\u0026amp;lock); s++; pthread_mutex_unlock(\u0026amp;lock); } return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_mutex_init(\u0026amp;lock, NULL); pthread_create(\u0026amp;th1, NULL, test, NULL); pthread_create(\u0026amp;th2, NULL, test, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); printf(\u0026#34;s = %d\\n\u0026#34;, s); return 0; }   例三 加锁-方式二  每一轮运算前后加锁、解锁 这样做，逻辑上又相当于不用多线程  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; pthread_mutex_t lock; int s = 0; void* test(void* args) { pthread_mutex_lock(\u0026amp;lock); int i; for (i = 0; i \u0026lt; 100000; i++) { s++; } pthread_mutex_unlock(\u0026amp;lock); return NULL; } int main() { pthread_t th1; pthread_t th2; pthread_mutex_init(\u0026amp;lock, NULL); pthread_create(\u0026amp;th1, NULL, test, NULL); pthread_create(\u0026amp;th2, NULL, test, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); printf(\u0026#34;s = %d\\n\u0026#34;, s); return 0; }   ","description":"加锁","id":72,"section":"c","tags":null,"title":"03. Lock","uri":"https://yorkfish.github.io/review/c/thread/03-lock/"},{"content":"例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import multiprocessing import time def work(): for i in range(1, 11): print(i, \u0026#34;working...\u0026#34;) time.sleep(0.2) def main(): work_process = multiprocessing.Process(target=work) work_process.start() time.sleep(1) print(\u0026#34;all done\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main()   \u0026gt;\u0026gt;\u0026gt;\n1 working...\r2 working...\r3 working...\r4 working...\r5 working...\rall done\r6 working...\r7 working...\r8 working...\r9 working...\r10 working...\r说明  若使用 Sublime Text3 测试，避免“底部弹出运行结果”的方式，使用“弹出命令窗口”的方式  示意图 main thread_job\r| |\r------\u0026gt;\r| |\rover |\r\u0026quot;main\u0026quot; 已经结束了，但子进程还是会跑完\r","description":"不设置守护进程","id":73,"section":"python","tags":null,"title":"03. without setting","uri":"https://yorkfish.github.io/review/python/multiprocessing/03-without-setting/"},{"content":"例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import threading import time def thread_job(): print(\u0026#34;start job\\n\u0026#34;) time.sleep(1) print(\u0026#34;finish job\\n\u0026#34;) def main(): added_thread = threading.Thread(target=thread_job) added_thread.start() print(\u0026#34;all done\\n\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main()   \u0026gt;\u0026gt;\u0026gt;\nstart job\rall done\rfinish job\r说明  与 C 略有不同  main thread_job\r| |\r------\u0026gt;\r| |\rover |\r\u0026quot;main\u0026quot; 已经结束了，但子线程还是会跑完\r","description":"不设置守护线程","id":74,"section":"python","tags":null,"title":"03. without setting","uri":"https://yorkfish.github.io/review/python/threading/03-without-setting/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8 9 10 11  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) string = tk.StringVar() string.set(\u0026#34;This is Label!\u0026#34;) l = tk.Label(window, textvariable=string, bg=\u0026#34;green\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), width=20, height=2) l.pack() window.mainloop()   2. 添加一个 button 1 2 3  b = tk.Button(window, text=\u0026#34;hit me\u0026#34;, bg=\u0026#34;white\u0026#34;, font=(\u0026#34;Arial\u0026#34;, 12), width=10, height=2, command=hit_me) b.pack()   3. hit_me 方法  需要写在调用它的语句的上方  1 2 3 4 5 6 7 8 9 10 11  on_hit = False def hit_me(): global on_hit if not on_hit: on_hit = True string.set(\u0026#34;you hit me\u0026#34;) else: on_hit = False string.set(\u0026#34;你过来呀！\u0026#34;)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) string = tk.StringVar() string.set(\u0026#34;This is Label!\u0026#34;) l = tk.Label(window, textvariable=string, bg=\u0026#34;green\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), width=20, height=2) l.pack() on_hit = False def hit_me(): global on_hit if not on_hit: on_hit = True string.set(\u0026#34;you hit me\u0026#34;) else: on_hit = False string.set(\u0026#34;你过来呀！\u0026#34;) b = tk.Button(window, text=\u0026#34;hit me\u0026#34;, bg=\u0026#34;white\u0026#34;, font=(\u0026#34;Arial\u0026#34;, 12), width=10, height=2, command=hit_me) b.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"按钮","id":75,"section":"python","tags":null,"title":"03. Button","uri":"https://yorkfish.github.io/review/python/tkinter/03-button/"},{"content":"1. 说明  __new__() 先于 __init() 被调用 先执行 __new__()，生成一个实例对象 再执行 __init__()，对生成的对象进行初始化  2. 举例  一般很少用到 __new__() 当继承一个不可变的类型变量时，需要重写  1 2 3 4 5 6 7 8 9 10 11  class CapStr(str): def __new__(cls, string): print(\u0026#34;using __new__\u0026#34;) string = string.upper() return str.__new__(cls, string) def __init__(self, string): print(\u0026#34;using __init__\u0026#34;) a_str = CapStr(\u0026#34;I am YorkFish.\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\nusing __new__\rusing __init__\r","description":"","id":76,"section":"python","tags":null,"title":"03. __new__","uri":"https://yorkfish.github.io/review/python/class/03-new/"},{"content":"1. 说明  a \u0026lt; b \u0026lt; c \u0026lt; ... \u0026lt; n-1 \u0026lt; n 会被转换为 a \u0026lt; b and b \u0026lt; c and ... and n-1 \u0026lt; n 若 a \u0026lt; b 为 False，则后面内容会被短路 a \u0026lt; b \u0026gt; c 也是合法的  2. 举例 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; -3 \u0026lt; -2 \u0026lt; -1 True \u0026gt;\u0026gt;\u0026gt; 1 \u0026lt; 5 \u0026gt; 2 True \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":77,"section":"python","tags":null,"title":"03. compare","uri":"https://yorkfish.github.io/review/python/basics/03-compare/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12  def deco(clss): clss.x = 1 clss.y = 2 return clss @deco class Person(object): pass print(Person.__dict__)   \u0026gt;\u0026gt;\u0026gt;\n{'__module__': '__main__', '__dict__': \u0026lt;attribute '__dict__' of 'Person' objects\u0026gt;, '__weakref__': \u0026lt;attribute '__weakref__' of 'Person' objects\u0026gt;, '__doc__': None, 'x': 1, 'y': 2}\r","description":"","id":78,"section":"python","tags":null,"title":"03. decorator-class","uri":"https://yorkfish.github.io/review/python/decorator/03-decorator-for-class/"},{"content":"1. 说明  del 不会去操作内存，它只是删除了变量的引用 当某片内存空间没有引用的时候，该片空间会自动释放  2. 举例 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = a \u0026gt;\u0026gt;\u0026gt; id(a) # 每次分配的地址不一定相同 2130114338560 \u0026gt;\u0026gt;\u0026gt; id(b) 2130114338560 \u0026gt;\u0026gt;\u0026gt; del a \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":79,"section":"python","tags":null,"title":"03. del()","uri":"https://yorkfish.github.io/review/python/bif/03-del/"},{"content":"1. 创建 1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; a = np.arange(12).reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt;   2. 查看性质   数组的轴（维度）\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.ndim 2 \u0026gt;\u0026gt;\u0026gt;     数组的形状\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.shape (3, 4) \u0026gt;\u0026gt;\u0026gt;     数组的元素个数\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.size 12 \u0026gt;\u0026gt;\u0026gt;     数组中元素的类型\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.dtype dtype(\u0026#39;int32\u0026#39;) \u0026gt;\u0026gt;\u0026gt;     数组中每个元素所占字节数\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.itemsize 4 \u0026gt;\u0026gt;\u0026gt;     存储数组内元素内存缓冲区地址（不常用）\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.data \u0026lt;memory at 0x000001A54B307790\u0026gt; \u0026gt;\u0026gt;\u0026gt;     3. 较大的数组 默认  对较大的数组，默认以省略的形式打印  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = np.arange(10000).reshape((100, 100)) \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 ... 97 98 99] [ 100 101 102 ... 197 198 199] [ 200 201 202 ... 297 298 299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]] \u0026gt;\u0026gt;\u0026gt;   自定义 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; np.set_printoptions(threshold=10000) \u0026gt;\u0026gt;\u0026gt; a = np.arange(10000).reshape((100, 100)) \u0026gt;\u0026gt;\u0026gt; print(a) # threshold \u0026gt;= 数字个数，所有数字都会打印 # 1W 个数字挺多的，这里就不打印了   ","description":"","id":80,"section":"python","tags":null,"title":"03. ndarray attribute","uri":"https://yorkfish.github.io/review/python/numpy/03-ndarray-attribute/"},{"content":"1. 简介  Python3 要使用 reduce 需要从 functools 导入 reduce: 规约，可以使各元素按顺序进行计算，每次计算结果会参与到下次计算中  2. 举例 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; from functools import reduce \u0026gt;\u0026gt;\u0026gt; def mul(a, b): ... return a * b ... \u0026gt;\u0026gt;\u0026gt; lst = [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; reduce(mul, lst) # f(f(f(1, 2), 3), 4) 24 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":81,"section":"python","tags":null,"title":"03. reduce","uri":"https://yorkfish.github.io/review/python/module/03-reduce/"},{"content":"1. fgetc 简介  从指定的文件读入一个字符，该文件必须是以读或写方式打开的  一般形式 char ch = fgetc(fp); // fp 为文件型指针变量\n说明   如果在执行 fgetc 函数读字符时遇到文件结束符，函数返回一个结束标志 EOF，即 -1\n  EOF 不是可输出字符，因此无法打印\n  其实，EOF 就是 ASCII（扩展）表的第 255 位\n char i = -1; // 补码：0b1111 1111 =\u0026gt; 255    ANSI C 之后允许用缓冲文件系统处理二进制文件，而读入的某个字节中的二进制数据的值可能为 -1\n  ANSI C 提供了一个 feof 函数来判断文件是否真的结束\n feof(fp) == 1 =\u0026gt; 真 feof(fp) == 0 =\u0026gt; 假    例一  从一个磁盘文件顺序读入字符，并打印  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); char c = fgetc(fp); while (c != EOF) { putchar(c); c = fgetc(fp); } fclose(fp); return 0; }   例二  顺序读入一个二进制文件中的数据，并打印  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); char c; while (!feof(fp)) { c = fgetc(fp); putchar(c); } fclose(fp); return 0; }    这种方法也适用于文本文件 Windows 下，行末的回车、换行，打印时的效果是“两次回车”  2. fputc 简介  把一个字符写到磁盘文件上去  一般调用形式 fputc(ch, fp);\n说明   fputc 函数带一个返回值\n 若输出成功，返回值就是输出的字符 若输出失败，返回一个 EOF，即 -1    putchar 其实是从 fputc 派生出来的\n #define putchar(ch) fputc(ch, stdout) 作用：将 ch 的值输出到终端    例三 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;a\u0026#34;); fputc(\u0026#39;y\u0026#39;, fp); fclose(fp); return 0; }   3. 等价写法  fputc 和 putc 等价 fgetc 和 getc 等价 可以少写一个字母~  ","description":"","id":82,"section":"c","tags":null,"title":"03. fgetc() \u0026 fputc()","uri":"https://yorkfish.github.io/review/c/file/03-fgetc-and-fputc/"},{"content":"1. 作用  声明新的类型名，代替已有的类型名  2. 简介  用 typedef 可以声明各种类型名，但不能用来定义变量 #define 是在预编译时处理的，它只能作简单的字符串替换 typedef 是在编译时处理的，实际上，它不是作简单的替换 使用 typedef 有利于程序的通用与移植  如，将 typedef int INTEGER; 改为 typedef long INTEGER;    3. 举例 例一 1 2  typedef int COUNT; COUNT i, j;   例二 1 2 3 4 5 6 7 8 9  typedef struct { int year; int month; int day; } DATE, *pDate; DATE birthday; DATE* p1; pDate p2;   例三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;stdio.h\u0026gt; typedef int NUMS[10]; // 声明 NUMS 为整型数组类型  int main() { NUMS nums; // 说白了，就是让 nums 替换 \u0026#34;int NUMS[10];\u0026#34; 中的 NUMS  for (int i = 0; i \u0026lt; 10; i++) { nums[i] = i; } for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d\\n\u0026#34;, nums[i]); } return 0; }    定义的方法（不是推导，是操作步骤）  先按定义数组变量形式书写 int nums[100]; 将变量名 nums 换成自己指定的类型名 int NUMS[100]; 在前面加上 typedef 得到 typedef int NUM[100]; 用来定义变量 NUMS nums;    例四 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; typedef char * STRING; // 声明 STRING 为字符指针类型  int main() { STRING pStr1 = \u0026#34;york\u0026#34;; STRING pStr2 = \u0026#34;fish\u0026#34;; STRING s[] = {pStr1, pStr2}; printf(\u0026#34;%s\\n\u0026#34;, s[0]); printf(\u0026#34;%s\\n\u0026#34;, s[1]); return 0; }   例五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;stdio.h\u0026gt; typedef int (*POINTER)(); // 声明 POINTER 为指向函数的指针类型，该函数返回整型值  int test() { return 1; } int main() { POINTER p; p = test; printf(\u0026#34;%d\\n\u0026#34;, p()); return 0; }   ","description":"","id":83,"section":"c","tags":null,"title":"03. typedef","uri":"https://yorkfish.github.io/review/c/struct-union-enum/03-typedef/"},{"content":"1. 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int main() { int arr1[4] = {1, 2, 3, 4}; int arr2[] = {1, 2, 3, 4}; int* p1 = arr1; int* p2 = \u0026amp;arr1[0]; int arr3[5] = {0}; // 0, 0, 0, 0, 0  int arr4[5] = {1, 2, 3}; // 1, 2, 3, 0, 0  // c99, c11, c18  int arr5[10] = {[1]=2, 4, [5]=6}; // 0, 2, 4, 0, 0, 6, 0, 0, 0, 0  return 0; }   2. 使用 例一 索引 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { int arr[] = {1, 2, 3, 4}; int* p = arr; printf(\u0026#34;%d\\n\u0026#34;, arr[0]); // 1  printf(\u0026#34;%d\\n\u0026#34;, *(arr+1)); // 2  printf(\u0026#34;%d\\n\u0026#34;, p[2]); // 3  printf(\u0026#34;%d\\n\u0026#34;, *(p+3)); // 4  return 0; }    Tip: *(arr+i) 等价于 arr[i]  例二 传参 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt; void f1(int arr[], int arrSize) { for (int i = 0; i \u0026lt; arrSize; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } printf(\u0026#34;\\n\u0026#34;); } void f2(int* arr, int arrSize) { for (int i = 0; i \u0026lt; arrSize; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int arr[] = {1, 2, 3, 4}; int arrSize = 4; f1(arr, arrSize); f2(arr, arrSize); return 0; }    Tip: f(int arr[], int n) 等价于 f(int* arr, int n) C 编译都是将形参数组名作为指针变量来处理的  ","description":"","id":84,"section":"c","tags":null,"title":"03. 一维数组与指针","uri":"https://yorkfish.github.io/review/c/pointer/03-arrays-and-pointers-1/"},{"content":"1. 简介  C 语言允许在结构体中以位为单位，来指定其成员所占内存长度 这种以位为单位的成员称为“位段”或“位域” bit field 利用位段能够利用较少的位数存储数据 位段成员的类型必须指定为 unsigned 或 int  2. 举例 例一 1 2 3 4 5 6 7 8 9  struct packed_data { unsigned a: 4; unsigned b: 12; unsigned c: 8; unsigned d: 8; int i; } data; // a b c d i // (4 )(12 )(8 )(8 )(32...)    a, b, c, d 分别占 4 位，12 位，8 位，8 位 i 为整型，占 4 个字节  例二  可以使各个位段不占满一个字节  1 2 3 4 5 6 7 8  struct packed_data { unsigned a: 4; unsigned b: 12; unsigned c: 8; int i; } data; // a b c i // (4 )(12 )(8 )(xxxxxxxx)(32...)    在存储单元中，位段的分配方向因机器而异 在微机使用的 C 系统中，一般是“由右到左”进行分配的  例三  位段中的数据引用的方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;stdio.h\u0026gt; struct packed_data { unsigned a: 4; unsigned b: 12; unsigned c: 8; int i; } data; int main() { data.a = 16; data.b = 1; data.c = 2; data.i = 3; printf(\u0026#34;%d\\n\u0026#34;, data.a); // 0，有 warning  return 0; }    注意位段允许的最大值范围 a 占 4 位，最大值为 15，给多了，只截取低位  3. 新字节放位段   若某一位段要从另一个字节开始存放，可以用以下形式定义\n1 2 3 4 5 6  struct data { unsigned a: 1; //  unsigned b: 2; // 头两句是一个存储单元  unsigned : 0; unsigned c: 3; // 这是另一个存储单元 };     unsigned :0; 的作用：使下一个位段从下一个存储单元开始存放\n  上述“存储单元”可能是一个字节，也可能是两个字节，视不同的编译器而异\n  一个位段必须存储在同一单元中，不能跨两个单元\n  如果第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段\n  4. 无名位段 1 2 3 4 5 6  struct data { unsigned a: 1; unsigned : 2; // 这两位空间不用，此为“无名位段”  unsigned b: 3; unsigned c: 4; };    位段的长度不能大于存储单元的长度，也不能定义位段数组 位段可以用整型格式符输出，例如  printf(\u0026quot;%d, %d, %d\\n\u0026quot;, data.a, data.b, data.c); 也可以用 %u, %o, %x 等格式符输出   位段可以在数值表达式中引用，它会被系统自动地转换成整型数，例如  int num = data.a + 5/data.b;    ","description":"","id":85,"section":"c","tags":null,"title":"03. 位段","uri":"https://yorkfish.github.io/review/c/bit/03-bit-field/"},{"content":"1. 形参  形参，在未出现函数调用时，它们并不占内存中的存储单元 只有在发生函数调用时，形参才被分配内存单元 在调用结束后，形参所占的内存空间也被释放  2. 实参  实参可以是常量、变量或表达式 实参与形参的类型应相同或复制兼容 实参向形参的数据传递是“值传递”，即单向传递 调用结束后，形参单元被释放  3. 返回值 写法  以下方两种写法等价  return z; return (z);   z 可以是一个表达式  ps  函数类型决定返回值类型 若函数值的类型和 return 语句中表达式的值不一致，则以函数类型为准  ","description":"","id":86,"section":"c","tags":null,"title":"03. 函数的参数与返回值","uri":"https://yorkfish.github.io/review/c/function/03-params-and-return-vals/"},{"content":"1. 前提  .h + .c  2. 编译  在编译时并不是对两个文件分别进行编译，然后再将它们的目标程序连接的 而是在经过编译预处理后将头文件 .h 包含到主文件中，得到一个新的源程序 然后对这个文件进行编译，得到一个目标文件 .obj 被包含的文件成为新的源文件的一部分，而单独生成目标文件  3. 约定  这种常用在文件头部的被包含的文件称为“标题文件”或“头文件”常以 .h 为后缀 用 .c 甚至不用都行，但 .h 作后缀更能表示此文件的性质  4. 优势  如果要修改程序中的一些参数，可以不修改每个程序，只需把这些参数放在一个头文件中 注意：被包含的文件修改后，凡包含此文件的所有文件都要全部重新编译  5. 说明   一个 #include 命令只能指定一个被包含文件，如果要包含 n 个，就用 n 个命令\n  如果“文件1”包含“文件2”，“文件2”要用到“文件3”，则可在“文件1”中用两个 #include\n 注意，先包含“文件3”，再包含“文件2” 不过这种情况有特殊性    \u0026lt;.h\u0026gt; -\u0026gt; 系统到存放 C 库函数头文件的目录中寻找要包含的文件，此为标准方式\n  \u0026quot;.h\u0026quot; -\u0026gt; 系统先到用户当前目录中寻找要包含的文件，若找不到，再按标准方式查找\n  使用对应方式包含可以节省时间\n  预编译后将成为一个文件，如果 .h 中有全局变量，它在 .c 中也有效，不必用 extern 声明\n  ","description":"","id":87,"section":"c","tags":null,"title":"03. 导入","uri":"https://yorkfish.github.io/review/c/preprocessor/03-include/"},{"content":"1. 补码  数值是以补码形式存储的 正数：原码 = 反码 = 补码 负数  反码：原码除符号位，按位取反 补码：原码除符号位，按位取反再加 1    2. unsigned int  一个整数常量后面加一个字母 u 或 U，则认为是 unsigned int  例：-12345u 的存储 1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\\n\u0026#34;, -12345u); // -12345 (-1 X 12345)  printf(\u0026#34;%u\\n\u0026#34;, -12345u); // 4294954951  return 0; }     -12345 原码：0b1000 0000 0000 0000 0011 0000 0011 1001\n  -12345 反码：0b1111 1111 1111 1111 1100 1111 1100 0110\n  -12345 补码：0b1111 1111 1111 1111 1100 1111 1100 0111\n  0b11111111111111111100111111000111 = 4294954951\n  计算机先将 -12345 转换成其补码 4294954951，再按无符号数存储\n  3. long int  一个整数常量后面加一个字母 l 或 L，则认为是 long int  用法 1 2 3 4 5 6 7  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%ld\\n\u0026#34;, 1L); // %ld 是 long int 的格式字符  return 0; }   ps  使用 gcc 编译时，如果使用了 -Wall 参数，%lld 会有 warning Windows 下消除 warning 的两种方法  用 %I64d 代替 %lld 引入头文件 #include \u0026lt;inttypes.h\u0026gt;，并使用 %\u0026quot; PRId64 \u0026quot; 代替 %lld    4. 指数  形如 123e3 或 123E3，e/E 之前必须有数，之后必为整数 若 e/E 之前为小数，则小数点左边应该有且只有一位非零数字，如  5689.65 -\u0026gt; 5.68965e+003    5. 浮点数 单精度  一般，一个单精度浮点数型变量最多只能保证 7 位十进制有效数字  1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; int main() { float n1 = 111111.1; float n2 = 111111.1; float n3 = n1 + n2; printf(\u0026#34;%f\\n\u0026#34;, n3); // 222222.203125  return 0; }   双精度  一般，一个双精度浮点数型变量最多只能保证 16 位十进制有效数字  1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; int main() { double n1 = 1111111111111.1113; double n2 = 1111111111111.1113; double n3 = n1 + n2; printf(\u0026#34;%f\\n\u0026#34;, n3); // 2222222222222.222700  return 0; }   ps  应当避免一个很大的数和一个很小的数直接相加或相减  1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { float num = 1234567.0e5f + 20.0f; printf(\u0026#34;%f\\n\u0026#34;, num); // 123456700416.000000  return 0; }   ","description":"","id":88,"section":"c","tags":null,"title":"03. 数值的表示","uri":"https://yorkfish.github.io/review/c/basics/03-representation-of-value/"},{"content":"1. 说明  除了用 PyCharm 创建虚拟环境，还可以用命令 venv 是自带的 virtualenv 需要自行安装  2. venv  使用命令：D:\\test\u0026gt;python -m venv env 启用命令：D:\\test\u0026gt;env\\Scripts\\activate 关闭命令：D:\\test\u0026gt;env\\Scripts\\deactivate.bat  ps  -m: run library module as a script 加了 -m 就不用管模块的位置了，可以直接用  3. virtualenv   官方博客：\u0026gt;\u0026gt;\u0026gt; 传送门\n  安装命令：C:\\Users\\York\u0026gt;pip install virtualenv\n  使用命令：D:\\test\u0026gt;virtualenv venv\n  启用命令：D:\\test\u0026gt;env\\Scripts\\activate\n  关闭命令：D:\\test\u0026gt;env\\Scripts\\deactivate.bat\n  ps   选择一个特定的 Python 版本创建虚拟环境：D:\\test\u0026gt;virtualenv -p path/to/python venv\n  默认情况下，虚拟环境会依赖系统环境中的 sit package\n  即，系统中已经安装好的第三方 package 也会被安装在虚拟环境中\n  如果不想依赖这些 package，可以加上 --no-site-packages 参数\n  ","description":"","id":89,"section":"python","tags":null,"title":"03. virtual environment","uri":"https://yorkfish.github.io/review/python/operation/03-virtual-env/"},{"content":"1. 用法   标题栏 + 停靠设置 + 具体内容\n  形如\n| | | |\t—— 标题栏\r| :--- | :---: | ---: |\t—— 停靠设置\r| | | |\t—— 具体内容\r...\r  2. 说明  停靠效果有三种  :--- —— 左对齐 :---: —— 居中 ---: —— 右对齐   - 至少三个 只用 - 也行，默认为左对齐 可以偷懒，省去左右两侧的 |  3. 示例与效果  示例  | 靠左 | 居中 | 靠右 |\r| :--- | :---: | ---: |\r| 12345 | 12345 | 12345 |\r 效果     靠左 居中 靠右     12345 12345 12345    ","description":"","id":90,"section":"markdown","tags":null,"title":"04. 表格","uri":"https://yorkfish.github.io/review/markdown/04-table/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \\documentclass[UTF8]{ctexart} % 引入图片包 \\usepackage{graphicx} \\begin{document} % 图片可以不写扩展名  \\includegraphics{图片名} % 设置图片的大小（若引入的是 graphics 包，不支持修改大小）  \\includegraphics[width=0.5\\textwidth]{图片名} \\begin{figure} % 设置居中显示  \\centering \\includegraphics[width=0.5\\textwidth]{图片名} \\caption{给图片添加标题} % 标记，方便引用  \\label{fraction} \\end{figure} % 需要编译两次或更多 也可能无法显示  这是位图(\\ref{fraction}) \\end{ducument}   ","description":"插入图片","id":91,"section":"latex","tags":null,"title":"04. Insert Picture","uri":"https://yorkfish.github.io/review/latex/04-insert-picture/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;outline\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; vue 1 版本可以这么用，但 2 版本改了 \u0026lt;a href={{url}}\u0026gt;谷歌\u0026lt;/a\u0026gt; --\u0026gt; \u0026lt;!-- 完整写法 v-bind:href=\u0026#34;url\u0026#34; --\u0026gt; \u0026lt;a v-bind:href=\u0026#34;url1\u0026#34;\u0026gt;百度\u0026lt;/a\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- 简写（推荐） :href=\u0026#34;url\u0026#34; --\u0026gt; \u0026lt;a :href=\u0026#34;url2\u0026#34; :title=\u0026#34;msg\u0026#34;\u0026gt;博客园\u0026lt;/a\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { url1: \u0026#34;https://www.baidu.com\u0026#34;, url2: \u0026#34;https://www.cnblogs.com\u0026#34;, msg: \u0026#34;点我去博客园\u0026#34; } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   说明  v-bind:属性名=\u0026quot;\u0026quot; 简写 :属性名=\u0026quot;\u0026quot;  ","description":"属性操作","id":92,"section":"web","tags":null,"title":"04. Property Operation","uri":"https://yorkfish.github.io/review/web/vue/04-property-operation/"},{"content":"1. 事件绑定 基本绑定 1 2 3 4 5 6 7  // 单击与双击事件 $(element).click(function(){}); $(element).dblclick(function(){}); // 加载完毕事件 $(document).ready(function(){}); $(function(){});   方法绑定 1 2  $(element).bind(\u0026#39;click\u0026#39;, function(){}); // 绑定事件 $(element).unbind(); // 解除事件绑定   动态绑定 live 方法在高版本(\u0026gt;1.8.3)的 jQuery 中被移出了，使用时请注意版本\r 1  $(element).live(\u0026#39;click\u0026#39;, function(){});   2. 事件触发 写法  当我们想要去触发某个元素的事件时，可以使用 trigger  需指定元素的事件类型\r 1  $(element).trigger(\u0026#39;click\u0026#39;); // 必须指定元素的事件类型，如此处的 click   常用的鼠标事件    事件 对应的名称     鼠标单击事件 click   鼠标双击事件 dbclick   鼠标移入事件 mouseover   鼠标移出事件 mouseout   鼠标按下事件 mousedown   鼠标抬起事件 mouseup   鼠标移动事件 mousemove    1 2 3  $(\u0026#39;div\u0026#39;).mousedown(function() { console.log(\u0026#34;鼠标被按下了\u0026#34;); });   3. 事件冒泡和默认行为 事件冒泡  当触发一个元素的事件时，其自动触发该元素的父级和先辈级的同类型事件，造成事件并发，导致页面混乱，我们称为之事件冒泡 此时我们可以在元素的事件处理函数中返回一个 false 来进行阻止  这个方法仅限于在 jQuery 中使用\r 默认行为  在页面中，有些元素是具备默认行为的，例如  a 链接的单击 表单的提交   以上元素都会进行跳转或提交，这些行为被称为“默认行为” 但是，在绑定上事件后，它会首先先执行事件，然后执行默认行为 若我们只想让其触发事件，但不执行默认行为，我们可以在该元素的事件中返回一个 false 来阻止默认行为  1  \u0026lt;a href=\u0026#34;https://github.com/yorkfish\u0026#34;\u0026gt;点我\u0026lt;/a\u0026gt;   1 2 3 4 5  $(\u0026#39;a\u0026#39;).click(function() { alert(\u0026#34;单击事件被触发了\u0026#34;); return false; // 阻止默认行为 });   4. 获得鼠标的位置和按下的按键  我们有鼠标和键盘按键的事件 在触发事件时，如果我们想要获取鼠标的位置或键盘按键信息 首先，需要在当前的事件中传递一个事件对象 event  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  $(element).click(function(e) { // e for enent，类似于在 Python 中写 Class 时要加 self  // 能够获取鼠标的 x 轴和 y 轴坐标，坐标位置相对于浏览器窗口  var x = e.clientX; var y = e.clientY; // 能够获取鼠标的 x 轴和 y 轴坐标，坐标位置相对于文档  var _x = e.pageX; var _y = e.pageY; }); $(element).keydown(function(e) { // 可以打印 e 对象，或者直接使用该对象中的 keyCode 属性来获取按键信息  var key = e.keyCode; console.log(key); });   ","description":"事件","id":93,"section":"web","tags":null,"title":"04. Event","uri":"https://yorkfish.github.io/review/web/jquery/04-event/"},{"content":"变量的定义  JS 的变量类型由它的值来决定 定义变量需要用关键字 var 在非严格模式下，可以不使用 var 关键字定义全局变量，但不推荐 在严格模式下，不使用 var 关键字定义全局变量，会产生错误 声明严格模式：在 script 标签中写入 \u0026quot;use strict\u0026quot;;  1 2 3 4 5 6 7 8  // 声明严格模式 \u0026#34;use strict\u0026#34;; var a = 123; var b = \u0026#39;abc\u0026#39;; // 同时定义多个变量 var c = 456, d = \u0026#39;def\u0026#39;;   变量的分类    类型 释义     boolean 布尔类型，true, false   number 整型、浮点型   string 字符类型   object 对象类型   function 函数类型   undefined “未定义”类型    举例 例1 boolean  alert() 弹窗 typeof() 获取变量类型  1 2 3  var B = true; alert(typeof(B)); // boolean alert(B); // true   例2 number  一般不用 alert() 查看结果 而是使用 console.log() 将结果打印到控制台 此外，document.write(\u0026quot;Hello\u0026quot;); 可以将结果打印到窗口  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 数字 var num_01 = 12; var num_02 = 12.1; console.log(num_01, typeof(num_01)); // 12 \u0026#34;number\u0026#34; console.log(num_02, typeof(num_02)); // 12.1 \u0026#34;number\u0026#34;  // binary 二进制，以 0b 开头 var num_2 = 0b1011; console.log(num_2, typeof(num_2)); // 11 \u0026#34;number\u0026#34;  // Octal 八进制，以 0 或 0o 开头 var num_8_1 = 076; var num_8_2 = 0o76; console.log(num_8_1); // 62 console.log(num_8_2); // 62  // Hexadecimal 十六进制，以 0x 开头 var num_16 = 0xfe; console.log(num_16); // 254  // NaN: not a number var num_nan = NaN; console.log(num_nan, typeof(num_nan)); // NaN \u0026#34;number\u0026#34;   例3 string 1 2 3 4 5 6 7 8 9 10 11 12 13 14  var str1 = \u0026#39;123\u0026#39;; var str2 = \u0026#34;123\u0026#34;; console.log(str1, typeof(str1)); // 123 string console.log(str2, typeof(str2)); // 123 string  // 将关键字放入引号内部 var str3 = \u0026#34;true\u0026#34;; console.log(str3, typeof(str3)); // true string  // 单双引号可以相互嵌套 var str4 = \u0026#34;I am learning \u0026#39;Python\u0026#39;!\u0026#34; var str5 = \u0026#39;I am learning \u0026#34;Python\u0026#34;!\u0026#39; console.log(str4, typeof(str4)); // I am learning \u0026#39;Python\u0026#39;! string console.log(str5, typeof(str5)); // I am learning \u0026#34;Python\u0026#34;! string   例4 对象 1 2 3 4 5 6 7 8 9 10  var obj = {name: \u0026#39;lisi\u0026#39;, age: 18}; console.log(obj, typeof(obj)); // {name: \u0026#34;lisi\u0026#34;, age: 18} \u0026#34;object\u0026#34;  // 数组 var list = [1, 2, 3, 4, 5]; console.log(list, typeof(list)); // [1, 2, 3, 4, 5] \u0026#34;object\u0026#34;  // null var obj = null; console.log(obj, typeof(obj)); // null \u0026#34;object\u0026#34;   例5 函数数据类型 1 2 3 4 5  var Func = function(){ console.log(\u0026#34;This is a function.\u0026#34;); } console.log(Func); console.log(typeof(Func));   \u0026gt;\u0026gt;\u0026gt;\nƒ (){\rconsole.log(\u0026quot;This is a function.\u0026quot;);\r}\rfunction\r例6 undefined  定义一个变量，若不赋值，则默认为 undefined  1 2 3 4  var un1 = undefined; var un2; console.log(un1, typeof(un1)); // undefined \u0026#34;undefined\u0026#34; console.log(un2, typeof(un2)); // undefined \u0026#34;undefined\u0026#34;   ","description":"基本数据类型","id":94,"section":"web","tags":null,"title":"04. Basic Data Type","uri":"https://yorkfish.github.io/review/web/javascript/04-basic-data-type/"},{"content":"参数表    参数 释义 举例     color 设置文字的颜色 color: red;   font-size 设置文字的大小 font-size: 12px;   font-family 设置文字的字体 font-family: '微软雅黑';   font-style 设置字体的倾斜 font-style: normal; 设置不倾斜\nfont-style: italic; 设置倾斜   font-weight 设置文字的加粗 font-weight: normal; 设置不加粗\nfont-weight: bold; 设置加粗   line-height 设置文字的行高 line-height: 24px;   text-decoration 设置文字下划线 text-decoration: none; 将文字下划线去掉   text-indent 设置文字的缩进 text-indent: 24px; 设置文字首行缩进 24px   text-align 设置文字的对齐 text-align: center; 设置文字水平居中    举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .box{ background: rgb(40, 41, 35); font-family: consolas; /* 字体：consolas */ font-size: 20px; /* 字体大小：20px */ color: red; /* 字体颜色：红色 */ font-style: normal; /* 字体倾斜：不倾斜 */ font-weight: bold; /* 字体加粗：加粗 */ line-height: 20px; /* 文字行高：20px */ text-decoration: none; /* 下划线：不设 */ text-indent: 30px; /* 首行缩进：30px */ text-align: center; /* 文字居中：水平居中 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; 1234567890 \u0026lt;br\u0026gt; abcdefghijklmnopqrstuvwxyz \u0026lt;br\u0026gt; 一二三四五六七八九十 \u0026lt;br\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   \u0026gt;\u0026gt;\u0026gt;\n","description":"常用的文本样式","id":95,"section":"web","tags":null,"title":"04. Text Style","uri":"https://yorkfish.github.io/review/web/css/04-common-text-style-settings/"},{"content":"1. 简介  \u0026lt;br\u0026gt; 就是换行标签 此标签不需要闭合 写成 \u0026lt;/br\u0026gt; 也能工作  2. 示例与效果 示例 1 2 3 4  加 br；\u0026lt;br\u0026gt; 加 br；\u0026lt;br\u0026gt; 加 br；\u0026lt;br\u0026gt; 不加 br；不加 br；不加 br   效果 加 br；\n加 br；\n加 br；\n不加 br；不加 br；不加 br\n","description":"换行标签","id":96,"section":"web","tags":null,"title":"04. Wrap Label","uri":"https://yorkfish.github.io/review/web/html/04-wrap-label/"},{"content":"1. 连续读入 方式一 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x; while (cin \u0026gt;\u0026gt; x \u0026amp;\u0026amp; x) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; }     输入\n 1 2 3 4 5 0\n   返回值\n 1 2 3 4 5 0\n   方式二 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x; while (cin \u0026gt;\u0026gt; x, x) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; }     输入\n 1 2 3 4 5 0\n   返回值\n 1 2 3 4 5 0\n   方式三 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int y; while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;y) != EOF) cout \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; return 0; }     输入\n 1 2 3 4 5\n^Z\n   返回值\n 1 2 3 4 5\n   ps  scanf() 有返回值，一般停止输入时返回 EOF EOF 的值是 -1，但 -1 不都是 EOF Windows 下用 Ctrl + z 代替 EOF Linux 下用 Ctrl + d 代替 EOF  方式四 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int y; while (~scanf(\u0026#34;%d\u0026#34;, \u0026amp;y)) cout \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; return 0; }     输入\n 1 2 3 4 5\n^Z\n   返回值\n 1 2 3 4 5\n   ps  -1 取反是 0，用它来跳出循环  方式五 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b; scanf(\u0026#34;a = %d, b = %d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;a = %d, b = %d\\n\u0026#34;, a, b); return 0; }     输入\n a = 1, b = 2\n   返回值\n a = 1, b = 2\n   2. 输出回车 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;abc\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;123\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;456\u0026#34; \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\nabc\r123\r456\r","description":"连续读入与输出回车","id":97,"section":"cpp","tags":null,"title":"04. input and output","uri":"https://yorkfish.github.io/review/cpp/04-input-and-output/"},{"content":" empty() size() top() push() pop()   1. 简介  适配器 可以将任意类型的序列容器转换为一个堆栈，一般使用 deque 作为支持的序列容器 元素只能先进后出 (FILO) 不能遍历整个 stack 给 vector 提供了栈接口 与 queue 类似，如果要使用栈中元素，先用 top 检索，再用 pop 弹栈  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026lt;iostream\u0026gt;#include \u0026lt;stack\u0026gt; using namespace std; int main() { stack\u0026lt;int\u0026gt; stk; stk.push(1); // 压栈  stk.push(2); stk.push(3); cout \u0026lt;\u0026lt; stk.top() \u0026lt;\u0026lt; endl; // 取栈顶元素  stk.pop(); // 这个 pop 无返回值  cout \u0026lt;\u0026lt; stk.top() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; stk.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; stk.empty() \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n3\r2\r2\r0\r2. 简单应用 例一 十进制转二进制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include \u0026lt;iostream\u0026gt;#include \u0026lt;stack\u0026gt; using namespace std; int itob(int decimal) { stack\u0026lt;int\u0026gt; s; while (decimal) { s.push(decimal % 2); decimal /= 2; } int res = 0; while (!s.empty()) { res = res * 10 + s.top(); s.pop(); } return res; } int main() { int decimal = 20; cout \u0026lt;\u0026lt; itob(decimal) \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n10100\r例二 将输入的单词逆序输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;iostream\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;stack\u0026gt; using namespace std; int main() { string str; getline(cin, str); stringstream ssin; ssin \u0026lt;\u0026lt; str; stack\u0026lt;string\u0026gt; res; while (ssin \u0026gt;\u0026gt; str) res.push(str); while (!res.empty()) { cout \u0026lt;\u0026lt; res.top(); if (res.size() \u0026gt; 1) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; res.pop(); } cout \u0026lt;\u0026lt; endl;     输入\n york fish c++\n   返回值\n c++ fish york\n   ","description":"栈","id":98,"section":"cpp","tags":null,"title":"04. stack","uri":"https://yorkfish.github.io/review/cpp/stl/04-stack/"},{"content":"1. 使用  与大多数转义方式一样，使用 \\     写法 表示     \\\\ \\   \\. .   \\^ ^   \u0026hellip;     2. 说明  在 [] 内，有些符号不必转义，如 ., $, |，且强行转义也行  ","description":"转义","id":99,"section":"regex","tags":null,"title":"04. paraphrase","uri":"https://yorkfish.github.io/review/regex/04-paraphrase/"},{"content":"例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import multiprocessing import time def work(): for i in range(1, 11): print(i, \u0026#34;working...\u0026#34;) time.sleep(0.2) def main(): work_process = multiprocessing.Process(target=work) # 设置守护主进程，主进程结束后，子进程直接销毁，不再执行子进程中的代码 work_process.daemon = True work_process.start() time.sleep(1) print(\u0026#34;all done\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main()   \u0026gt;\u0026gt;\u0026gt;\n1 working...\r2 working...\r3 working...\r4 working...\r5 working...\rall done\r示意图 main thread_job\r| |\r------\u0026gt;\r| X\rover \u0026quot;main\u0026quot; 结束后，子进程也跟着结束\r","description":"守护主进程","id":100,"section":"python","tags":null,"title":"04. daemon","uri":"https://yorkfish.github.io/review/python/multiprocessing/04-daemon/"},{"content":"主线程结束，不想等待子线程，可以设置守护主线程 目标示意图 main thread_job\r| |\r------\u0026gt;\r| X\rover \u0026quot;main\u0026quot; 结束后，子线程也跟着结束\r方式一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import threading import time def thread_job(): for _ in range(10): print(\u0026#34;start job\u0026#34;) time.sleep(0.2) print(\u0026#34;finish job\u0026#34;) def main(): added_thread = threading.Thread(target=thread_job, daemon=True) added_thread.start() time.sleep(1) print(\u0026#34;all done\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main()   \u0026gt;\u0026gt;\u0026gt;\nstart job\rstart job\rstart job\rstart job\rstart job\rall done\r方式二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import threading import time def thread_job(): for _ in range(10): print(\u0026#34;start job\u0026#34;) time.sleep(0.2) print(\u0026#34;finish job\u0026#34;) def main(): added_thread = threading.Thread(target=thread_job) added_thread.setDaemon(True) added_thread.start() time.sleep(1) print(\u0026#34;all done\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: main()   \u0026gt;\u0026gt;\u0026gt;\nstart job\rstart job\rstart job\rstart job\rstart job\rall done\r","description":"守护主线程","id":101,"section":"python","tags":null,"title":"04. daemon","uri":"https://yorkfish.github.io/review/python/threading/04-daemon/"},{"content":"例一 使用全局变量存值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; #define MAX_SIZE 1000000  typedef struct { int first; int last; int id; } MY_ARGS; int* array; int results[2]; void* test(void* args) { int i; MY_ARGS* my_args = (MY_ARGS*)args; int first = my_args-\u0026gt;first; int last = my_args-\u0026gt;last; int id = my_args-\u0026gt;id; for (i = first; i \u0026lt; last; i++) { results[id] += array[i]; } return NULL; } int main() { array = malloc(MAX_SIZE * sizeof(int)); int i; for (i = 0; i \u0026lt; MAX_SIZE; i++) { array[i] = rand() % 5; } results[0] = 0; results[1] = 0; pthread_t th1; pthread_t th2; int mid = MAX_SIZE / 2; MY_ARGS args1 = {0, mid, 0}; MY_ARGS args2 = {mid, MAX_SIZE, 1}; pthread_create(\u0026amp;th1, NULL, test, \u0026amp;args1); pthread_create(\u0026amp;th2, NULL, test, \u0026amp;args2); pthread_join(th1, NULL); pthread_join(th2, NULL); printf(\u0026#34;sum1 = %d\\n\u0026#34;, results[0]); printf(\u0026#34;sum2 = %d\\n\u0026#34;, results[1]); printf(\u0026#34;sum1 + sum2 = %d\\n\u0026#34;, results[0]+results[1]); free(array); return 0; }   例二 使用结构体变量存值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; #define MAX_SIZE 1000000  typedef struct { int first; int last; int result; } MY_ARGS; int* array; void* test(void* args) { int i; MY_ARGS* my_args = (MY_ARGS*)args; int first = my_args-\u0026gt;first; int last = my_args-\u0026gt;last; int s = 0; for (i = first; i \u0026lt; last; i++) { s += array[i]; } my_args-\u0026gt;result = s; return NULL; } int main() { array = malloc(MAX_SIZE * sizeof(int)); int i; for (i = 0; i \u0026lt; MAX_SIZE; i++) { array[i] = rand() % 5; } pthread_t th1; pthread_t th2; int mid = MAX_SIZE / 2; MY_ARGS args1 = {0, mid, 0}; MY_ARGS args2 = {mid, MAX_SIZE, 1}; pthread_create(\u0026amp;th1, NULL, test, \u0026amp;args1); pthread_create(\u0026amp;th2, NULL, test, \u0026amp;args2); pthread_join(th1, NULL); pthread_join(th2, NULL); int sum1 = args1.result; int sum2 = args2.result; printf(\u0026#34;sum1 = %d\\n\u0026#34;, sum1); printf(\u0026#34;sum2 = %d\\n\u0026#34;, sum2); printf(\u0026#34;sum1 + sum2 = %d\\n\u0026#34;, sum1+sum2); free(array); return 0; }   知识点  例二的效率比例一高 多核 CPU，几个数据地址很接近时会发生假共享(False Sharing)  简述 ram: ( ... [7][15] ... )\rcpu\r--------------------------- ---------------------------\r| cache: ( ... [7][15] ...) | | cache: ( ... [7][15] ...) |\r| | | |\r| th1 | | th2 |\r--------------------------- ---------------------------\r 不妨设  线程一在左边的核中跑，线程二在右边的核中跑 线程一“管” 7，线程二“管” 15   线程一将 7 运算成 n1，线程二将 15 运算成 n2，两者写回 ram 时，系统会作校验 若发现数据有变，会先更新，再写入，这里的检查与更新消耗了时间  例三 改进例一  使用不相邻的内存地址以防止 CPU 的内存一并取得两者  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;pthread.h\u0026gt; #define MAX_SIZE 1000000  typedef struct { int first; int last; int id; } MY_ARGS; int* array; int results[101]; void* test(void* args) { MY_ARGS* my_args = (MY_ARGS*)args; int first = my_args-\u0026gt;first; int last = my_args-\u0026gt;last; int id = my_args-\u0026gt;id * 100; int i; for (i = first; i \u0026lt; last; i++) { results[id] += array[i]; } return NULL; } int main() { array = malloc(MAX_SIZE * sizeof(int)); int i; for (i = 0; i \u0026lt; MAX_SIZE; i++) { array[i] = rand() % 5; } results[0] = 0; results[100] = 0; // 防止数据地址很接近  pthread_t th1; pthread_t th2; int mid = MAX_SIZE / 2; MY_ARGS args1 = {0, mid, 0}; MY_ARGS args2 = {mid, MAX_SIZE, 1}; pthread_create(\u0026amp;th1, NULL, test, \u0026amp;args1); pthread_create(\u0026amp;th2, NULL, test, \u0026amp;args2); pthread_join(th1, NULL); pthread_join(th2, NULL); printf(\u0026#34;s1 = %d\\n\u0026#34;, results[0]); printf(\u0026#34;s2 = %d\\n\u0026#34;, results[100]); printf(\u0026#34;s1 + s2 = %d\\n\u0026#34;, results[0]+results[100]); return 0; }   小结  以上三个例子的效率：例二 \u0026gt; 例三 \u0026gt; 例一  ","description":"假共享与效率","id":102,"section":"c","tags":null,"title":"04. Lock - upgrade","uri":"https://yorkfish.github.io/review/c/thread/04-lock-upgrade/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. 添加一个 Text 1 2  t = tk.Text(window, height=2) t.pack()   3. insert 文字  insert 到光标后：t.insert(\u0026quot;insert\u0026quot;, string) insert 到文本末：t.insert(\u0026quot;end\u0026quot;, string) insert 到指定处：t.insert(2.1, string)  ps  x.y 的形式有一个注意点  x 表示行，索引从 1 开始 y 表示列，索引从 0 开始    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) t = tk.Text(window, height=2, font=(\u0026#34;Consolas\u0026#34;, 20)) t.insert(\u0026#34;insert\u0026#34;, \u0026#34;012\\n012\u0026#34;) t.pack() def insert_point(): t.insert(\u0026#34;insert\u0026#34;, \u0026#34;York\u0026#34;) def insert_end(): t.insert(\u0026#34;end\u0026#34;, \u0026#34;Fish\u0026#34;) def insert_anypoint(): t.insert(2.1, \u0026#39;-\u0026#39;) b1 = tk.Button(window, text=\u0026#34;insert point\u0026#34;, width=15, command=insert_point) b1.pack() b2 = tk.Button(window, text=\u0026#34;insert end\u0026#34;, width=15, command=insert_end) b2.pack() b3 = tk.Button(window, text=\u0026#34;insert anypoint\u0026#34;, width=15, command=insert_anypoint) b3.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n ps  启动后，光标默认在文末，即第二行末尾 点到其他位置以体验 insert point    ","description":"文本框","id":103,"section":"python","tags":null,"title":"04. Text","uri":"https://yorkfish.github.io/review/python/tkinter/04-text/"},{"content":"1. 简介  callable() 用于检查一个对象是否可调用 对于函数、方法、lambda 函数式、类，以及实现了 __call__ 方法的类实例, 它都返回 True 对于整数、字符串、列表、元组、字典等，都返回 False  ps  若返回 True，object 仍可能调用失败 若返回 False，object 必然调用失败  2. 举例 例一 函数 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def say(): ... print(\u0026#34;Hi, I am YorkFish!\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; callable(say) True \u0026gt;\u0026gt;\u0026gt;   例二 空类与其实例 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; class Test(object): ... pass ... \u0026gt;\u0026gt;\u0026gt; callable(Test) True \u0026gt;\u0026gt;\u0026gt; t = Test() # 没有实现 __call__, 返回 False \u0026gt;\u0026gt;\u0026gt; callable(t) False \u0026gt;\u0026gt;\u0026gt;   例三 实现 __call__ 后 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; class Test(object): ... def __init__(self): ... pass ... def __call__(self, *args, **kwargs): ... print(\u0026#34;Hello, I am YorkFish.\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; callable(Test) True \u0026gt;\u0026gt;\u0026gt; t = Test() # 实现了 __call__, 返回 True \u0026gt;\u0026gt;\u0026gt; callable(t) True \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":104,"section":"python","tags":null,"title":"04. callable","uri":"https://yorkfish.github.io/review/python/class/04-callable/"},{"content":"例一  不同类型的数值，只要大小相等，Python 就认为它们相等  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 1.0 \u0026gt;\u0026gt;\u0026gt; a == b True \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = [1, 2] \u0026gt;\u0026gt;\u0026gt; b = [1.0, 2.0] \u0026gt;\u0026gt;\u0026gt; a == b True \u0026gt;\u0026gt;\u0026gt;   例二  dict 通过检查键值和哈希来确定两个键是否相同 若有相等的键  键取最前面的 值取最后面的    1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; d1 = {1:\u0026#39;a\u0026#39;, 1.0:\u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d1 {1: \u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d2 = {1.0:\u0026#39;a\u0026#39;, 1:\u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d2 {1.0: \u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt;   例三 常量赋值产生副本，其他产生别名\r 副本  字符串、整型、浮点、布尔“产生”副本 就像“写时拷贝”(Copy-on-Write)  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = b = 3 \u0026gt;\u0026gt;\u0026gt; c = 3 \u0026gt;\u0026gt;\u0026gt; a is b is c True \u0026gt;\u0026gt;\u0026gt; a = 4 \u0026gt;\u0026gt;\u0026gt; b 3 \u0026gt;\u0026gt;\u0026gt; c 3 \u0026gt;\u0026gt;\u0026gt;   别名  list, dict 以及自定义的 class “产生”别名  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = b = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; c = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; a is b True \u0026gt;\u0026gt;\u0026gt; a is c False \u0026gt;\u0026gt;\u0026gt; a[0] = 11 \u0026gt;\u0026gt;\u0026gt; b [11, 2, 3] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":105,"section":"python","tags":null,"title":"04. equal","uri":"https://yorkfish.github.io/review/python/basics/04-equal/"},{"content":"1. 简介  eval for evaluate 原型：eval(expression, globals=None, locals=None)  2. 举例 例一 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; s = \u0026#34;[[1, 2], [3, 4], [5, 6]]\u0026#34; \u0026gt;\u0026gt;\u0026gt; s \u0026#39;[[1, 2], [3, 4], [5, 6]]\u0026#39; \u0026gt;\u0026gt;\u0026gt; eval(s) [[1, 2], [3, 4], [5, 6]] \u0026gt;\u0026gt;\u0026gt;   例二 先局部\n再全局\n最后内置\r 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; a = 10 \u0026gt;\u0026gt;\u0026gt; eval(\u0026#34;a+1\u0026#34;, {\u0026#39;a\u0026#39;: 20}) 21 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b = 10 \u0026gt;\u0026gt;\u0026gt; eval(\u0026#34;b+1\u0026#34;, {\u0026#39;b\u0026#39;: 20}, {\u0026#39;b\u0026#39;: 30}) 31 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":106,"section":"python","tags":null,"title":"04. eval()","uri":"https://yorkfish.github.io/review/python/bif/04-eval/"},{"content":"1. 说明  当对 ndarray 使用各种算术运算符时  numpy 会将其应用于数组的每一个元素 计算完成后返回一个与原来形状相同的 ndarray    2. 操作 导入 1  import numpy as np   四则运算 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; a = np.arange(10) \u0026gt;\u0026gt;\u0026gt; print(a) [0 1 2 3 4 5 6 7 8 9] \u0026gt;\u0026gt;\u0026gt; print(a + 10) [10 11 12 13 14 15 16 17 18 19] \u0026gt;\u0026gt;\u0026gt; print(a * 2) [ 0 2 4 6 8 10 12 14 16 18] \u0026gt;\u0026gt;\u0026gt;   幂运算 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12).reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(a ** 2) [[ 0 1 4 9] [ 16 25 36 49] [ 64 81 100 121]] \u0026gt;\u0026gt;\u0026gt;   三角函数 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12).reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; print(np.sin(a)) # 这里的 sin 接收的是弧度 [[ 0. 0.84147098 0.90929743 0.14112001] [-0.7568025 -0.95892427 -0.2794155 0.6569866 ] [ 0.98935825 0.41211849 -0.54402111 -0.99999021]] \u0026gt;\u0026gt;\u0026gt;   逻辑运算 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12).reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; print(a \u0026lt; 6) [[ True True True True] [ True True False False] [False False False False]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":107,"section":"python","tags":null,"title":"04. ndarray calculate","uri":"https://yorkfish.github.io/review/python/numpy/04-ndarray-calculate/"},{"content":"1. 设置   “以管理员身份运行”打开 PowerShell\n  输入 set-executionpolicy remotesigned\n执行策略可以防止您执行不信任的脚本。\r更改执行策略可能会使您面临 about_Execution_Policies 帮助主题中所述的安全风险。\r是否要更改执行策略? [Y] 是(Y) [N] 否(N) [S] 挂起(S) [?] 帮助 (默认值为“Y”):\r  输入 Y 确认\n  重启生效\n  2. 使用   现在，Anaconda 默认有 PowerShell Prompt 和 CMD Prompt\n  硬要手动激活、关闭，可以这样\n 打开 PowerShell 或 CMD 输入 conda activate base 激活（base 可以改成自己的虚拟环境） 输入 conda deactivate base 关闭    若想每次打开 PowerShell 或 CMD 都是激活状态，输入下方两条命令\n conda init powershell conda config --set auto_activate_base true    若想恢复，使用命令：conda config --set auto_activate_base false\n  ","description":"","id":108,"section":"python","tags":null,"title":"04. powershell virtual-env","uri":"https://yorkfish.github.io/review/python/operation/04-powershell/"},{"content":"1. 说明  因为 Python 的变量是动态的，所以不能真正像 C, Java 那样对函数的参数类型进行严格定义 Python 3.6 以后有了类型提示 列表、字典等，需要导入 typing 模块  2. 举例 例一 1 2 3 4 5 6 7  def test(name: str, age: int) -\u0026gt; bool: res = True print(f\u0026#34;{name=}\u0026#34;) print(f\u0026#34;{age=}\u0026#34;) if age \u0026lt; 18: res = False return res   例二 1 2 3 4 5  from typing import Dict, List a: List[int] = [] b: Dict[str, int] = {}   ","description":"","id":109,"section":"python","tags":null,"title":"04. typing","uri":"https://yorkfish.github.io/review/python/module/04-typing/"},{"content":"1. 简介  fread 和 fwrite 函数可以用来读写一个字符 因为常常需要一次读取一组数据，ANSI C 标准提出设置这两个函数，用来读写一个数据块  2. 一般形式 1 2  fread(buffer, size, count, fp); fwrite(buffer, size, count, fp);   3. 说明   buffer: 一个指针\n 对 fread 来说，它是读入数据的存放（起始）地址 对 fwrite 来说，它是要输出数据的（起始）地址    size: 要读写的字节数\n  count: 要读写多少次 size 字节的数据像\n  fp: 文件型指针\n  如果文件以二进制形式打开，用 fread 和 fwrite 函数就可以读写任何类型的信息\n  4. 举例 例一 写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); float nums[5] = {11.0, 12.0, 13.0, 14.0, 15.0}; int fsize = sizeof(float); for (int i = 0; i \u0026lt; 5; i++) { if (fwrite(\u0026amp;nums[i], fsize, 1, fp) != 1) { printf(\u0026#34;file write error!\\n\u0026#34;); exit(0); } } fclose(fp); return 0; }   例二 读出 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); float nums[5]; int fsize = sizeof(float); for (int i = 0; i \u0026lt; 5; i++) { fread(\u0026amp;nums[i], fsize, 1, fp); printf(\u0026#34;%f\\n\u0026#34;, nums[i]); } fclose(fp); return 0; }   ps  上面的例子不用二进制 (wb, rb) 也能成功，但  一来，不推荐 二来，程序还是会以二进制运行    ","description":"","id":110,"section":"c","tags":null,"title":"04. fread() \u0026 fwrite()","uri":"https://yorkfish.github.io/review/c/file/04-fread-and-fwrite/"},{"content":"1. 多个实参的求值顺序  有的编译器自右向左 有的编译器自左向右 应当避免这种容易混淆的用法  2. 编译器的检查  只检查参数个数和参数类型，而不检查参数名 对形参数组大小不做检查，只是将实参数组的首元素的地址传给形参数组 不检查（数组）第一维的大小  ","description":"","id":111,"section":"c","tags":null,"title":"04. 函数的调用","uri":"https://yorkfish.github.io/review/c/function/04-function-call/"},{"content":"1. 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14  int arr1[3][4] = { {10, 11, 12, 13}, {14, 15, 16, 17}, {18, 19, 20, 21}}; int arr2[][4] = { {10, 11, 12, 13}, {14, 15, 16, 17}, {18, 19, 20, 21}}; int arr3[][4] = { {10}, {14, 15}, {18, 19, 20}};    Tip: 指针尽量用 p[i] 的形式，这样就省了下文的唠叨  2. 不同写法    表示形式 含义     arr 二维数组名，首行首地址   *arr, *(arr+0), arr[0], \u0026amp;*(arr[0] + 0), \u0026amp;arr[0][0] 首行首列地址   arr+1, \u0026amp;*(arr+1), \u0026amp;arr[1] 1 行首地址   *(arr+1), arr[1], \u0026amp;*(arr[1] + 0), \u0026amp;arr[1][0] 1 行首列地址   *(arr+1)+2, arr[1]+2, \u0026amp;*(arr[1]+2), \u0026amp;arr[1][2] 1 行 2 列元素 arr[1][2] 的地址   *(*(arr+1)+2), *(arr[1]+2), arr[1][2] 1 行 2 列元素 arr[1][2] 的值     Tip  *(arr+i) 等价于 arr[i] \u0026amp; 与 * 可以消掉    *(arr+1) 与 arr+1  *(arr+1) 就是 arr[1]，在二维数组中，它是一维数组名，是地址，指向 arr[1][0] arr+1 是二维数组 arr 中的 1 行首地址，也指向 arr[1][0]  指向行与指向列  二维数组名（如 arr）是指向行的 在指向行的指针之前加一个 *（如 *arr, *(arr+1)），就成了指向列的指针 在指向列的指针值前加一个 \u0026amp;（如 \u0026amp;*arr, \u0026amp;*(arr+1)），就成了指向行的指针  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int main() { int arr[][4] = { {10, 11, 12, 13}, {14, 15, 16, 17}, {18, 19, 20, 21}}; printf(\u0026#34;%p\\n\u0026#34;, arr); // 0061FEA0，每次编译分配的地址不一定相同  printf(\u0026#34;%p\\n\u0026#34;, *arr); // 0061FEA0  printf(\u0026#34;%p\\n\u0026#34;, arr[0]); // 0061FEA0, *arr \u0026gt; *(arr+0) \u0026gt; arr[0]  printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr[0]); // 0061FEA0, arr \u0026gt; \u0026amp;*(arr+0) \u0026gt; \u0026amp;arr[0]  printf(\u0026#34;%p\\n\u0026#34;, *(arr+0)+0); // 0061FEA0, arr[0]+0  printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr[0][0]); // 0061FEA0, \u0026amp;*(arr[0]+0) \u0026gt; \u0026amp;arr[0][0]  return 0; }    值一样，但概念不尽相同 不要把 \u0026amp;arr[i] 简单地理解为 arr[i] 单元的物理地址 对二维数组而言，并不存在 arr[i] 这样一个实际的变量 它只是一种地址的计算方法，能得到第 i 行的首地址  4. 说明  当 arr[i][j] 的 j 为 0 时，\u0026amp;arr[i] 和 arr[i] 值相等，即它们占同一地址 它们所指向的对象是不同的，即指针的基本类型是不同的 二维数组中，arr+i, arr[i], *(arr+i), \u0026amp;arr[i], \u0026amp;arr[i][0] 的值相等 *(*(arr+1)) 可以改写成 **(arr+1)  公式  arr[i][j] 在数组中相对位置的计算公式：i*m + j，m 为二维数组 arrnxm 的列数  arr[2][3] 可以用 *(arr + 2*m+3) 求得 arr[i][j] 的地址为 \u0026amp;arr[0][0] + sizeof(int)*(i*m+j)   由此可见，二维数组在计算机中是“一维连续”存储的  ","description":"","id":112,"section":"c","tags":null,"title":"04. 多维数组与指针","uri":"https://yorkfish.github.io/review/c/pointer/04-arrays-and-pointers-2/"},{"content":"1. 换行与回车    符号 释义 英文 ASCII     \\n 换行 newline begin 10   \\r 回车 return oldline begin 13    ps  以前的打字机，打满一行字后，先把纸往上卷（换行），再把纸往右拉（回车）  2. 八进制    八进制 十进制 ASCII     \\101 65 'A'    3. 字符与字符串  'a' 是字符常量，\u0026quot;a\u0026quot; 是字符串常量  字符   如果在字符变量中存放一个 128~255 间的值，用 %d 格式符输出时会得到负值\n  因为 128~255 在字节中最高位为 1\n1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { char c = 128; printf(\u0026#34;%d\\n\u0026#34;, c); // -128  return 0; }     字符串   C 规定以字符 '\\0' 作为字符串结束标志\n  ASCII 码为 0 的字符是 '\\0'，表示“空操作字符”\n  写字符串不必多加 '\\0'\n  字符串 \u0026quot;a\u0026quot; 实际上包含 2 个字符：'a' 和 '\\0'\n1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;a\u0026#34;; printf(\u0026#34;%d\\n\u0026#34;, strlen(str)); // 1  printf(\u0026#34;%d\\n\u0026#34;, sizeof(str)); // 2  return 0; }     ","description":"","id":113,"section":"c","tags":null,"title":"04. 字符型数据","uri":"https://yorkfish.github.io/review/c/basics/04-character-data/"},{"content":"1. 优点  采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间  2. 三种形式 形式一 1 2 3  #ifdef 标识符  // 程序段1 #endif   形式二 1 2 3 4 5  #ifdef 标识符  // 程序段1 #else  // 程序段2 #endif   形式三 1 2 3 4 5  #if 表达式  // 程序段1 #else  // 程序段2 #endif   ","description":"","id":114,"section":"c","tags":null,"title":"04. 条件编译","uri":"https://yorkfish.github.io/review/c/preprocessor/04-conditional-compilation/"},{"content":"1. 引用的方式 一般形式  结构体变量名.成员名 如：student1.num = 10010; . 是成员（分量）运算符，它在所有的运算符中优先级最高的  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef struct data { int num; } Data; typedef struct student { char name[20]; char gender; Data st_num; } Student; int main() { Student st1; strcpy(st1.name, \u0026#34;york\u0026#34;); st1.gender = \u0026#39;M\u0026#39;; st1.st_num.num = 1; printf(\u0026#34;%s\\n\u0026#34;, st1.name); printf(\u0026#34;%c\\n\u0026#34;, st1.gender); printf(\u0026#34;%d\\n\u0026#34;, st1.st_num.num); return 0; }   2. 指针的方式 一般形式  (*结构体变指针).成员名 或 结构体指针-\u0026gt;成员名 如：(*pStu).num = 10010; 或 pStu-\u0026gt;num = 10010; -\u0026gt; 是指向运算符  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef struct student { char name[20]; char gender; int num; } Student; void printInfo(Student* stu) { printf(\u0026#34;%s\\n\u0026#34;, (*stu).name); printf(\u0026#34;%c\\n\u0026#34;, stu-\u0026gt;gender); printf(\u0026#34;%d\\n\u0026#34;, stu-\u0026gt;num); } int main() { Student st1; strcpy(st1.name, \u0026#34;york\u0026#34;); st1.gender = \u0026#39;M\u0026#39;; scanf(\u0026#34;%d\u0026#34;, \u0026amp;st1.num); printInfo(\u0026amp;st1); return 0; }   ","description":"","id":115,"section":"c","tags":null,"title":"04. 结构体变量的使用","uri":"https://yorkfish.github.io/review/c/struct-union-enum/04-usage/"},{"content":" Bootstrap 看官方的文档就行了 我只是从官网搬了一些过来   表格 基本实例  为任意 \u0026lt;table\u0026gt; 标签添加 .table 类可以为其赋予基本的样式\n— 少量的内补(padding)和水平方向的分隔线 这种方式看起来很多余！？ 表格元素使用的很广泛，如果为其赋予默认样式可能会影响例如日历和日期选择之类的插件，所以将此样式独立出来  表单 基本实例  单独的表单控件会被自动赋予一些全局样式 所有设置了 .form-control 类的 \u0026lt;input\u0026gt;、\u0026lt;textarea\u0026gt; 和 \u0026lt;select\u0026gt; 元素都将被默认设置宽度属性为 width: 100%; 将 label 元素和前面提到的控件包裹在 .form-group 中可以获得最好的排列  \u0026hellip; ","description":"零碎的知识点","id":116,"section":"web","tags":null,"title":"04. Ohters","uri":"https://yorkfish.github.io/review/web/bootstrap/04-others/"},{"content":"1. 用法  与许多语言一样，Markdown 中的转义字符也是 \\ 用的时候，在需要转义的字符前加上反斜杠即可  2. 说明  下表中的符号使用时需要转义，符号均为英文字符     序号 符号 名称     01 # 井号   02 * 星号   03 - 减号   04 + 加号   05 ` 反引号   06 \\ 反斜杠   07 _ 下划线   08 {} 大括号   09 [] 中括号   10 () 小括号   11 ! 叹号   12 . 句号    ","description":"","id":117,"section":"markdown","tags":null,"title":"05. 转义字符","uri":"https://yorkfish.github.io/review/markdown/05-escape-character/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \\documentclass[UTF8]{ctexart} \\begin{document} % 无序列表  \\begin{itemize} \\item 无序列表1 \\item 无序列表2 \\item 无序列表3 \\end{itemize} % 有序列表  \\begin{enumerate} \\item 有序列表1 \\item 有序列表2 \\item 有序列表3 \\end{enumerate} \\end{document}   ","description":"列表","id":118,"section":"latex","tags":null,"title":"05. List","uri":"https://yorkfish.github.io/review/latex/05-list/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;outline\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .box1{ width: 200px; height: 200px; background: red; } .box2{ border: 3px solid green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div :class=\u0026#34;[item1,item2]\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div :class=\u0026#34;{box1:true,box2:false}\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div :class=\u0026#34;{box1:flag,box2:flag}\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;!-- 会报错 \u0026lt;div v-bind:style=\u0026#34;width:200px\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;div v-bind:style=\u0026#34;{width:\u0026#39;200px\u0026#39;,height:\u0026#39;200px\u0026#39;,background:\u0026#39;red\u0026#39;}\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div v-bind:style=\u0026#34;{width:W,height:H,background:bg}\u0026#34;\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;div v-bind:style=\u0026#34;json\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div v-bind:style=\u0026#34;[json,b]\u0026#34;\u0026gt;7\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { item1: \u0026#34;box1\u0026#34;, item2: \u0026#34;box2\u0026#34;, flag: true, W: \u0026#34;200PX\u0026#34;, H: \u0026#34;200PX\u0026#34;, bg: \u0026#34;red\u0026#34;, json: { width: \u0026#34;200px\u0026#34;, height: \u0026#34;200px\u0026#34;, background: \u0026#34;red\u0026#34; }, b: { border: \u0026#34;3px solid green\u0026#34; } } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   类名的操作 数组语法 v-bind:class=[变量名, 变量名]\rdata: {\r变量名: 类名\r}\r对象语法 v-bind:class={类名:true/false}\rstyle 的操作 数组语法 :style=[obj1, obj2]\rdata: {\robj1: {\rwidth: '200px',\rbackground: 'red'\r},\robj2: {\rborder: '1px solid green'\r}\r}\r对象语法 :style={width:w}\rdata: {\rw:'200px'\r}\r","description":"样式操作","id":119,"section":"web","tags":null,"title":"05. Style operation","uri":"https://yorkfish.github.io/review/web/vue/05-style-operation/"},{"content":"1. 创建节点 1  var Div = $(\u0026#39;\u0026lt;div\u0026gt;这是一个div元素\u0026lt;/div\u0026gt;\u0026#39;);   2. 插入节点 append() 和 appendTo()  在现存元素的内部，从后面插入元素  1  \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   1 2 3  var Span = $(\u0026#39;\u0026lt;span\u0026gt;这是一个span元素\u0026lt;/span\u0026gt;\u0026#39;); $(\u0026#39;#div1\u0026#39;).append(Span); // 在指定元素 div1 里面的尾部插入新的元素 Span // Span.appendTo($(\u0026#39;#Div1\u0026#39;)); // 将新的元素 Span 插入到指定的元素 div1 的尾部，效果同上一行   prepend() 和 prependTo()  在现存元素的内部，从前面插入元素  after() 和 insertAfter()  在现存元素的外部，从后面插入元素  before() 和 insertBefore()  在现存元素的外部，从前面插入元素  3. 删除节点与清空节点 1 2  $(element).remove(); // 删除元素，可以删除自己 $(element).empty(); // 清空元素，不删除自己   4. 克隆节点  如果单纯的只是为了克隆元素，那么里面不需要传参数 如果需要连同元素身上的事件一起克隆，那就在括号中写 true  1  $(element).clone(true);   5. 注意事项  插入元素的时候，要先进行克隆，再进行插入操作，不然会把原来的元素拿走  1 2 3  \u0026lt;button\u0026gt;克隆\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;注意\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   1 2 3 4  $(\u0026#39;button\u0026#39;).eq(1).click(function(){ // $(\u0026#39;.wrap\u0026#39;).append($(\u0026#39;button\u0026#39;).eq(0)); // 将第一个按钮添加到 wrap 中  $(\u0026#39;.wrap\u0026#39;).append($(\u0026#39;button\u0026#39;).eq(0).clone()); // 先克隆，再插入 });   ","description":"元素节点操作","id":120,"section":"web","tags":null,"title":"05. Element Node Operation","uri":"https://yorkfish.github.io/review/web/jquery/05-element-node-operation/"},{"content":"函数介绍    函数 释义     Number(value) 强转整数或浮点数   parseInt(value) 强转成整型   parseFloat(value) 强转成浮点型   String(value) 强转成字符串类型   Boolean(value) 强转成布尔类型    举例 Number(), parseInt(), parseFloat() 例1 1 2 3 4 5 6 7 8 9 10 11  var str1 = \u0026#39;123\u0026#39;; console.log(str1, typeof(str1)); // 123 stirng  var str2 = Number(str1); console.log(str2, typeof(str2)); // 123 \u0026#34;number\u0026#34;  var str3 = parseInt(str1); console.log(str3, typeof(str3)); // 123 \u0026#34;number\u0026#34;  var str4 = parseFloat(str1); console.log(str4, typeof(str4)); // 123 \u0026#34;number\u0026#34;   例2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 更换 str5 查看区别 // var str5 = \u0026#39;123abc\u0026#39;; // var str5 = \u0026#39;abc123\u0026#39;; // var str5 = \u0026#39;abc123def\u0026#39;; // var str5 = \u0026#39;123abc456\u0026#39;; var str5 = \u0026#39;1.23abc\u0026#39;; console.log(str5, typeof(str5)); var str6 = Number(str5); console.log(str6, typeof(str6)); var str7 = parseInt(str5); console.log(str7, typeof(str7)); var str8 = parseFloat(str5); console.log(str8, typeof(str8));    简单地说  Numer() 比较严格，混入了字母就是 NaN parseInt() 与 parseFloat() 会从前往后，尽量找出符合自己类型的数字部分    isNaN() 例3 1 2 3 4 5 6 7 8  var num1 = \u0026#39;1\u0026#39;; console.log(num1, isNaN(num1)); // 1 false  var num2 = \u0026#39;a\u0026#39;; console.log(num2, isNaN(num2)); // a true  var num3 = \u0026#39;1a\u0026#39;; console.log(num3, isNaN(num3)); // 1a true   Boolean() 例4 1 2 3 4 5 6 7 8 9 10 11 12 13  /* 字符串转布尔值 \u0026#39;1\u0026#39; -\u0026gt; true \u0026#39;0\u0026#39; -\u0026gt; true \u0026#39;\u0026#39; -\u0026gt; false */ var str1 = \u0026#39;1\u0026#39;; console.log(str1, Boolean(str1)); // 1 true  var str2 = \u0026#39;0\u0026#39;; console.log(str2, Boolean(str2)); // 0 true  var str3 = \u0026#39;\u0026#39;; console.log(str3, Boolean(str3)); // false   例5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* 数值类型转布尔值 1 -\u0026gt; true 0 -\u0026gt; false NaN -\u0026gt; false */ var num1 = 1; console.log(num1, Boolean(num1)); // 1 true  var num2 = 0; console.log(num2, Boolean(num2)); // 0 false  var num3 = 0.0; console.log(num3, Boolean(num3)); // 0 false  var num4 = NaN; console.log(num4, Boolean(num4)); // NaN false   例6 1 2 3 4 5 6 7 8 9 10 11 12  /* 对象转布尔值 obj -\u0026gt; true null -\u0026gt; false */ var obj1 = {name: \u0026#34;Tom\u0026#34;, age: 18}; console.log(obj1, Boolean(obj1)); // {name: \u0026#34;Tom\u0026#34;, age: 18} true  var obj2 = {}; console.log(obj2, Boolean(obj2)); // {} true  var obj3 = null; console.log(obj3, Boolean(obj3)); // null false   ","description":"数据类型转换","id":121,"section":"web","tags":null,"title":"05. Data Type Conversion","uri":"https://yorkfish.github.io/review/web/javascript/05-data-type-conversion/"},{"content":"参数表    参数 释义     border 设置边框属性（可以多个）   border-color 边框颜色   border-style 边框样式\nsolid 实线，dotted 点状线，dashed 虚线   border-width 边框粗细   border-left-color 左边框颜色（上下左右均可单独设置）   border-left-style 左边框样式（上下左右均可单独设置）   border-left-width 左边框高度（上下左右均可单独设置）   border-radius 圆角处理   box-shadow 必写参数：x 轴偏移，y 轴偏移，x 与 y 均接受负值\n非必写参数：模糊度，扩散程度，阴影颜色，内阴影设置    举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt; \u0026lt;p\u0026gt; 1234567890 \u0026lt;br\u0026gt; 1234567890 \u0026lt;br\u0026gt; 1234567890 \u0026lt;br\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt; \u0026lt;p\u0026gt; abcdefghijklmnopqrstuvwxyz \u0026lt;br\u0026gt; abcdefghijklmnopqrstuvwxyz \u0026lt;br\u0026gt; abcdefghijklmnopqrstuvwxyz \u0026lt;br\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt; \u0026lt;p\u0026gt; 一二三四五六七八九十 \u0026lt;br\u0026gt; 一二三四五六七八九十 \u0026lt;br\u0026gt; 一二三四五六七八九十 \u0026lt;br\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  *{ width: 80%; height: 100px; } .box1{ border: 3px solid black; /* 多个属性设置：3px 实线 黑色 */ border-radius: 20px; /* 圆角 */ box-shadow: 10px 10px 5px #888888; margin-bottom: 15px; /* 设置间距 */ } .box2{ border-width: 3px; /* 单个属性设置 */ border-style: dotted; /* 点状线 */ border-top-color: red; border-bottom-color: blue; border-left-color: orange; border-right-color: yellow; border-radius: 15% 50px; /* 左下右下为 15% 右上左下为 50px */ margin-bottom: 15px; } .box3{ border-left-width: 3px; border-left-style: dashed; /* 虚线 */ border-right: 6px solid; /* 两个属性设置 */ border-radius: 15px 30px 45px 60px; /* 左上为起点，顺时针走 */ }   \u0026gt;\u0026gt;\u0026gt;\n","description":"常用的边框设置","id":122,"section":"web","tags":null,"title":"05. Border Settings","uri":"https://yorkfish.github.io/review/web/css/05-common-border-settings/"},{"content":"1. 无序列表 1.1 简介  必要的标签：ul, li 标签的层级：\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;ul\u0026gt;  1.2 示例与效果 示例 1 2 3 4 5  \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;无序列表一\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;无序列表二\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;无序列表三\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   效果 \r无序列表一\r无序列表二\r无序列表三\r\r2. 有序列表 2.1 简介  必要的标签：ol, li 标签的属性  type  设置有序列表的标记类型 默认是数字 type=\u0026quot;i\u0026quot; 可以改为使用罗马数字   start  设置列表项标记的起始位置 默认从 1 开始 更改方法：start=3 可以改为从 3 开始      2.2 示例与效果 示例 1 2 3 4 5  \u0026lt;ol type=\u0026#34;i\u0026#34; start=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;li\u0026gt;有序列表，序号为 5\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;有序列表，序号为 6\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;有序列表，序号为 7\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt;   效果 有序列表，序号为 5\r有序列表，序号为 6\r有序列表，序号为 7\r\r3. 自定义列表 3.1 简介  必要的标签：dl, dt, dd \u0026lt;dl\u0026gt;: dl for definition list 定义了定义列表，用于结合 \u0026lt;dt\u0026gt; 和 \u0026lt;dd\u0026gt; \u0026lt;dt\u0026gt;: 定义列表中的项目 \u0026lt;dd\u0026gt;: 描述列表中的项目  3.2 示例与效果 示例 1 2 3 4 5 6 7  \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;dt 自定义列表一\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;dd 自定义列表一的内容\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;dd 自定义列表一的内容\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;dt 自定义列表二\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;dd 自定义列表二的内容\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt;   效果 \rdt 自定义列表一\rdd 自定义列表一的内容\rdd 自定义列表一的内容\rdt 自定义列表二\rdd 自定义列表二的内容\r\r","description":"列表标签","id":123,"section":"web","tags":null,"title":"05. List Label","uri":"https://yorkfish.github.io/review/web/html/05-list-label/"},{"content":" empty() size() begin(), end() front(), back() push_front(), push_back() pop_front(), pop_back() clear() []   1. 简介  deque: double-ended queue 双端队列 deque 是一个支持在两端高效插入或删除元素的连续线性存储空间 它就像是 vector 和 queue 的结合  与 vector 相比，deque 的优势是可以在头部增删元素，且仅需 O(1) 的时间 与 queue 相比，deque 的优势是可以像数组一样随机访问    2. 举例 例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;iostream\u0026gt;#include \u0026lt;deque\u0026gt; using namespace std; int main() { deque\u0026lt;int\u0026gt; a{2, 3, 4}; for (deque\u0026lt;int\u0026gt;::iterator i = a.begin(); i \u0026lt; a.end(); i ++ ) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a.front() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a.back() \u0026lt;\u0026lt; endl; // 头尾元素  a.push_front(1), a.push_back(5); // 头尾入队  cout \u0026lt;\u0026lt; a.front() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a.back() \u0026lt;\u0026lt; endl; a.pop_front(), a.pop_back(); // 头尾出队  cout \u0026lt;\u0026lt; a[0] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a[a.size() - 1] \u0026lt;\u0026lt; endl; a.clear(); // 清空队列  cout \u0026lt;\u0026lt; a.empty() \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n2\r3\r4\r2 4\r1 5\r2 4\r1\r例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;iostream\u0026gt;#include \u0026lt;deque\u0026gt; using namespace std; int main() { deque\u0026lt;int\u0026gt; a{3, 2, 1, 5, 4}; sort(a.begin(), a.end(), greater\u0026lt;int\u0026gt;()); // 降序  for (auto num : a) cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n5 4 3 2 1 ","description":"双端队列","id":124,"section":"cpp","tags":null,"title":"05. deque","uri":"https://yorkfish.github.io/review/cpp/stl/05-deque/"},{"content":"与、或、非  默认：\u0026amp;\u0026amp;, ||, ! 支持：and, or, not  可以和 Python 一样用    1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { if (1 and 1) cout \u0026lt;\u0026lt; \u0026#34;\u0026#39;and\u0026#39; is ok\u0026#34; \u0026lt;\u0026lt; endl; if (0 or 1) cout \u0026lt;\u0026lt; \u0026#34;\u0026#39;or\u0026#39; is ok\u0026#34; \u0026lt;\u0026lt; endl; if (not 0) cout \u0026lt;\u0026lt; \u0026#34;\u0026#39;not\u0026#39; is ok\u0026#34; \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n'and' is ok\r'or' is ok\r'not' is ok\r","description":"与 或 非","id":125,"section":"cpp","tags":null,"title":"05. logical operation","uri":"https://yorkfish.github.io/review/cpp/05-logical-operation/"},{"content":"希望在子线程结束后，再结束主线程 目标示意图 main thread_job\r| |\r------\u0026gt;\r| |\r\u0026lt;------\r| over\r例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import threading import time def thread_job(): print(\u0026#34;start job\\n\u0026#34;) time.sleep(1) print(\u0026#34;finish job\\n\u0026#34;) def main(): added_thread = threading.Thread(target=thread_job) added_thread.start() added_thread.join() # 有了这一行，主线程会等子线程运行结束后再结束 print(\u0026#34;all done\\n\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main()   \u0026gt;\u0026gt;\u0026gt;\nstart job\rfinish job\rall done\r","description":"等待","id":126,"section":"python","tags":null,"title":"05. join","uri":"https://yorkfish.github.io/review/python/threading/05-join/"},{"content":"例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import multiprocessing import time def sing(num): for i in range(num): print(\u0026#34;singing...\u0026#34;) time.sleep(0.5) def dance(num): for i in range(num): print(\u0026#34;dancing...\u0026#34;) time.sleep(0.5) if __name__ == \u0026#34;__main__\u0026#34;: sing_process = multiprocessing.Process(target=sing, args=(2,)) dance_process = multiprocessing.Process(target=dance, kwargs={\u0026#34;num\u0026#34;: 3}) sing_process.start() dance_process.start()   说明  args  以元组的方式给执行任务传递参数 注意顺序一致   kwargs  以字典的方式给执行任务传递参数 注意键值对一致    ","description":"两种传参方式","id":127,"section":"python","tags":null,"title":"05. transfer parameters","uri":"https://yorkfish.github.io/review/python/multiprocessing/05-transfer-parameters/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. 添加三个 entry 1 2 3 4 5 6  e1 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 20), show=None) # 显示 e2 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 20), show=\u0026#39;*\u0026#39;) # 隐藏 e3 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 20), show=\u0026#39;1\u0026#39;) # 恶搞 e1.pack() e2.pack() e3.pack()   3. 获取 entry 的内容 1  string = e1.get()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) e1 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 16), show=None) e2 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 16), show=\u0026#39;*\u0026#39;) e3 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 16), show=\u0026#39;1\u0026#39;) e1.pack() e2.pack() e3.pack() t = tk.Text(window, font=(\u0026#34;Arial\u0026#34;, 20), height=2) t.pack() def insert_point(): string = e1.get() t.insert(\u0026#34;insert\u0026#34;, string) b = tk.Button(window, text=\u0026#34;insert point\u0026#34;, width=14, height=2, command=insert_point) b.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n ps: 三个 entry 输入的都是 123  ","description":"文本输入框","id":128,"section":"python","tags":null,"title":"05. Entry","uri":"https://yorkfish.github.io/review/python/tkinter/05-entry/"},{"content":"1. 说明  函数名：filter 顾名思意：筛选程序、过滤器  2. 举例 例一 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = list(range(10)) \u0026gt;\u0026gt;\u0026gt; [e for e in a if e % 2 == 0] [0, 2, 4, 6, 8] \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = list(range(10)) \u0026gt;\u0026gt;\u0026gt; b = filter(lambda x: x % 2 == 0, a) \u0026gt;\u0026gt;\u0026gt; list(b) [0, 2, 4, 6, 8] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":129,"section":"python","tags":null,"title":"05. filter()","uri":"https://yorkfish.github.io/review/python/bif/05-filter/"},{"content":"1. 说明  与 for 对应的 else 只有完整地走完 for 后才生效  2. 举例 1 2 3 4 5 6 7 8 9 10 11 12  def find_num(lst, num): for i in lst: if i == num: print(\u0026#34;found\u0026#34;, num) break else: print(\u0026#34;not found\u0026#34;, num) lst = [1, 2, 3, 4, 5] find_num(lst, 3) find_num(lst, 6)   \u0026gt;\u0026gt;\u0026gt;\nfound 3\rnot found 6\r","description":"","id":130,"section":"python","tags":null,"title":"05. for-else","uri":"https://yorkfish.github.io/review/python/basics/05-for-else/"},{"content":" 通过 python -h 可以查看帮助信息  例一 python file   在 D:\\test 下新建文件 hellp.py\n  写入 print(\u0026quot;hello world\u0026quot;)\n  在命令行运行\nD:\\test\u0026gt;python hellp.py\rhello world\rD:\\test\u0026gt;\r  例二 python -m D:\\test\u0026gt;python -m hellp\rhello world\rD:\\test\u0026gt;\r例三 python -c C:\\Users\\York\u0026gt;python -c \u0026quot;print('hello world')\u0026quot;\rhello world\rC:\\Users\\York\u0026gt;\r例四 通过“标准输出”传递 C:\\Users\\York\u0026gt;echo print(\u0026quot;hello world\u0026quot;) | python\rhello world\rC:\\Users\\York\u0026gt;\r","description":"","id":131,"section":"python","tags":null,"title":"05. hello world","uri":"https://yorkfish.github.io/review/python/operation/05-hello-world/"},{"content":"1. 说明  numpy 有矩阵类 但还是尽量使用 ndarray 为好 不要混用！  2. 操作 导入 1  import numpy as np   创建 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12).reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; b = np.arange(12).reshape((4, 3)) \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] \u0026gt;\u0026gt;\u0026gt;   错误的用法 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; print(a * b) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: operands could not be broadcast together with shapes (3,4) (4,3) \u0026gt;\u0026gt;\u0026gt;   正确的用法 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; print(a.dot(b)) [[ 42 48 54] [114 136 158] [186 224 262]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(a @ b) [[ 42 48 54] [114 136 158] [186 224 262]] \u0026gt;\u0026gt;\u0026gt;   matrix  仅限 2d  1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; c = np.matrix(a) \u0026gt;\u0026gt;\u0026gt; d = np.matrix(b) \u0026gt;\u0026gt;\u0026gt; type(c) \u0026lt;class \u0026#39;numpy.matrix\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(c * d) [[ 42 48 54] [114 136 158] [186 224 262]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":132,"section":"python","tags":null,"title":"05. matrix multiplication","uri":"https://yorkfish.github.io/review/python/numpy/05-ndarray-matrix/"},{"content":"1. 说明  之前做 Python Challenge，对用到的“库”做过总结 另一个博客：\u0026gt;\u0026gt;\u0026gt;传送门  2. 预览  base64 binascii bz2 collections datetime diffflib email gzip hashlib os pickle Pillow re requests struct this urlib wave xmlrpc zipfile zlib  ","description":"","id":133,"section":"python","tags":null,"title":"05. others","uri":"https://yorkfish.github.io/review/python/module/05-others/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; class Hero(object): ... game_name = \u0026#34;LOL\u0026#34; # 类变量 ... \u0026gt;\u0026gt;\u0026gt; lijing = Hero() \u0026gt;\u0026gt;\u0026gt; lijing.game_name \u0026#39;LOL\u0026#39; \u0026gt;\u0026gt;\u0026gt; lijing.game_name = \u0026#34;DNF\u0026#34; \u0026gt;\u0026gt;\u0026gt; lijing.game_name \u0026#39;DNF\u0026#39; \u0026gt;\u0026gt;\u0026gt; del lijing.game_name \u0026gt;\u0026gt;\u0026gt; lijing.game_name \u0026#39;LOL\u0026#39; \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":134,"section":"python","tags":null,"title":"05. 类变量","uri":"https://yorkfish.github.io/review/python/class/05-class-var/"},{"content":"1. 简介  与 scanf() 和 printf() 作用相仿 都是格式化读写函数  2. 一般调用方式 fscanf(文件指针, 格式字符串, 输出表列);\rfprintf(文件指针, 格式字符串, 输出表列);\r3. 举例 例一 写 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); fprintf(fp, \u0026#34;%d, %.2f\u0026#34;, 100, 100.5); fclose(fp); return 0; }   例二 读 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); int i; float f; fscanf(fp, \u0026#34;%d, %f\u0026#34;, \u0026amp;i, \u0026amp;f); printf(\u0026#34;%d, %f\\n\u0026#34;, i, f); fclose(fp); return 0; }   4. 说明  在输入时要将 ASCII 码转换为二进制形式 在输出时又要将二进制形式转换成字符 花费时间较多 在内存与磁盘频繁交换数据的情况下，最好使用 fread 和 fwrite  ","description":"","id":135,"section":"c","tags":null,"title":"05. fscanf() \u0026 fprintf()","uri":"https://yorkfish.github.io/review/c/file/05-fscanf-and-fprintf/"},{"content":"例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #include \u0026lt;stdio.h\u0026gt; void traverseArray(int (*arr)[5], int arrSize, int arrColSize){ for (int i = 0; i \u0026lt; arrSize; i++) { for (int j = 0; j \u0026lt; arrColSize; j++) { printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main() { int nums[][5] = { {11, 12, 13, 14, 15}, {16, 17, 18, 19, 20}, {21, 22, 23, 24, 25} }; int arrSize = 3; int arrColSize = 5; traverseArray(nums, arrSize, arrColSize); return 0; }   ps1   int (*arr)[5] 表示 arr 是一个指针变量，它指向包含 5 个整型元素的一维数组\n  *p;: 数的指针可以接一维数组 =\u0026gt; (*p)[5]: 一维数组的指针可以接二维数组\n  缺点：列数是固定的\n  注意：括号必不可少，不能写成 *arr[5]，因为 *arr[5] 相当于 *(arr[5])，是指针数组\n  ps2  *(p+2) 是 p[2]，是数组 2 行的起始地址，也是 p[2][0] 的地址 p+2 是数组 2 行的起始地址 *(p+2) 与 p+2 的值相同，但 *(p+2)+3 不能写成 (p+2)+3，因为 (p+2)+3 等价于 p+5  例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt; void traverseArray(int** arr, int arrSize, int* arrColSize){ for (int i = 0; i \u0026lt; arrSize; i++) { for (int j = 0; j \u0026lt; arrColSize[i]; j++) { printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main() { int nums[][5] = { {11, 12, 13, 14, 15}, {16, 17, 18, 19, 20}, {21, 22, 23, 24, 25} }; int* arr[] = {nums[0], nums[1], nums[2]}; int arrSize = 3; int arrColSize[] = {5, 5, 5}; traverseArray(arr, arrSize, arrColSize); return 0; }   ","description":"","id":136,"section":"c","tags":null,"title":"05. 二维数组传参","uri":"https://yorkfish.github.io/review/c/pointer/05-array-param-transfer/"},{"content":"1. 常见的情况  ! \u0026gt; 算术 \u0026gt; 关系 \u0026gt; 逻辑 \u0026gt; 赋值 \u0026gt; 逗号  算术：*, /, %, +, - 关系：\u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=, !=, == 逻辑：\u0026amp;\u0026amp;, || 赋值：= 及其扩展（如 +=） 逗号：,    2. 保险的做法  加括号  ","description":"","id":137,"section":"c","tags":null,"title":"05. 优先级","uri":"https://yorkfish.github.io/review/c/basics/05-priority/"},{"content":"1. 全局变量  全局变量“管”的是它定义之下的语句 不在必要时，不要使用全局变量 全局变量使用过多，会降低程序的清晰性  2. 局部变量  在同一个源文件中，若外部变量与局部变量同名，在局部变量的作用范围内，外部变量被“屏蔽”  3. 划分要求  在程序设计中在划分模块时要求  模块的“内聚性”强 与其他模块的“耦合性”弱   即，模块功能单一，与其他模块之间的影响小  ","description":"","id":138,"section":"c","tags":null,"title":"05. 全局变量与局部变量","uri":"https://yorkfish.github.io/review/c/function/05-global-var-and-local-var/"},{"content":"1. 定义 例一 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char name[20]; char gender; int num; } Student; int main() { Student stu[3]; return 0; }   例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; } stu1[3]; struct { char name[20]; char gender; int num; } stu2[3]; int main() { return 0; }   2. 初始化 例三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char name[20]; char gender; int num; } Student; int main() { Student stu[] = { {\u0026#34;york\u0026#34;, \u0026#39;M\u0026#39;, 1}, {\u0026#34;fish\u0026#34;, \u0026#39;M\u0026#39;, 2}, {\u0026#34;jessy\u0026#34;, \u0026#39;F\u0026#39;, 3} }; return 0; }   例四 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; } stu[3] = { {\u0026#34;york\u0026#34;, \u0026#39;M\u0026#39;, 1}, {\u0026#34;fish\u0026#34;, \u0026#39;M\u0026#39;, 2}, {\u0026#34;jessy\u0026#34;, \u0026#39;F\u0026#39;, 3} }; int main() { printf(\u0026#34;%s\\n\u0026#34;, stu[2].name); return 0; }   3. 指向结构体数组元素的指针 例五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char gender; char name[20]; int num; } Student; int main() { Student stu[3] = { {\u0026#39;M\u0026#39;, \u0026#34;york\u0026#34;, 1}, {\u0026#39;M\u0026#39;, \u0026#34;fish\u0026#34;, 2}, {\u0026#39;F\u0026#39;, \u0026#34;jessy\u0026#34;, 3} }; Student* pStu = (Student*)stu[0].name; printf(\u0026#34;%s\\n\u0026#34;, pStu+1); // fish  return 0; }    不要这样用  例六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char gender; char name[20]; int num; } Student; int main() { Student stu[3] = { {\u0026#39;M\u0026#39;, \u0026#34;york\u0026#34;, 1}, {\u0026#39;M\u0026#39;, \u0026#34;fish\u0026#34;, 2}, {\u0026#39;F\u0026#39;, \u0026#34;jessy\u0026#34;, 3} }; Student* pStu = (Student*)stu[0].num; printf(\u0026#34;%d\\n\u0026#34;, pStu); // 1  printf(\u0026#34;%d\\n\u0026#34;, pStu+1); // 29, 1 + sizeof(Student)  printf(\u0026#34;%d\\n\u0026#34;, pStu+2); // 57, 1 + sizeof(Student)*2  return 0; }    不要这样用  ","description":"","id":139,"section":"c","tags":null,"title":"05. 结构体数组","uri":"https://yorkfish.github.io/review/c/struct-union-enum/05-struct-array/"},{"content":"(): 修饰原子 1. 作用  将多个原子视为一个原子处理 将括号中的内容暂存于内存，方便后期调用 改变优先级，配合 | 使用  2. 暂存  默认情况下，每个括号都会暂存规则 \\1: 复用第一个暂存规则（\\2, \\3, \u0026hellip; 同理） (?:): 取消暂存操作（可以减少内存开销）  3. 引用  (?P\u0026lt;名称\u0026gt;): 起名 (?P=名称): 引用有名称的规则  ","description":"分组","id":140,"section":"regex","tags":null,"title":"05. group","uri":"https://yorkfish.github.io/review/regex/05-group/"},{"content":"1. 有序列表  用法：No. + . + 1 个空格 + 内容 说明：有些地方，数字会显示为“英文字母”、“罗马数字”……  示例与效果   示例\n1. 有序列表 1\r2. 有序列表 2\r3. ……\r  效果\n 有序列表 1 有序列表 2 ……    2. 无序列表  用法：- + 1 个空格 + 内容 说明：- 可以用 + 或者 * 代替  示例与效果   示例\n- 无序列表 1\r- 无序列表 2\r- ……\r  效果\n 无序列表 1 无序列表 2 ……    3. 列表的层级 说明  “有序列表”与“无序列表”都可以表现层级，或者说是“嵌套” 层级可用 Tab 实现 一般地，Tab 的长度为 4，可以根据需要改动  示例与效果   示例\n- 第一级\r1. 第一项\r2. 第二项\r  效果\n 第一级  第一项 第二项      4. 补充   如果，想在行前使用数字，但又不想使用有序列表，可以用反斜杠转义\n  示例\n4\\. 补充\n  效果\n4. 补充\n  ","description":"","id":141,"section":"markdown","tags":null,"title":"06. 列表","uri":"https://yorkfish.github.io/review/markdown/06-lists/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  \\documentclass[UTF8]{ctexart} % 美国数学学会的几个包 \\usepackage{amssymb,amsfonts,amsmath,amsthm} \\begin{document} \\section{数学公式} \\begin{itemize} \\item 可以使用 mathtype 导出 TeX 代码 \\item 可以手写、拍照，再采用 mathpix snipping tools 工具识别，识别率超过 90\\% \\item 被占用的符号（如百分号）可以使用反斜杠转义 \\end{itemize} 数学公式分为两种 \\begin{enumerate} \\item 行内公式 $v=v_0+at$ \\item 块状公式 \\begin{enumerate} \\item 带编号 \\item 不带编号 \\end{enumerate} \\end{enumerate} % equation 表示会在公式右边打印编号  \\begin{euqation} E=mc^2 \\end{euqation} % 多个公式采用一个编号  \\begin{equation} \\begin{split} \\nabla \\cdot E\u0026amp;=\\frac{\\rho_0}{\\varepsilon_0}\\\\ \\nabla \\times E\u0026amp;=0 \\quad ~ \\text{麦克斯韦方程组} \\end{split} \\end{equation} % 不带编号 \\[是displaymath环境的简写  \\[x=v_0t+\\frac{1}{2} at^2\\] \\end{document}   ","description":"数学公式","id":142,"section":"latex","tags":null,"title":"06. Mathematical Formula","uri":"https://yorkfish.github.io/review/latex/06-mathematical-formula/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-model\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;!-- 1. 对普通文本框的值的设置 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; v-model=\u0026#34;msg\u0026#34;\u0026gt; {{msg}} \u0026lt;br\u0026gt; \u0026lt;!-- 2. 单选框与多选框 --\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; v-model=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; v-model=\u0026#34;gender\u0026#34; value=\u0026#34;0\u0026#34;\u0026gt; {{gender}} \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;live\u0026#34; value=\u0026#34;1\u0026#34; v-model=\u0026#34;live\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;live\u0026#34; value=\u0026#34;2\u0026#34; v-model=\u0026#34;live\u0026#34;\u0026gt; {{live}} \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;change\u0026#34; value=\u0026#34;1\u0026#34; v-model=\u0026#34;change\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;change\u0026#34; value=\u0026#34;2\u0026#34; v-model=\u0026#34;change\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;change\u0026#34; value=\u0026#34;3\u0026#34; v-model=\u0026#34;change\u0026#34;\u0026gt; {{change}} \u0026lt;br\u0026gt; \u0026lt;select v-model=\u0026#34;select\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;北京\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;上海\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;3\u0026#34;\u0026gt;广州\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; {{select}} \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { msg: \u0026#34;123\u0026#34;, gender: \u0026#34;1\u0026#34;, live: \u0026#34;\u0026#34;, change: [\u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;], select: \u0026#34;\u0026#34; } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   说明  v-model 一般用于表单的指令 将表单的 value 和数据模型当中的变量进行绑定 通常用来实现数据的双向绑定  ","description":"","id":143,"section":"web","tags":null,"title":"06. v-model","uri":"https://yorkfish.github.io/review/web/vue/06-v-model/"},{"content":"简介    运算符 举例     算术运算符 +, -, *, /, ++, --   字符串连接 +   赋值运算 =, +=, -=, *=, /=, %=   比较运算符 \u0026lt;, \u0026gt;, \u0026gt;=, \u0026lt;=, ==, !=, ===, !==   逻辑运算符 \u0026amp;\u0026amp;, `   位运算 ^, \u0026amp;, `   三元运算符 ? :    举例 例1 1 2 3 4 5 6 7 8 9 10 11  // 自增 i++ var num1 = 1; console.log(num1); // 1 num1++; console.log(num1); // 2  // 自减 i-- var num2 = 1; console.log(num2); // 1 num2--; console.log(num2); // 0   例2 1 2 3 4 5 6 7 8 9 10 11 12 13  /* 字符串连接：字符串及其之后的运算用\u0026#34;拼接\u0026#34; \u0026#39;1\u0026#39; + \u0026#39;2\u0026#39; \u0026#39;1\u0026#39; + 2 \u0026#39;1\u0026#39; + 2 + 3 1 + \u0026#39;2\u0026#39; 1 + 2 + \u0026#39;3\u0026#39; */ console.log(\u0026#39;1\u0026#39; + \u0026#39;2\u0026#39;); // 12 console.log(\u0026#39;1\u0026#39; + 2); // 12 console.log(\u0026#39;1\u0026#39; + 2 + 3); // 123  console.log(1 + \u0026#39;2\u0026#39;); // 12 console.log(1 + 2 + \u0026#39;3\u0026#39;); // 33   例3 1 2 3 4 5 6 7 8 9 10 11 12  /* === 全等 !== 不全等 */ var num1 = 1 == 1; console.log(num1); // true  var num2 = 1 === 1; console.log(num2); // true  console.log(\u0026#39;1\u0026#39; == 1); // true console.log(\u0026#39;1\u0026#39; === 1); // false   ","description":"运算符","id":144,"section":"web","tags":null,"title":"06. Operator","uri":"https://yorkfish.github.io/review/web/javascript/06-operator/"},{"content":"参数表    参数 释义     background-color 背景颜色   background-image 背景图片   background-repeat 是否重复   background-position 定位   background-size 背景大小\n举例：background-size: 100px 140px;    举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p class=\u0026#34;box1\u0026#34;\u0026gt; 001 \u0026lt;br\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;box2\u0026#34;\u0026gt; 002 \u0026lt;br\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  *{ width: 400px; height: 240px; } .box1{ background-color: #b35e59; background-image: url(../img/a-pic.jpg);/* 注：此图 200X120 */ background-repeat: no-repeat; /* 不重复 */ background-position: center; /* 图片定位：居中 */ /* 在网页当中让图片或者元素往上移动或者往左移动，需使用负值 */ } .box2{ background-color: #f1c4be; background-image: url(../img/a-pic.jpg); background-repeat: no-repeat; background-position: center; background-size: 25% 25%; /* width*25% height*25% */ /*background-size: 100px 60px; 因为数字是凑好的，所以效果与上方一致*/ }   \u0026gt;\u0026gt;\u0026gt;\n","description":"背景属性","id":145,"section":"web","tags":null,"title":"06. Background Attribute","uri":"https://yorkfish.github.io/review/web/css/06-background-attribute/"},{"content":"1. 标签与说明    标签 释义     \u0026lt;table\u0026gt; 声明一个表格   \u0026lt;th\u0026gt; 表头   \u0026lt;tr\u0026gt; 行   \u0026lt;td\u0026gt; 列    2. \u0026lt;table\u0026gt; 的属性    属性 释义     width 设置单元格的总体宽度   height 设置单元格的总体高度   border 设置边框显示与否   cellpadding 设置表格中的内容与边框的间距   cellspacing 设置表格与表格的间距    3. 单元格合并    属性 释义     colspan 设置水平方向一个单元格占据的宽度   rowspan 设置垂直方向一个单元格占据的高度    4. 单元格内容的对齐方式  水平对齐方式 align  默认靠左显示 center: 居中 right: 靠右   垂直对齐方式 valign  默认垂直居中 top: 靠上 bottom: 靠下    5. 补充   如果给 tr 设置，会影响整行\n  如果给 td 设置，只影响当前的单元格\n  th 标签：默认水平居中，有加粗效果\n  关于 \u0026lt;thead\u0026gt;, \u0026lt;tfoot\u0026gt;, \u0026lt;tbody\u0026gt;\n 这些元素内部必须包含一个或者多个 \u0026lt;tr\u0026gt; 标签 \u0026lt;tfoot\u0026gt; 必须出现在 \u0026lt;tbody\u0026gt; 之前 HTML5 中不再支持    6. 示例与效果 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;table border=\u0026#34;1\u0026#34; cellpadding=\u0026#34;10px\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;500px\u0026#34; height=\u0026#34;280px\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th colspan=\u0026#34;4\u0026#34;\u0026gt;表头\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 第二行 --\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34;\u0026gt;(2, 1) + (3, 1)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;(2, 2)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;(2, 3)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;(2, 4)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 第三行 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;(3, 2)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;(3, 3)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;(3, 4)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 第四行 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td valign=\u0026#34;top\u0026#34;\u0026gt;(4, 1)\u0026lt;/td\u0026gt; \u0026lt;td align=\u0026#34;right\u0026#34; valign=\u0026#34;bottom\u0026#34;\u0026gt;(4, 2)\u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026#34;bottom\u0026#34;\u0026gt;(4, 3)\u0026lt;/td\u0026gt; \u0026lt;td align=\u0026#34;right\u0026#34; valign=\u0026#34;top\u0026#34;\u0026gt;(4, 4)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;   效果 \r表头\r\r(2, 1) + (3, 1)\r(2, 2)\r(2, 3)\r(2, 4)\r\r\r(3, 2)\r(3, 3)\r(3, 4)\r\r\r(4, 1)\r(4, 2)\r(4, 3)\r(4, 4)\r\r\r","description":"表格标签","id":146,"section":"web","tags":null,"title":"06. Form Label","uri":"https://yorkfish.github.io/review/web/html/06-form-label/"},{"content":"1. 一些概念  函数内的数组会存在栈空间，约 1 M 函数外的数组会存在堆空间，能开多大取决于内存大小 函数外定义的变量、数组等全局变量，若没有初始化，默认均为零  2. memset 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; // memset using namespace std; int main() { int a[10]; memset(a, 0, sizeof a); // 将 a 的每一个字节都赋值成 0  for (int i = 0; i \u0026lt; 10; i ++ ) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n0 0 0 0 0 0 0 0 0 0 ps  memset() 在 \u0026lt;cstring\u0026gt; 中 memset() 是一个字节一个字节地赋值的，若 int 有 4 个字节，有些数是赋不了的 sizeof a 与 sizeof(a) 都能用，在可能有歧义时，还是用后者为好  3. memcpy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; int main() { int a[10], b[10]; for (int i = 0; i \u0026lt; 10; i ++ ) a[i] = i; memcpy(b, a, sizeof a); // 从存储区 a 复制 sizeof(a) 个字节到存储区 b  for (int i = 0; i \u0026lt; 10; i ++ ) cout \u0026lt;\u0026lt; b[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n0 1 2 3 4 5 6 7 8 9 ps  memcpy() 在 \u0026lt;cstring\u0026gt; 中 memcpy() 操作字符串比较多  4. reverse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int a[10]; for (int i = 0; i \u0026lt; 10; i ++ ) a[i] = i; reverse(a, a + 10); // 翻转 a[0] 起的 10 个数  for (int i = 0; i \u0026lt; 10; i ++ ) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n9 8 7 6 5 4 3 2 1 0 ps  reverse() 在 \u0026lt;algorithm\u0026gt; 中，我在《13 库函数》那里也有写  sort(), swap() 都在 \u0026lt;algorithm\u0026gt; 里    5. 高精度  计算 2^n (n\u0026lt;=1000)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int nums[1000] = {1}; int size = 1; int n; // n \u0026lt;= 1000  cin \u0026gt;\u0026gt; n; while (n -- ) { int carry = 0; for (int i = 0; i \u0026lt; size; i ++ ) { carry += nums[i] * 2; nums[i] = carry % 10; carry /= 10; } if (carry) nums[size ++ ] = carry; } for (int i = size - 1; i \u0026gt;= 0; i -- ) cout \u0026lt;\u0026lt; nums[i]; cout \u0026lt;\u0026lt; endl; return 0; }   6. 多维数组  int array[3][4][5] = {0}; // 将所有元素初始化为 0  ","description":"数组","id":147,"section":"cpp","tags":null,"title":"06. array","uri":"https://yorkfish.github.io/review/cpp/06-array/"},{"content":" empty() size() clear() begin(), end() ++, \u0026ndash;   insert() find() lower_bound(), upper_bound() erase() count()   1. 简介  \u0026lt;set\u0026gt; 主要包括 set 和 multiset 两个容器，分别是“有序集合”和“有序多重集合” set 的元素不能重复，multiset 可以，它们支持的方法基本相同 set, map, multiset, multimap 基于平衡二叉树（红黑树），动态维护有序序列 set 和 multiset 的迭代器称为“双向访问迭代器”，不支持随机访问，支持 * 解除引用 元素默认按升序排列  2. 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #include \u0026lt;iostream\u0026gt;#include \u0026lt;set\u0026gt; using namespace std; struct rectangle { int x, y; bool operator\u0026lt; (const rectangle\u0026amp; t) const // set 会用到 \u0026lt;，所以需要重载，而且必须重载  { return x \u0026lt; t.x; } }; int main() { set\u0026lt;int\u0026gt; a; // 元素不能重复，存入的数会变得有序，默认升序  multiset\u0026lt;int\u0026gt; b; // 元素可以重复  set\u0026lt;rectangle\u0026gt; c; // 支持结构体  set\u0026lt;int\u0026gt;::iterator it; it ++ ; // ++ 与 -- 是找有序（升序）序列里的“前驱”与“后继”  // size(), empty(), clear() 与 vector 类似  return 0; }   3. begin \u0026amp; end  返回集合的首、尾迭代器 时间复杂度均为 O(1) s.begin() 是指向集合中最小元素的迭代器 s.end() 是指向集合中最大元素的下一个位置的迭代器 vector 一样，都是“左闭右开” 那么 -- s.end() 指向集合中最大元素  4. insert  s.insert(x) 表示把一个元素 x 插入到集合 s 中 时间复杂度为 O(logn) 你无法两次进入同一个 set  5. find  s.find(x) 表示在集合 s 中查找等于 x 的元素，并返回指向该元素的迭代器 若不存在，则返回 s.end() 时间复杂度为 O(logn)  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;iostream\u0026gt;#include \u0026lt;set\u0026gt; using namespace std; int main() { // 若 a 找到 x，返回一个迭代器；若没找到，返回 a.end()  set\u0026lt;int\u0026gt; s{1, 2, 3}; if (s.find(2) == s.end()) cout \u0026lt;\u0026lt; \u0026#34;not found 2\u0026#34; \u0026lt;\u0026lt; endl; if (s.find(5) == s.end()) cout \u0026lt;\u0026lt; \u0026#34;not found 5\u0026#34; \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\nnot found 5\r6. lower_bound \u0026amp; upper_bound  这两个函数的用法与 find 类似，但查找的条件略有不同 时间复杂度为 O(logn) s.lower_bound(x) 查找大于等于 x 的元素中最小的一个，并返回指向该元素的迭代器 s.upper_bound(x) 查找大于 x 的元素中最小的一个，并返回指向该元素的迭代器 需要注意的是这里的 lower 与 upper 并不是反义关系，而是相差一个“等于”  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;iostream\u0026gt;#include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; s{1, 2, 3, 4, 5}; cout \u0026lt;\u0026lt; *s.lower_bound(3) \u0026lt;\u0026lt; endl; // 找到大于等于 3 的最小元素的迭代器  cout \u0026lt;\u0026lt; *s.upper_bound(3) \u0026lt;\u0026lt; endl; // 找到大于 3 的最小元素的迭代器  return 0; }   \u0026gt;\u0026gt;\u0026gt;\n3\r4\r7. erase  对于迭代器 it，s.erase(it) 表示从 s 中删除迭代器 it 指向的元素，时间复杂度为 O(logn) 对于一个元素 x，s.erase(x) 表示从 s 中删除所有等于 x 的元素，时间复杂度为O(k + logn)，其中 k 是被删除的元素个数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;iostream\u0026gt;#include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; s{1, 2, 3, 4, 5}; s.erase(2); // 删除 2 的所有的迭代器  set\u0026lt;int\u0026gt;::iterator it = s.find(3); s.erase(it); // 删除迭代器 it  for (int i : s) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1 4 5 8. count  s.count(x) 返回集合 s 中等于 x 的元素个数，时间复杂度为 O(k +logn)，其中 k 为元素 x 的个数  1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;iostream\u0026gt;#include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; s{1, 2, 3, 4, 5}; cout \u0026lt;\u0026lt; s.count(3) \u0026lt;\u0026lt; endl; // 对于 set 而言，存在即为 1，不存在即为 0  return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1\r9. 效率总结  迭代器的获取都是 o(1) it ++ ; it \u0026ndash; ; 都是 o(logn) insert(); 是 o(logn) find(); 是 o(logn) 二分是 o(logn) erase(迭代器) 是 o(logn)，迭代器可以理解成指针 erase(元素) 是 o(k + logn)，k 是被删除的元素个数 count(x) 是 o(k + logn)，k 是 x 的个数  ","description":"有序集合","id":148,"section":"cpp","tags":null,"title":"06. set","uri":"https://yorkfish.github.io/review/cpp/stl/06-set/"},{"content":"1. 说明  因为不作为分组，所以无法复用或引用  2. 注释  (?#注释)  3. 断言  先行断言从左往右看 后行断言从右往左看   正向先行断言   (?=表达式)\n  如 york(?=fish)，匹配 york，但必须是 yorkfish 的 york\n  例\n 至少一个大写字母 至少一个小写字母 至少一个数字 至少八个字符    解\n (?=.*?[a-z])(?=.*?[A-Z])(?=.*?\\d).{8,}    反向先行断言  (?!表达式) 如 york(?!fish)，匹配 york，但不能是 yorkfish 的 york  正向后行断言  (?\u0026lt;=表达式) 如 (?\u0026lt;=york)fish，匹配 fish，但必须是 yorkfish 的 fish  反向后行断言  (?\u0026lt;!表达式) 如 (?\u0026lt;!york)fish，匹配 fish，但不能是 yorkfish 的 fish  ","description":"不作为分组的括号","id":149,"section":"regex","tags":null,"title":"06. brackets","uri":"https://yorkfish.github.io/review/regex/06-brackets/"},{"content":"例一 args 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  import threading import time from queue import Queue def job(lst, q): for i in range(len(lst)): lst[i] = lst[i] ** 2 q.put(lst) def multi_threading(data): q = Queue() threads = [] length = len(data) for i in range(length): t = threading.Thread(target=job, args=(data[i], q)) t.start() threads.append(t) for thread in threads: thread.join() results = [] for _ in range(length): results.append(q.get()) print(results) if __name__ == \u0026#34;__main__\u0026#34;: data = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] multi_threading(data)   \u0026gt;\u0026gt;\u0026gt;\n[[1, 4, 9], [16, 25, 36], [49, 64, 81]]\r说明  args: 以元组的方式给执行任务传递参数 注意顺序一致  补充  若不传参，可以加 args=() 或者直接不写 线程安全变量类型： queue 线程不安全变量类型： list, set, dict  例二 kwargs 1 2 3 4 5 6 7 8 9 10 11 12 13  import threading import time def dance(count): for i in range(count): print(\u0026#34;dancing...\u0026#34;) time.sleep(0.1) if __name__ == \u0026#34;__main__\u0026#34;: dance_thread = threading.Thread(target=dance, kwargs={\u0026#34;count\u0026#34;: 3}) dance_thread.start()   \u0026gt;\u0026gt;\u0026gt;\ndancing...\rdancing...\rdancing...\r说明  kwargs: 以字典的方式给执行任务传递参数 注意键值对一致  ","description":"传参","id":150,"section":"python","tags":null,"title":"06. transfer parameters","uri":"https://yorkfish.github.io/review/python/threading/06-transfer-parameters/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8 9 10  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x400\u0026#34;) str1 = tk.StringVar() l = tk.Label(window, textvariable=str1, bg=\u0026#34;yellow\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 20), width=10, height=2) l.pack() window.mainloop()   2. 添加一个 listbox 1 2 3 4  string = tk.StringVar() string.set((11, 22, 33, 44)) lb = tk.Listbox(window, listvariable=string) lb.pack()   3. insert 内容 1 2  lb.insert(\u0026#34;end\u0026#34;, 100) # 在末尾 insert lb.insert(0, \u0026#34;first\u0026#34;) # 索引从 0 开始   4. delete 内容 1  lb.delete(2) # 索引从 0 开始   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x400\u0026#34;) str1 = tk.StringVar() l = tk.Label(window, textvariable=str1, bg=\u0026#34;yellow\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 20), width=10, height=2) l.pack() def print_selection(): value = lb.get(lb.curselection()) # 取出当前选择的值 str1.set(value) b = tk.Button(window, text=\u0026#34;insert print selection\u0026#34;, bg=\u0026#34;white\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 12), command=print_selection) b.pack() str2 = tk.StringVar() str2.set((11, 22, 33, 44)) lb = tk.Listbox(window, listvariable=str2, font=(\u0026#34;Consolas\u0026#34;, 16)) for item in [1, 2, 3, 4]: lb.insert(\u0026#34;end\u0026#34;, item) lb.insert(0, \u0026#34;first\u0026#34;) lb.insert(2, \u0026#34;second\u0026#34;) lb.delete(2) lb.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"列表部件","id":151,"section":"python","tags":null,"title":"06. Listbox","uri":"https://yorkfish.github.io/review/python/tkinter/06-listbox/"},{"content":"1. 说明  有人喜欢 '%s %s' % ('one', 'two') 的形式 有人喜欢 '{} {}'.format(1, 2) 的形式 于是 Python 保留了两种形式 3.6 之后，增加了 f-string 3.8 之后，f-string 增加了 f'{expr=}'  2. 简介  要详细了解，还得去看官方文档 format 在格式详见例四  2. 举例 例一 % 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;a_tuple: (%d, %d)\u0026#34; % (1, 2)) a_tuple: (1, 2) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;a_list: %s\u0026#34; % [1, 2]) a_list: [1, 2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;a_dict: %s\u0026#34; % {\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2}) a_dict: {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt;   例二 format 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; t = (1, 2) \u0026gt;\u0026gt;\u0026gt; \u0026#34;a_tuple = {}\u0026#34;.format(t) \u0026#39;a_tuple = (1, 2)\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026#34;t[0] = {}, t[1] = {}\u0026#34;.format(*t) \u0026#39;t[0] = 1, t[1] = 2\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;:2} \u0026gt;\u0026gt;\u0026gt; \u0026#34;d[\u0026#39;a\u0026#39;] = {a}, dict_e[\u0026#39;b\u0026#39;] = {b}\u0026#34;.format(**d) \u0026#34;d[\u0026#39;a\u0026#39;] = 1, dict_e[\u0026#39;b\u0026#39;] = 2\u0026#34; \u0026gt;\u0026gt;\u0026gt;   例三 f-string 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; name = \u0026#34;YorkFish\u0026#34; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;name: {name}\u0026#34; \u0026#39;name: YorkFish\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{name=}\u0026#34; \u0026#34;name=\u0026#39;YorkFish\u0026#39;\u0026#34; \u0026gt;\u0026gt;\u0026gt;   例四 更多格式  格式：{[index][: [[fill] align] [sign] [width] [.precision] [type]]}     align 含义     \u0026lt; 左对齐   \u0026gt; 右对齐   = 右对齐\n只对数字类型有效，若有符号或设置了符号，显示在最左侧   ^ 居中\n需和 width 参数一起使用       sign 含义     + 正数前加正号   空格 正数前加空格   # 二进制数、八进制数和十六进制数，会以相应的形式显示\n需和 type 参数一起使用       type 含义     s 字符串   d 十进制整数   c 十进制整数对应的 Unicode 字符   b 二进制   o 八进制   x/X 十六进制   f/F 浮点数，默认保留小数点后 6 位   e/E 科学计数法   g/G 在 f 和 e 中选择合适的   % 显示百分比，默认显示小数点后 6 位    1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; num = 1234567890 \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:,}\u0026#34; \u0026#39;1,234,567,890\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:=\u0026gt;+20.6e}\u0026#34; \u0026#39;=======+1.234568e+09\u0026#39; \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":152,"section":"python","tags":null,"title":"06. format","uri":"https://yorkfish.github.io/review/python/basics/06-format/"},{"content":"1. 先说结论  字符串是不可变对象，每次使用 + 拼接，都会生成新对象 join() 没有中间字符串生成，效率较高   计算结果所需的内存 一次性申请内存空间 把每个字符串复制过去   2. 举例论证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from time import perf_counter count = 100000 s = \u0026#39;\u0026#39; start1 = perf_counter() for i in range(count): s += \u0026#39;a\u0026#39; stop1 = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#39;+=\u0026#39; run time is: %.6fs\u0026#34; % (stop1 - start1)) lst = [\u0026#39;a\u0026#39;] * count start2 = perf_counter() \u0026#39;\u0026#39;.join(lst) stop2 = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#39;join\u0026#39; run time is: %.6fs\u0026#34; % (stop2 - start2))   ","description":"","id":153,"section":"python","tags":null,"title":"06. join()","uri":"https://yorkfish.github.io/review/python/bif/06-join/"},{"content":"1. 说明  REPL: read-evaluates-print loop evaluates 对应的是 exec，不是 eval  2. Banner 横幅  命令行敲完 python 后出现的信息  Python 3.8.3 (default, Jul 2 2020, 17:30:36) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\rType \u0026quot;help\u0026quot;, \u0026quot;copyright\u0026quot;, \u0026quot;credits\u0026quot; or \u0026quot;license\u0026quot; for more information.\r有意思的小例子 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; import code \u0026gt;\u0026gt;\u0026gt; code.interact(banner=\u0026#34;welcome\u0026#34;, exitmsg=\u0026#34;bye~\u0026#34;) welcome \u0026gt;\u0026gt;\u0026gt; # 按 Ctrl-z bye~ \u0026gt;\u0026gt;\u0026gt;   3. ps  ps: Prompt String  1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; import sys \u0026gt;\u0026gt;\u0026gt; sys.ps1 \u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026#39; \u0026gt;\u0026gt;\u0026gt; sys.ps2 \u0026#39;... \u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; sys.ps1 = \u0026#34;==\u0026gt; \u0026#34; # 重启失效；若不想失效，可仿照下文，写入 startup.py ==\u0026gt; sys.ps2 = \u0026#34;--- \u0026#34; ==\u0026gt; if 1 \u0026lt; 2: --- print(\u0026#34;Y\u0026#34;) --- Y ==\u0026gt;   有意思的小实验   新建一个 python 文件 D:\\Code\\Python\\startup.py\n  写入如下语句\n1 2 3 4  from time import strftime, localtime now = strftime(\u0026#34;%Y-%m-%d%H:%M:%S\u0026#34;, localtime()) print(\u0026#34;Hello YorkFish! \u0026#34;, now)     添加环境变量\n 为用户新增环境变量 变量名：PYTHNSTARTUP 变量值：D:\\Code\\Python\\startup.py    重启命令行\n  4. str \u0026amp; repr 例一 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; \u0026#34;yorkfish\u0026#34; \u0026#39;yorkfish\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;yorkfish\u0026#34;) yorkfish \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; class Test: ... def __repr__(self): ... return \u0026#39;repr\u0026#39; ... def __str__(self): ... return \u0026#39;str\u0026#39; ... \u0026gt;\u0026gt;\u0026gt; t = Test() \u0026gt;\u0026gt;\u0026gt; t repr \u0026gt;\u0026gt;\u0026gt; print(t) str \u0026gt;\u0026gt;\u0026gt;   5. 退出   exit() 或 quit()\n  exit() 可以传参\n exit(1) 表示异常退出 exit(0) 表示正常退出     Windows 快捷键：Ctrl + z\n  Linux 快捷键：Ctrl + d\n  ","description":"","id":154,"section":"python","tags":null,"title":"06. REPL","uri":"https://yorkfish.github.io/review/python/operation/06-repl/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; class Hero(object): ... game_name = \u0026#34;LOL\u0026#34; # 类变量 ... def __init__(self, name): ... self.name = name # 实例变量，由每个对象自行赋值，对象之间不影响 ... \u0026gt;\u0026gt;\u0026gt; lijing = Hero(\u0026#34;Lingjing\u0026#34;) \u0026gt;\u0026gt;\u0026gt; lijing.name \u0026#39;Lingjing\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; garen = Hero(\u0026#34;Garen\u0026#34;) \u0026gt;\u0026gt;\u0026gt; garen.name \u0026#39;Garen\u0026#39; \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":155,"section":"python","tags":null,"title":"06. 实例变量","uri":"https://yorkfish.github.io/review/python/class/06-instance-var/"},{"content":"1. 简介  大多数 C 编译系统都提供 getw 和 putw 用来对磁盘文件读写一个字（整数）  2. 举例 例一 使用自带的函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); putw(10, fp); fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); int i = getw(fp); printf(\u0026#34;%d\\n\u0026#34;, i); fclose(fp); return 0; }   例二 使用自定义的函数  putw 和 getw 不是 ANSI C 标准定义的函数，可以自己定义  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;stdio.h\u0026gt; int putw(int i, FILE* fp) { char* s = (char*)\u0026amp;i; putc(s[0], fp); // 指向 i 的第一个字节  putc(s[1], fp); putc(s[2], fp); putc(s[3], fp); return i; } int getw(FILE* fp) { int i; char* s = (char*)\u0026amp;i; // 使 s 指向 i 的起始地址  s[0] = getc(fp); s[1] = getc(fp); s[2] = getc(fp); s[3] = getc(fp); return i; } int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); putw(10, fp); fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); int i = getw(fp); printf(\u0026#34;%d\\n\u0026#34;, i); fclose(fp); return 0; }    int 的字节数与 char 对上就行  例三  定义一个向磁盘文件写一个实数（用二进制的方式）的函数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #include \u0026lt;stdio.h\u0026gt; void putfloat(float num, FILE* fp) { char* s = (char*)\u0026amp;num; int fsize = sizeof(float); for (int i = 0; i \u0026lt; fsize; i++) { putc(s[i], fp); // fputc  } } int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); putfloat(10.0, fp); fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); float f; fread(\u0026amp;f, sizeof(float), 1, fp); printf(\u0026#34;%f\\n\u0026#34;, f); fclose(fp); return 0; }   ","description":"","id":156,"section":"c","tags":null,"title":"06. getw() \u0026 putw()","uri":"https://yorkfish.github.io/review/c/file/06-getw-and-putw/"},{"content":"1. 两种角度  从变量的作用域（空间）角度来分  全局变量 局部变量   从变量值存在的时间（生存期）角度来分  静态存储方式 动态存储方式    2. 结构  用户区\r-----------\r| 程序区 |\r-----------\r| 静态存储区 |\r-----------\r| 动态存储区 |\r-----------\r3. 说明  自动变量：未加 static 声明的局部变量 每一个变量和函数都有两个属性  数据类型 数据的存储类别    ","description":"","id":157,"section":"c","tags":null,"title":"06. 变量的存储类别","uri":"https://yorkfish.github.io/review/c/function/06-storage-category-of-var/"},{"content":"1. 除法  如果除数或被除数中有一个为负值，则舍入的方向是不固定的 如 -5/3  有的系统：-1 （取整后向零靠拢） 有的系统：-2   C/C++ 一般是“取整后向零靠拢”  余数的符号看被除数   Python 一般是另一种  余数的符号看除数    例一 C 程序 1 2 3 4 5 6 7  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;-5 / 3 = %d ...... %d\\n\u0026#34;, -5/3, -5%-3); return 0; }    运行结果：-5 / 3 = -1 ...... -2  例二 Python 程序 1  print(\u0026#34;-5 / 3 = %d...... %d\u0026#34; % (-5//3, -5%3))    运行结果：-5 / 3 = -2 ...... 1  2. 加减乘除  如果参加四则运算的数中有 float 或 double 类型，则结果是 double 型 因为所有的 float 都按 double 进行运算  ","description":"","id":158,"section":"c","tags":null,"title":"06. 四则运算","uri":"https://yorkfish.github.io/review/c/basics/06-arithmetic/"},{"content":"1. 字符数组和字符指针变量  字符数组：只能单个更改 字符指针：只能整体更改  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { char str1[] = \u0026#34;york\u0026#34;; str1[0] = \u0026#39;Y\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, str1); char* str2 = \u0026#34;fish\u0026#34;; str2 = \u0026#34;Fish\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, str2); return 0; }   2. 指向函数的指针 一般定义形式  数据类型 (*指针变量名)(函数参数表列); 如：int (*p)(int, int);  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int max2(int a, int b) { return a\u0026lt;b? b: a; } int main() { int (*p)(int, int); p = max2; int a = 1, b = 2; int c = (*p)(a, b); printf(\u0026#34;%d\\n\u0026#34;, c); return 0; }   ps  () 优先级高于 * 函数名代表该函数的入口地址 函数指针可以用来存放函数的入口地址，它不固定指向某一函数 函数的调用可以通过函数名，也可以通过函数指针 给函数指针变量赋值时，只需给出函数名而不必给出参数 对于指向函数的指针变量，像 p+n, p++, p-- 等运算是无意义的  3. 用函数指针作函数参数 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;stdio.h\u0026gt; int max2(int a, int b) { return a\u0026lt;b? b: a; } int min2(int a, int b) { return a\u0026lt;b? a: b; } int process(int x, int y, int (*fun)(int, int)) { int res = (*fun)(x, y); return res; } int main() { int a = 1, b = 2; printf(\u0026#34;max(a, b) = %d\\n\u0026#34;, process(a, b, max2)); printf(\u0026#34;min(a, b) = %d\\n\u0026#34;, process(a, b, min2)); return 0; }   ps  这种方法是符合结构化程序设计方法原则的，是程序设计中常用的  4. 返回指针值的函数 一般定义形式  类型名* 函数名(参数表列); 如：int* test(int*, int);  ","description":"","id":159,"section":"c","tags":null,"title":"06. 字符串与指针","uri":"https://yorkfish.github.io/review/c/pointer/06-strings-and-pointers/"},{"content":"并不是简单地累加成员变量占用的大小 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include \u0026lt;stdio.h\u0026gt; struct test1 { char gender; }; struct test2 { char gender; int num; }; struct test3 { char gender; double score; }; struct test4 { char gender; int num; double score; }; struct test5 { char gender; char name[20]; }; int main() { printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test1)); // 1  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test2)); // 8  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test3)); // 16  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test4)); // 16  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test5)); // 21  return 0; }   ","description":"","id":160,"section":"c","tags":null,"title":"06. 结构体类型的大小","uri":"https://yorkfish.github.io/review/c/struct-union-enum/06-sizeof-struct/"},{"content":"例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  import multiprocessing as mp import threading as td import time def job(q): res = 0 for i in range(10000): res += i + i**2 + i**3 q.put(res) def normal(): res = 0 # 既然多线程与多进程都做两组，那么普通方式也做两次 for _ in range(2): for i in range(10000): res += i + i**2 + i**3 print(\u0026#34;normal:\u0026#34;, res) def multi_thread(): q = mp.Queue() # 可以使用 multiprocessing 的 Queue t1 = td.Thread(target=job, args=(q,)) t2 = td.Thread(target=job, args=(q,)) t1.start() t2.start() t1.join() t2.join() res1 = q.get() res2 = q.get() print(\u0026#34;thread:\u0026#34;, res1 + res2) def multi_core(): q = mp.Queue() p1 = mp.Process(target=job, args=(q,)) p2 = mp.Process(target=job, args=(q,)) p1.start() p2.start() p1.join() p2.join() res1 = q.get() res2 = q.get() print(\u0026#34;core:\u0026#34;, res1 + res2) if __name__ == \u0026#34;__main__\u0026#34;: st = time.time() normal() st1 = time.time() print(\u0026#34;normal time:\u0026#34;, st1 - st) multi_thread() st2 = time.time() print(\u0026#34;multi_thread time:\u0026#34;, st2 - st1) multi_core() st3 = time.time() print(\u0026#34;multi_core time:\u0026#34;, st3 - st2)   说明  不同运行环境，结果有所不同 计算密集型，多核多进程拥有优势 I/O 密集型，多进程体现不出优势  ","description":"普通方式、多进程与多线程的效率对比","id":161,"section":"python","tags":null,"title":"06. efficiency comparison","uri":"https://yorkfish.github.io/review/python/multiprocessing/06-efficiency-comparison/"},{"content":"1. 导入 1  import numpy as np   2. 操作 切片 一维 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12) \u0026gt;\u0026gt;\u0026gt; print(a) [ 0 1 2 3 4 5 6 7 8 9 10 11] \u0026gt;\u0026gt;\u0026gt; print(a[1]) 1 \u0026gt;\u0026gt;\u0026gt; print(a[2:8]) [2 3 4 5 6 7] \u0026gt;\u0026gt;\u0026gt; print(a[2:8:2]) [2 4 6] \u0026gt;\u0026gt;\u0026gt; print(a[::-1]) [11 10 9 8 7 6 5 4 3 2 1 0] \u0026gt;\u0026gt;\u0026gt;   二维 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; b = np.arange(12).reshape((4, 3)) \u0026gt;\u0026gt;\u0026gt; print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(b[0]) [0 1 2] \u0026gt;\u0026gt;\u0026gt; print(b[1][2]) 5 \u0026gt;\u0026gt;\u0026gt; print(b[1:3, :0:-1]) [[5 4] [8 7]] \u0026gt;\u0026gt;\u0026gt;   迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; for i in b.flat: ... print(i) ... 0 1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":162,"section":"python","tags":null,"title":"06. index-slice-iterator","uri":"https://yorkfish.github.io/review/python/numpy/06-ndarray-slice/"},{"content":"1. Markdown 方式  用法：至少三个星号 说明  独占一行 星号间可以有空格，但不推荐 * 可以用 - 或者 _ 代替    示例与效果   示例\n***\n  效果\n  2. HTML 方式  用法：借助 HTML 的标签 \u0026lt;hr\u0026gt; 说明：\u0026lt;hr\u0026gt; 的 width 参数有两种方式设置长度  示例与效果   示例\n\u0026lt;hr\u0026gt;\r\u0026lt;hr width=50%\u0026gt; \u0026lt;!--按百分比--\u0026gt;\r\u0026lt;hr width=200px\u0026gt; \u0026lt;!--按像素--\u0026gt;\r  效果\n\r  ","description":"","id":163,"section":"markdown","tags":null,"title":"07. 分割线","uri":"https://yorkfish.github.io/review/markdown/07-split-line/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13  \\documentclass[UTF8]{ctexart} % 画图的包 \\usepackage{tikz} \\begin{document} \\begin{tikzpicture} \\draw (0,0) circle (3cm); \\draw (6,0) rectangle (8,4); \\end{tikzpicture} \\end{document}   ","description":"画图","id":164,"section":"latex","tags":null,"title":"07. Draw","uri":"https://yorkfish.github.io/review/latex/07-draw/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-for\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 1. v-for=\u0026#34;\u0026#34; 此处一定要使用双引号 --\u0026gt; \u0026lt;li v-for=\u0026#34;i in arr\u0026#34;\u0026gt;{{i}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 2. 2.1 v,i 加不加括号均可 2.2 v,i 可以用别的变量替换 2.3 可以做简单的运算 2.4 :key=\u0026#34;idx\u0026#34; 加与不加，影响不大，但是推荐加上 --\u0026gt; \u0026lt;li v-for=\u0026#34;v,idx in arr\u0026#34; :key=\u0026#34;idx\u0026#34;\u0026gt;{{v}} -\u0026gt; {{idx+1}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 3. 此处与 Python 的字典有所不同 3.1 key 与 value 顺序相反 3.2 有索引值，排在第三位 --\u0026gt; \u0026lt;li v-for=\u0026#34;v,k,idx in obj\u0026#34;\u0026gt;{{k}} -\u0026gt; {{v}} -\u0026gt; {{idx}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { arr: [\u0026#34;铅笔\u0026#34;, \u0026#34;橡皮\u0026#34;, \u0026#34;尺子\u0026#34;, \u0026#34;圆规\u0026#34;], obj: { name: \u0026#34;张三\u0026#34;, gender: \u0026#34;1\u0026#34;, // 一般地，男：1，女：0  length: \u0026#34;180cm\u0026#34; } } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   ","description":"循环","id":165,"section":"web","tags":null,"title":"07. v-for","uri":"https://yorkfish.github.io/review/web/vue/07-v-for/"},{"content":"if 三种形式 1 2 3 4 5 6 7 8 9 10 11  // 第一种 if... // 第二种 if... else ... // 第三种 if... else if... else...   说明  支持单分支、双分支、多分支 else if 中间必须要有空格  举例 1 2 3 4 5 6  if (1 + 1 == 2) { console.log(\u0026#34;true\u0026#34;); } else { console.log(\u0026#34;false\u0026#34;); }   switch  多分支语句  1 2 3 4 5 6 7 8 9 10 11  switch (n) { case 1: ... break; case 2: ... break; ... default: ... // 对于 case 1 ~ case n 均不符合时，执行此语句 }   ","description":"流程控制","id":166,"section":"web","tags":null,"title":"07. Process Control","uri":"https://yorkfish.github.io/review/web/javascript/07-process-control/"},{"content":" 当子元素的尺寸超过父元素的尺寸时，需要设置父元素显示溢出的子元素的方式 通过 overflow 属性来设置   参数表    参数 释义     visible 默认值，内容不会被修剪\n会呈现在元素框之外   hidden 内容会被修剪\n其余内容是不可见的\n此属性还有清除浮动、清除 margin-top 塌陷的功能   scroll 内容会被修剪\n浏览器会显示滚动条，以便查看其余的内容   auto 如果内容被修剪，浏览器会显示滚动条以便查看其余的内容   inherit 规定应该从父元素继承 overflow 属性的值    举例 1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;box\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9  .box{ width: 200px; height: 200px; /*overflow: visible;*/ /*overflow: hidden;*/ overflow: scroll; /*overflow: auto;*/ /*overflow: inherit;*/ }   \u0026gt;\u0026gt;\u0026gt;\n","description":"元素溢出","id":167,"section":"web","tags":null,"title":"07. overflow","uri":"https://yorkfish.github.io/review/web/css/07-overflow/"},{"content":"1. 简介  hr 标签即为水平分割线标签 \u0026lt;hr\u0026gt; 不需要闭合  2. 属性说明    属性 释义     width 设置长度，可以用百分制或像素表示   align 设置对其方式，可选左、中（默认）、右   size 设置线的粗细    ps  width 属性设置为小于 100% 时，align 属性才有效果 HTML5 中不再支持这些属性  3. 示例与效果 示例 1 2 3  \u0026lt;hr\u0026gt; \u0026lt;hr width=\u0026#34;100px\u0026#34;\u0026gt; \u0026lt;hr width=\u0026#34;50%\u0026#34;\u0026gt;   效果 \r","description":"水平分割线","id":168,"section":"web","tags":null,"title":"07. Horizontal Split Line","uri":"https://yorkfish.github.io/review/web/html/07-horizontal-split-line/"},{"content":" empty() size() clear() begin(), end() ++, \u0026ndash;   insert() find() erase() count() [] 时间复杂度 O(logn), multimap 不支持此操作 lower_bound(), upper_bound()   1. 简介  map 容器是一个键值对 key-value 的映射，其内部实现是一棵以 key 为关键码的红黑树 Map 的 key 和 value 可以是任意类型，其中 key 必须重载 \u0026lt;  2. 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; int main() { map\u0026lt;int, int\u0026gt; a; a[1] = 2; a[666] = 3; cout \u0026lt;\u0026lt; a[666] \u0026lt;\u0026lt; endl; map\u0026lt;string, int\u0026gt; b; b[\u0026#34;york\u0026#34;] = 100; cout \u0026lt;\u0026lt; b[\u0026#34;york\u0026#34;] \u0026lt;\u0026lt; endl; map\u0026lt;string, vector\u0026lt;int\u0026gt;\u0026gt; c; c[\u0026#34;fish\u0026#34;] = vector\u0026lt;int\u0026gt;(); cout \u0026lt;\u0026lt; c[\u0026#34;fish\u0026#34;].size() \u0026lt;\u0026lt; endl; c[\u0026#34;fish\u0026#34;] = vector\u0026lt;int\u0026gt;({1, 2, 3, 4, 5}); cout \u0026lt;\u0026lt; c[\u0026#34;fish\u0026#34;][2] \u0026lt;\u0026lt; endl; // 一般不用 multimap  return 0; }   \u0026gt;\u0026gt;\u0026gt;\n3\r100\r0\r3\r3. insert \u0026amp; find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt; using namespace std; int main() { map\u0026lt;int, int\u0026gt; a; a.insert(pair\u0026lt;int, int\u0026gt;(1, 99)); a.insert(pair\u0026lt;int, int\u0026gt;(2, 98)); map\u0026lt;int, int\u0026gt;::iterator iter = a.find(1); cout \u0026lt;\u0026lt; iter-\u0026gt;first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; iter-\u0026gt;second \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1 99\r4. []  [] 操作符是 map 最吸引人的地方 h[key] 返回 key 映射的 value 的引用，时间复杂度为 O(logn) 可以很方便地通过 h[key] 来得到 key 对应的 value，还可以对 h[key] 进行赋值操作，改变 key 对应的 value  5. 遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt; using namespace std; int main() { map\u0026lt;int, int\u0026gt; a; a[2] = 10; a[3] = 15; a[1] = 5; for (auto it = a.begin(); it != a.end(); it ++ ) cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;===\u0026#34; \u0026lt;\u0026lt; endl; for (auto p : a) cout \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1 5\r2 10\r3 15\r===\r1 5\r2 10\r3 15\r","description":"关联式容器","id":169,"section":"cpp","tags":null,"title":"07. map","uri":"https://yorkfish.github.io/review/cpp/stl/07-map/"},{"content":"1. 字符数组与字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char s1[] = {\u0026#39;y\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;k\u0026#39;}; // 字符数组  char s2[] = {\u0026#39;y\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;\\0\u0026#39;}; // 既是字符数组，也是字符串  char s3[5] = {\u0026#39;y\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;k\u0026#39;}; // 既是字符数组，也是字符串  char s4[] = \u0026#34;york\u0026#34;; // 既是字符数组，也是字符串  // char s5[4] = \u0026#34;york\u0026#34;; // error: initializer-string for array of chars is too long  cout \u0026lt;\u0026lt; sizeof s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof s2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof s3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof s4 \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n4\r5\r5\r5\r2. 读入与输出  字符串读入时，读到“空格”、“回车”、“结束符”就停止读取 gets() 不进行数组范围检查，若写得不对，编译也许可以通过，但运行时会数组越界或内存泄露 C++11 以后，官方语法去除了 gets()  方式一 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt; int main() { char s[100]; fgets(s, 100, stdin); // 字符串首地址，最多读取数，输入方式  printf(\u0026#34;%s\\n\u0026#34;, s); printf(\u0026#34;%d\\n\u0026#34;, strlen(s)); return 0; }     输入\n york fish\n   输出\n york fish\n10\n   ps  fgets() 会把最后确认的回车也读进去  方式二 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; int main() { char s[100]; cin.getline(s, 100); // 字符串首地址，最多读取数  cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; strlen(s) \u0026lt;\u0026lt; endl; return 0; }     输入\n york fish\n   输出\n york fish\n9\n   3. 字典序 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; strcmp(\u0026#34;a\u0026#34;, \u0026#34;abc\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; strcmp(\u0026#34;abb\u0026#34;, \u0026#34;abc\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; strcmp(\u0026#34;abc\u0026#34;, \u0026#34;abc\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; strcmp(\u0026#34;abd\u0026#34;, \u0026#34;abc\u0026#34;) \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n-1\r-1\r0\r1\r更多字符串方法见 STL 部分的 string ","description":"字符串","id":170,"section":"cpp","tags":null,"title":"07. string","uri":"https://yorkfish.github.io/review/cpp/07-string/"},{"content":" C# 称“处理选项”(RegexOptions) Js 称“模式修正符”(RegexOptions) Python3 中表现为 flag 一般允许混搭   C#  IgnoreCase: 忽略大小写 RightToLeft: 从右向左查找（默认是从左向右） Multiline: 多行模式 Singleline: 扩容 .，使其可以匹配任意字符 IgnorePatternWhiteSpace: 忽略表达式中非转义的空白（方便注释） ExplicitCapture: 仅捕获显示命名组  Javascript  g: 全局匹配 i: 忽略大小写 m: 多行模式  Python3    Flag 释义     re.ASCII\nre.A 使 \\w, \\W \\b, \\B, \\d, \\D, \\s, \\S 执行仅 ASCII 匹配   re.DEBUG 显示有关已编译表达式的调试信息。   re.IGNORECASE\nre.I 忽略大小写   re.LOCAL\nre.L 只能与字节模式一起使用，官方不推荐使用   re.MULTILINE\nre.M 多行模式   re.DOTALL\nre.S 扩容 .，使其可以匹配任意字符   re.VERBOSE\nre.X 忽略表达式中非转义的空白（方便注释）    ","description":"模式修正符","id":171,"section":"regex","tags":null,"title":"07. pattern modifier","uri":"https://yorkfish.github.io/review/regex/07-pattern-modifier/"},{"content":"例一 未加锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import threading def test_count(): global count for _ in range(10_0000): count += 1 if __name__ == \u0026#34;__main__\u0026#34;: count = 0 threads = [] for _ in range(10): t = threading.Thread(target=test_count) t.start() threads.append(t) for t in threads: t.join() print(count) # 应该是 10 * 100000 = 100_0000   运行结果  结果小于 100_0000  例二 加锁 - 方式一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import threading def test_count(): global count, lock for _ in range(10_0000): lock.acquire() count += 1 lock.release() if __name__ == \u0026#34;__main__\u0026#34;: count = 0 threads = [] lock = threading.Lock() for _ in range(10): t = threading.Thread(target=test_count) t.start() threads.append(t) for t in threads: t.join() print(count)   运行结果  结果正确 每次运算都需要加锁、解锁，效率比较低  例三 加锁 - 方式二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import threading def test_count(): global count, lock lock.acquire() for _ in range(10_0000): count += 1 lock.release() if __name__ == \u0026#34;__main__\u0026#34;: count = 0 threads = [] lock = threading.Lock() for _ in range(10): t = threading.Thread(target=test_count) t.start() threads.append(t) for t in threads: t.join() print(count)   运行结果  结果正确 效率比较例二高 这种方法在逻辑上与依次调用函数没什么区别  例四 死锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  import threading import time lock1 = threading.Lock() lock2 = threading.Lock() def thread_job1(): print(\u0026#34;job1 starting\u0026#34;) lock1.acquire() print(\u0026#34;job1 asking for lock1 ...\u0026#34;) time.sleep(2) print(\u0026#34;job1 waiting for lock2 ...\u0026#34;) lock2.acquire() print(\u0026#34;job1 asking for lock2 ...\u0026#34;) lock2.release() print(\u0026#34;job1 release lock2\u0026#34;) lock1.release() print(\u0026#34;job1 release lock1\u0026#34;) print(\u0026#34;job1 done\u0026#34;) def thread_job2(): print(\u0026#34;job2 starting\u0026#34;) lock2.acquire() print(\u0026#34;job2 asking for lock2 ...\u0026#34;) time.sleep(4) print(\u0026#34;job2 waiting for lock1 ...\u0026#34;) lock1.acquire() print(\u0026#34;job2 asking for lock1 ...\u0026#34;) lock1.release() print(\u0026#34;job2 release lock1\u0026#34;) lock2.release() print(\u0026#34;job2 release lock2\u0026#34;) print(\u0026#34;job2 done\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;main thread start\u0026#34;) t1 = threading.Thread(target=thread_job1) t2 = threading.Thread(target=thread_job2) t1.start() t2.start() t1.join() t2.join() print(\u0026#34;main thread stop\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\nmain thread start\rjob1 starting\rjob1 asking for lock1 ...\rjob2 starting\rjob2 asking for lock2 ...\rjob1 waiting for lock2 ...\rjob2 waiting for lock1 ...\r# 陷入死锁\r说明  线程启动 第 2s 时，job1 申请 lock2，此时 job2 占用了 lock2，故申请失败 第 4s 时，job2 申请 lock1，此时 job1 占用了 lock1，故申请失败 job1 想要 lock2 就必须先交出 lock1，而它却想先得到 lock2 再交出 lock1 job2 同理 如此，陷入了“死锁”  例五 死锁的一种解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  import threading import time lock1 = threading.Lock() lock2 = threading.Lock() def thread_job1(): print(\u0026#34;job1 starting\u0026#34;) lock1.acquire() print(\u0026#34;job1 asking for lock1 ...\u0026#34;) time.sleep(2) print(\u0026#34;job1 waiting for lock2 ...\u0026#34;) rst = lock2.acquire(timeout=3) # 3s 内没申请到就不继续申请了 if rst: print(\u0026#34;job1 gets lock2\u0026#34;) lock2.release() print(\u0026#34;job1 release lock2\u0026#34;) else: print(\u0026#34;job1 can\u0026#39;t get lock2\u0026#34;) lock1.release() print(\u0026#34;job1 release lock1\u0026#34;) print(\u0026#34;job1 done\u0026#34;) def thread_job2(): print(\u0026#34;job2 starting\u0026#34;) lock2.acquire() print(\u0026#34;job2 asking for lock2 ...\u0026#34;) time.sleep(4) print(\u0026#34;job2 waiting for lock1 ...\u0026#34;) lock1.acquire() print(\u0026#34;job2 asking for lock1 ...\u0026#34;) lock1.release() print(\u0026#34;job2 release lock1\u0026#34;) lock2.release() print(\u0026#34;job2 release lock2\u0026#34;) print(\u0026#34;job2 done\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;main thread start\u0026#34;) t1 = threading.Thread(target=thread_job1) t2 = threading.Thread(target=thread_job2) t1.start() t2.start() t1.join() t2.join() print(\u0026#34;main thread stop\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\nmain thread start\rjob1 starting\rjob1 asking for lock1 ...\rjob2 starting\rjob2 asking for lock2 ...\rjob1 waiting for lock2 ...\rjob2 waiting for lock1 ...\rjob1 can't get lock2\rjob1 release lock1\rjob2 asking for lock1 ...\rjob1 done\rjob2 release lock1\rjob2 release lock2\rjob2 done\rmain thread stop\r","description":"锁","id":172,"section":"python","tags":null,"title":"07. lock","uri":"https://yorkfish.github.io/review/python/threading/07-lock/"},{"content":"例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import multiprocessing def consumer(input_q): print(\u0026#34;Into consumer\u0026#34;) while True: item = input_q.get() # 处理项 print(\u0026#34;pull\u0026#34;, item, \u0026#34;out of queue\u0026#34;) # 此处替换为有用的工作 input_q.task_done() # 发出信号通知任务完成 print(\u0026#34;Out of consumer\u0026#34;) # 此句未执行 def producer(sequence, output_q): print(\u0026#34;Into procuder\u0026#34;) for item in sequence: output_q.put(item) print(\u0026#34;put\u0026#34;, item, \u0026#34;into queue\u0026#34;) print(\u0026#34;Out of procuder\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: q = multiprocessing.JoinableQueue() # 运行消费者进程 cons_p = multiprocessing.Process(target=consumer, args=(q,)) cons_p.daemon = True cons_p.start() # 实践中，可能由生成器或别的方式生产输出 sequence = [1, 2, 3, 4] # 要发送给消费者的项序列 producer(sequence, q) q.join() # 等待所有项被处理   \u0026gt;\u0026gt;\u0026gt;\nInto procuder\rput 1 into queue\rput 2 into queue\rput 3 into queue\rput 4 into queue\rOut of procuder\rInto consumer\rpull 1 out of queue\rpull 2 out of queue\rpull 3 out of queue\rpull 4 out of queue\r说明  q.join() 收集到四个 task_done() 信号后，就转入主进程，紧接着程序就结束了 导致 print(\u0026quot;Out of consumer\u0026quot;) 没有被执行  例二 设置哨兵（一） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import multiprocessing # 设置哨兵问题 def consumer(input_q): print(\u0026#34;Into consumer\u0026#34;) while True: item = input_q.get() if item is None: break print(\u0026#34;pull\u0026#34;, item, \u0026#34;out of queue\u0026#34;) print(\u0026#34;Out of consumer\u0026#34;) # 此句执行完成，再转入主进程 def producer(sequence, output_q): print(\u0026#34;Into procuder\u0026#34;) for item in sequence: output_q.put(item) print(\u0026#34;put\u0026#34;, item, \u0026#34;into queue\u0026#34;) print(\u0026#34;Out of procuder\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: q = multiprocessing.Queue() cons_p = multiprocessing.Process(target=consumer, args=(q,)) cons_p.start() sequence = [1, 2, 3, 4] producer(sequence, q) q.put(None) # 主要是这句 cons_p.join()   \u0026gt;\u0026gt;\u0026gt;\nInto consumer\rpull 1 out of queue\rpull 2 out of queue\rpull 3 out of queue\rpull 4 out of queue\rOut of consumer\rInto procuder\rput 1 into queue\rput 2 into queue\rput 3 into queue\rput 4 into queue\rOut of procuder\r例三 设置哨兵（二） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import multiprocessing def consumer(input_q): print(\u0026#34;Into consumer\u0026#34;) while True: item = input_q.get() if item is None: break print(\u0026#34;pull\u0026#34;, item, \u0026#34;out of queue\u0026#34;) print(\u0026#34;Out of consumer\u0026#34;) def producer(sequence, output_q): for item in sequence: print(\u0026#34;Into procuder\u0026#34;) output_q.put(item) print(\u0026#34;Out of procuder\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: q = multiprocessing.Queue() cons_p1 = multiprocessing.Process(target=consumer, args=(q,)) cons_p1.start() cons_p2 = multiprocessing.Process(target=consumer, args=(q,)) cons_p2.start() sequence = [1, 2, 3, 4] producer(sequence, q) q.put(None) # 有几个进程，加几个 None q.put(None) # 加别的也行，一般是加 None cons_p1.join() cons_p2.join()   \u0026gt;\u0026gt;\u0026gt;\nInto procuder\rOut of procuder\rInto procuder\rOut of procuder\rInto procuder\rOut of procuder\rInto procuder\rOut of procuder\rInto consumer\rpull 1 out of queue\rpull 2 out of queue\rpull 3 out of queue\rpull 4 out of queue\rOut of consumer\rInto consumer\rOut of consumer\r","description":"JoinableQueue \u0026 Queue \u0026 哨兵","id":173,"section":"python","tags":null,"title":"07. Queue","uri":"https://yorkfish.github.io/review/python/multiprocessing/07-queue/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, width=20, height=2) l.pack() window.mainloop()   2. 添加一个 radiobutton 1 2 3 4 5 6 7 8 9 10  string = tk.StringVar() def print_selection(): l.config(text=\u0026#34;you have selected \u0026#34; + string.get()) r = tk.Radiobutton(window, text=\u0026#34;Option A\u0026#34;, variable=string, value=\u0026#39;A\u0026#39;, font=(\u0026#34;Consolas\u0026#34;, 16), command=print_selection) r.pack()   ps  variable=string, value='A' 若鼠标选中了某个选项  把 value 的值 A 存入变量 string 中 赋值给 variable    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, width=20, height=2) l.pack() string = tk.StringVar() def print_selection(): l.config(text=\u0026#34;you have selected \u0026#34; + string.get()) r1 = tk.Radiobutton(window, text=\u0026#34;Option A\u0026#34;, variable=string, value=\u0026#39;A\u0026#39;, command=print_selection) r2 = tk.Radiobutton(window, text=\u0026#34;Option B\u0026#34;, variable=string, value=\u0026#39;B\u0026#39;, command=print_selection) r3 = tk.Radiobutton(window, text=\u0026#34;Option C\u0026#34;, variable=string, value=\u0026#39;C\u0026#39;, command=print_selection) r1.pack() r2.pack() r3.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"选择按钮-单选","id":174,"section":"python","tags":null,"title":"07. Radiobutton","uri":"https://yorkfish.github.io/review/python/tkinter/07-radiobutton/"},{"content":"1. 问题   命令行敲 python，出现如下错误\n...\rUnicodeDecodeError: 'gbk' codec can't decode byte 0x8f in position 500: illegal multibyte sequence\r...\r  2. 解决 方法一  来到目录：C:\\Users\\{username} 比如我的：C:\\Users\\York 打开 .python_history 删去含中文的记录 缺点：以后命令行用 Python 时写了中文，重启仍有问题  方法二  Anaconda 版本 来到 D:\\anaconda3\\Lib\\site-packages\\pyreadline\\lineeditor 找到 history.py 根据异常的提示行数，找到 for line in open(filename, 'r'): 加上 encoding，如 for line in open(filename, 'r', encoding=\u0026quot;utf-8\u0026quot;):  ","description":"","id":175,"section":"python","tags":null,"title":"07. encode","uri":"https://yorkfish.github.io/review/python/operation/07-gbk/"},{"content":"1. 说明  与另的语言不同，Python 的函数可以很多参数 参数多了，可读性会降低 Python 3.8 之后的两个符号  /: 此符号之前的参数必须是位置参数 *: 此符号之后的参数必须是关键字参数   组合顺序：必选参数、默认参数、可变参数、命名关键字参数和关键字参数  2. 举例 例一 1 2 3 4 5 6 7 8 9 10 11 12 13  def test(a, b=2, *, c): \u0026#34;\u0026#34;\u0026#34; a: 位置参数 b: 默认参数/缺省参数 c: 命名关键字参数/强制关键字参数 \u0026#34;\u0026#34;\u0026#34; print(a, b, c) test(1, c=3) test(a=1, c=3) test(1, 22, c=3) test(a=1, b=22, c=3)   例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def test(a, b, /, c, d, *, e, f): \u0026#34;\u0026#34;\u0026#34; a, b: 强制位置参数 c, d: 都作位置参数或关键字参数，或 c 作位置参数、d 作关键字参数 e, f: 强制关键字参数 \u0026#34;\u0026#34;\u0026#34; print(a, b) print(c, d) print(e, f) test(1, 2, 3, 4, e=5, f=6) test(1, 2, 3, d=4, e=5, f=6) test(1, 2, c=3, d=4, e=5, f=6)   例三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def test(a, b, c, /, d, *args, e, f, **kwargs): \u0026#34;\u0026#34;\u0026#34; a, b, c: 强制位置参数 d: 当位置参数或关键字参数用 *args: 可变参数/多值参数，存入元组参数（后面跟强制关键字参数） e, f: 强制关键字参数 **kwargs: 多值参数，存入字典参数 \u0026#34;\u0026#34;\u0026#34; print(a, b, c, d) print(args) print(e, f) print(kwargs) test(1, 2, 3, 4, 55, 66, e=7, f=8, x=97, y=98, z=99)   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 4\r(55, 66)\r7 8\r{'x': 97, 'y': 98, 'z': 99}\r3. 两个坑 坑一 1 2 3 4 5 6 7 8 9 10  def test(*args, **kwargs): print(args) print(kwargs) nums = (1, 2, 3) d = {\u0026#39;a\u0026#39;: 97, \u0026#39;b\u0026#39;: 98, \u0026#39;c\u0026#39;: 99} test(nums, d) print(\u0026#34;=\u0026#34; * 30) test(*nums, **d)   \u0026gt;\u0026gt;\u0026gt;\n((1, 2, 3), {'a': 97, 'b': 98, 'c': 99})\r{}\r==============================\r(1, 2, 3)\r{'a': 97, 'b': 98, 'c': 99}\r坑二 错误的写法 1 2 3  def test(lst=[]): lst.append(\u0026#34;python\u0026#34;) return lst   操作一  这样没什么问题  1 2  print(test([\u0026#34;yorkfish\u0026#34;])) print(test([\u0026#34;jesscia\u0026#34;]))   \u0026gt;\u0026gt;\u0026gt;\n['yorkfish', 'python']\r['jesscia', 'python']\r操作二  这样有问题  1 2  print(test()) print(test())   \u0026gt;\u0026gt;\u0026gt;\n['python']\r['python', 'python']\r第一次调用 test，创建了 lst 却没有销毁\n第二次调用 test，函数认为接收了 ['python']，默认参数就失效了\r 正确的做法 1 2 3 4 5 6 7 8 9  def test(lst=None): if lst is None: lst = [] lst.append(\u0026#34;python\u0026#34;) return lst print(test()) print(test())   \u0026gt;\u0026gt;\u0026gt;\n['python']\r['python']\r函数的默认参数必须指向不可变对象\r ","description":"","id":176,"section":"python","tags":null,"title":"07. function arguments","uri":"https://yorkfish.github.io/review/python/basics/07-function-arguments/"},{"content":"1. 说明  函数名：map 顾名思意：映射  2. 举例 例一 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; b = [_ for _ in a] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; def mul2(num): ... return num * 2 ... \u0026gt;\u0026gt;\u0026gt; map(mul2, a) \u0026lt;map object at 0x000001DC17797430\u0026gt; \u0026gt;\u0026gt;\u0026gt; list(map(mul2, a)) [2, 4, 6, 8, 10] \u0026gt;\u0026gt;\u0026gt;   例三 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; list(map(lambda x: x*x, a)) [1, 4, 9, 16, 25] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":177,"section":"python","tags":null,"title":"07. map()","uri":"https://yorkfish.github.io/review/python/bif/07-map/"},{"content":"1. 导入 1  import numpy as np   2. 操作 创建 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12) \u0026gt;\u0026gt;\u0026gt; b = a.reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; print(a) [ 0 1 2 3 4 5 6 7 8 9 10 11] \u0026gt;\u0026gt;\u0026gt; print(b) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; id(a) 1809452646272 \u0026gt;\u0026gt;\u0026gt; id(b) 1809452699696 \u0026gt;\u0026gt;\u0026gt;   “变形” 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; id(a) 1809452646272 \u0026gt;\u0026gt;\u0026gt; a.resize((3, 4)) \u0026gt;\u0026gt;\u0026gt; id(a) 1809452646272 \u0026gt;\u0026gt;\u0026gt;   转置 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(a.T) [[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] \u0026gt;\u0026gt;\u0026gt;   展开 ravel()  返回的是原数组的一个视图(view)，会对原数组产生影响  1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(a.ravel()) [ 0 1 2 3 4 5 6 7 8 9 10 11] \u0026gt;\u0026gt;\u0026gt;   flatten()  返回的是一个新数组  1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(a.flatten()) [ 0 1 2 3 4 5 6 7 8 9 10 11] \u0026gt;\u0026gt;\u0026gt;   flat 1 2 3  \u0026gt;\u0026gt;\u0026gt; [_ for _ in a.flat] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":178,"section":"python","tags":null,"title":"07. ndarray operation","uri":"https://yorkfish.github.io/review/python/numpy/07-ndarray-operation/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; class Hero(object): ... game_name = \u0026#34;LOL\u0026#34; # 类变量 ... def __init__(self, name): ... self.name = name # 实例变量 ... def flash(self): ... count = 0 # 局部变量 ... print(f\u0026#34;{self.name} used flash\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; lijing = Hero(\u0026#34;Lijing\u0026#34;) \u0026gt;\u0026gt;\u0026gt; lijing.flash() Lijing used flash \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":179,"section":"python","tags":null,"title":"07. 局部变量","uri":"https://yorkfish.github.io/review/python/class/07-local-var/"},{"content":"1. 关键字  auto  2. 说明  “自动变量”是函数中的局部变量，和 C++ 中的 auto 是两码事 关键字可以省略，若省略，则隐含确定为“自动存储类别” 属于动态存储方式，数据存储在动态存储区中 如果不专门声明为 static 存储类别，都是动态地分配存储空间 调用该函数时，系统会给这些变量分配存储空间 调用结束时会自动释放这些存储空间  3. 举例  函数中的形参 函数中定义的变量 复合语句中定义的变量  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;stdio.h\u0026gt; // 执行完 test 函数，自动释放 num, start, stop 所占的存储单元 int test(int num) { auto int start; auto int stop = 3; for (start = 0; start \u0026lt; stop; start++) { num++; } return num; } int main() { int res = test(0); printf(\u0026#34;%d\\n\u0026#34;, res); // 3  return 0; }   ","description":"","id":180,"section":"c","tags":null,"title":"07. auto","uri":"https://yorkfish.github.io/review/c/function/07-auto/"},{"content":"1. 简介  fgets: 从指定文件读取一个字符串 fputs: 向指定文件写进一个字符串  2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); fputs(\u0026#34;China\u0026#34;, fp); // 把字符串 \u0026#34;China\u0026#34; 输出到 fp 指向的文件  fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); char str[6]; // str[5] 放 \u0026#39;\\0\u0026#39;  fgets(str, 6, fp); printf(\u0026#34;%s\\n\u0026#34;, str); fclose(fp); return 0; }   3. 说明   fputs 函数中的第一个参数可以是\n 字符串常量 字符数组 字符型指针    fgets 操作后的字符串，其末尾的 '\\0' 不输出\n 若输出成功，函数值为 0 若输出失败，函数值为 EOF    与 gets 和 puts 类似1\n gets: 输入字符串 puts: 输出字符串    fgets 和 fputs 可以指定文件\n   basic 12. gets() \u0026amp; puts() \u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":181,"section":"c","tags":null,"title":"07. fgets() \u0026 fputs()","uri":"https://yorkfish.github.io/review/c/file/07-fgets-and-fputs/"},{"content":"1. 指针数组的概念 一般定义形式  类型名 * 数组名[数组长度]; 如：int * p[4];  ps  [] 比 * 优先级高 字符串比较应当用 strcmp 函数  2. 指向指针的指针 举例 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt; int main() { char* name[] = {\u0026#34;york\u0026#34;, \u0026#34;fish\u0026#34;}; char** p = name + 1; printf(\u0026#34;%p\\n\u0026#34;, name[1]); // 00404049，每次编译分配的地址不一定相同  printf(\u0026#34;%08x\\n\u0026#34;, (int)*p); // 00404049  printf(\u0026#34;%s\\n\u0026#34;, *p); // fish  return 0; }   ps  char** p; * 运算符的结合默认是从右到左，因此 **p 相当于 *(*p) 指针数组的元素只能存放地址  3. 指针数组作主函数的形参  实际上，主函数是可以有参数的，如：int main(int argc, char* argv[]) 命令行输入的形式：命令名 参数1 参数2 ... 参数n  举例 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { for (int i = 1; i \u0026lt; argc; i++) { printf(\u0026#34;%s\\n\u0026#34;, argv[i]); } return 0; }     编译命令：gcc main.c -o main\n  Input: main york fish\n  Output\nyork\rfish\r  ps  argc 是自动统计的 argv 把执行程序名也算在内  ","description":"","id":182,"section":"c","tags":null,"title":"07. 指针数组和指针的指针","uri":"https://yorkfish.github.io/review/c/pointer/07-pointer-array-and-pointer-to-pointer/"},{"content":"不推荐下文例子中的写法 1. 右结合性  即“自右向左”结合  例一  如 -i++ -\u0026gt; -(i++)  1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { int i = 10; printf(\u0026#34;%d\\n\u0026#34;, -i++); // -10  printf(\u0026#34;%d\\n\u0026#34;, i); // 11  return 0; }    “负号”与 ++ 同级，默认右结合  例二 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; void func(int a, int b) { printf(\u0026#34;%d, %d\\n\u0026#34;, a, b); } int main() { int i = 10; func(i, i++); // 11, 10  return 0; }    函数的参数，从右向左“生成”  2. 左结合性  即“自左向右”结合  例三  如 i+++j -\u0026gt; (i++) + j  1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { int i = 10; int j = 20; printf(\u0026#34;%d\\n\u0026#34;, i+++j); // 30  printf(\u0026#34;%d\\n\u0026#34;, i); // 11  printf(\u0026#34;%d\\n\u0026#34;, j); // 20  return 0; }    组成运算符时，尽可能多地左结合 标识符、关键字也遵循这个原则  ","description":"","id":183,"section":"c","tags":null,"title":"07. 结合方向","uri":"https://yorkfish.github.io/review/c/basics/07-combination-direction/"},{"content":"1. 简介   链表可以根据需要开辟内存单元\n  链表有一个“头指针”变量\n 它存放一个地址 该地址指向一个元素    链表中每一个元素称为“结点”\n  每个结点都应包括两个部分\n 用户需要用的实际数据 下一个结点的地址    head 指向第一个元素\n  最后一个元素不再指向其他元素，它称为“表尾”，它的地址部分放一个 NULL\n  NULL 表示“空地址”，链表到此结束\n  一个指针类型的成员可以指向其他类型的结构体数据，也可以指向自己所在的结构体类型数据\n  只定义结构体，不分配存储空间，只有定义了结构体变量才分配内存单元\n  静态链表\n 所有结点都是在程序中定义的 不是临时开辟的 不能用完后释放    2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;stdio.h\u0026gt; typedef struct node { int val; struct node* next; } Node, *pNode; void traverse(pNode head) { if (head == NULL) return; while (head) { printf(\u0026#34;%d \u0026#34;, head-\u0026gt;val); head = head-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } int main() { Node n1, n2, n3; n1.val = 1; n2.val = 2; n3.val = 3; n1.next = \u0026amp;n2; n2.next = \u0026amp;n3; n3.next = NULL; traverse(\u0026amp;n1); return 0; }   ","description":"","id":184,"section":"c","tags":null,"title":"07. 链表","uri":"https://yorkfish.github.io/review/c/struct-union-enum/07-linked-list/"},{"content":" 用法：借助 HTML 的标签 \u0026lt;u\u0026gt; 说明  从效果上看，\u0026lt;ins\u0026gt; 也满足“下划线”的需求，不过它更倾向于“为修改而标记” 因为是 HTML 标签，所以可以加样式    示例与效果   示例\n\u0026lt;u\u0026gt;u 标签下划线\u0026lt;/u\u0026gt;\r\u0026lt;ins\u0026gt;ins 标签下划线\u0026lt;/ins\u0026gt;\r  效果\nu 标签下划线 ins 标签下划线\n  加特效   使用 \u0026lt;span\u0026gt; 标签\n\u0026lt;span style=\u0026quot;border-bottom:2px dashed blue\u0026quot;\u0026gt;蓝色虚线下划线\u0026lt;/span\u0026gt;\n  效果\n蓝色虚线下划线\n  ","description":"","id":185,"section":"markdown","tags":null,"title":"08. 下划线","uri":"https://yorkfish.github.io/review/markdown/08-underline/"},{"content":"\\documentclass[UTF8]{ctexart}\r\\begin{document}\r% 1. centering 居中，l 左对齐，r 右对齐\r\\begin{tabular}{c c c}\r单元格1 \u0026amp; 单元格2 \u0026amp; 单元格3 \\\\\r单元格4 \u0026amp; 单元格5 \u0026amp; 单元格6 \\\\\r单元格7 \u0026amp; 单元格8 \u0026amp; 单元格9\r\\end{tabular}\r% 2. 添加竖直方向的边框\r\\begin{tabular}{|c|c|c|}\r单元格1 \u0026amp; 单元格2 \u0026amp; 单元格3 \\\\\r单元格4 \u0026amp; 单元格5 \u0026amp; 单元格6 \\\\\r单元格7 \u0026amp; 单元格8 \u0026amp; 单元格9\r\\end{tabular}\r% 3. 添加水平方向上的边框 添加两次就是双横线\r\\begin{tabular}{|c|c|c|}\r\\hline\r单元格1 \u0026amp; 单元格2 \u0026amp; 单元格3 \\\\\r\\hline\\hline\r单元格4 \u0026amp; 单元格5 \u0026amp; 单元格6 \\\\\r\\hline\r单元格7 \u0026amp; 单元格8 \u0026amp; 单元格9\r\\hline\r\\end{tabular}\r% 4. 单独指定每列宽度\r\\begin{tabular}{|p{2cm}|c|c|}\r\\hline\r单元格1 \u0026amp; 单元格2 \u0026amp; 单元格3 \\\\\r\\hline\\hline\r单元格4 \u0026amp; 单元格5 \u0026amp; 单元格6 \\\\\r\\hline\r单元格7 \u0026amp; 单元格8 \u0026amp; 单元格9\r\\hline\r\\end{tabular}\r% 5. 给表格添加标题\r\\begin{table}\r\\center\r\\begin{tabular}{|p{2cm}|c|c|}\r\\hline\r单元格1 \u0026amp; 单元格2 \u0026amp; 单元格3 \\\\\r\\hline\\hline\r单元格4 \u0026amp; 单元格5 \u0026amp; 单元格6 \\\\\r\\hline\r单元格7 \u0026amp; 单元格8 \u0026amp; 单元格9\r\\hline\r\\end{tabular}\r\\caption{指定表格的标题}\r\\end{table}\r\\end{docucment}\r","description":"表格","id":186,"section":"latex","tags":null,"title":"08. Table","uri":"https://yorkfish.github.io/review/latex/08-table/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-if\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; div{ width: 200px; height: 200px; } .box1{ background: red; } .box2{ background: green; } .box3{ background: blue; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34; v-if=\u0026#34;1\u0026lt;0\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34; v-else-if=\u0026#34;1==0\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34; v-else\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;!-- 穿插一些 v-show 若判断一次即确定显示或隐藏，推荐使用 v-if 若频繁地显示与隐藏，推荐使用 v-show --\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34; v-show=\u0026#34;true\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34; v-show=\u0026#34;false\u0026#34;\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   说明  显示和隐藏  v-if v-else-if v-else   使用时，中间不能穿插别的元素  ","description":"","id":187,"section":"web","tags":null,"title":"08. v-if","uri":"https://yorkfish.github.io/review/web/vue/08-v-if/"},{"content":"for-loop 1 2 3  for (var i = 0; i \u0026lt; len; i++) { ... }   while-loop 1 2 3 4 5  var i = 0; while (i \u0026lt; 8) { ... i++; }   for-in  for-in 语句是严格的迭代语句，用于枚举对象的属性  1 2 3 4  var lst = [1, 2, 3, 4, 5]; for (i in lst) { document.write(lst[i] + \u0026#39; \u0026#39;); }   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 4 5\r","description":"循环","id":188,"section":"web","tags":null,"title":"08. Loop","uri":"https://yorkfish.github.io/review/web/javascript/08-loop/"},{"content":"内间距 说明  内间距也称“内补白”或“内补丁”  参数表    参数 释义     padding 检索或设置对象四边的内部边距，如 padding: 10px;, padding: 5px 10px;   padding-top 检索或设置对象顶边的内部边距   padding-right 检索或设置对象右边的内部边距   padding-bottom 检索或设置对象下边的内部边距   padding-left 检索或设置对象左边的内部边距    举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;box3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box4\u0026#34;\u0026gt;box4\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  *{ width: 100px; height: 100px; } .box1{ background-color: #edd094; } .box2{ background-color: #a7ab86; padding-top: 10px; padding-bottom: 10px; padding-left: 10px; padding-right: 10px; } .box3{ background-color: #b35e59; padding: 10px; } .box4{ background-color: #8a7e94; padding: 10px 15px; }   \u0026gt;\u0026gt;\u0026gt;\n补充  padding: 10px; 四边都 padding 10px padding: 10px 20px; 上下 padding 10px，左右 padding 20px  外间距 说明  外间距也称“外补白”或“外补丁”  参数表    参数 释义     margin 检索或设置对象四边的外延边距，如 margin: 10px;, margin: 5px auto;   margin-top 检索或设置对象顶边的外延边距   margin-right 检索或设置对象右边的外延边距   margin-bottom 检索或设置对象下边的外延边距   margin-left 检索或设置对象左边的外延边距    举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;box3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box4\u0026#34;\u0026gt;box4\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  *{ width: 100px; height: 100px; } .box1{ background-color: #edd094; } .box2{ background-color: #a7ab86; margin-top: -10px; margin-bottom: 10px; margin-left: 10px; margin-right: 10px; } .box3{ background-color: #b35e59; margin: 10px; } .box4{ background-color: #8a7e94; margin: 10px 20px; } .box5{ background-color: #f1c4be; margin: 10px auto; }   \u0026gt;\u0026gt;\u0026gt;\n补充  设置元素水平居中：margin: x auto; margin 取负值可以让元素位移及边框合并  ","description":"内外间距","id":189,"section":"web","tags":null,"title":"08. padding","uri":"https://yorkfish.github.io/review/web/css/08-padding/"},{"content":"1. 介绍  没有默认样式（语义） 独占一行 一般用来划定一块区域，配合 CSS 在布局中使用  2. 示例与效果 示例1 \u0026lt;div\u0026gt;这是一个div\u0026lt;/div\u0026gt;\n效果1 这是一个div\r示例2 \u0026lt;div style=\u0026quot;width:200px; height:100px; border:1px solid black;\u0026quot;\u0026gt;在div中加些css样式\u0026lt;/div\u0026gt;\n效果2 在div中加些css样式\r","description":"区块标签","id":190,"section":"web","tags":null,"title":"08. Block Label","uri":"https://yorkfish.github.io/review/web/html/08-block-label/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #include \u0026lt;iostream\u0026gt; #define x first #define y second  using namespace std; int main() { pair\u0026lt;char, int\u0026gt; p1{\u0026#39;a\u0026#39;, 97}; cout \u0026lt;\u0026lt; p1.first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p1.second \u0026lt;\u0026lt; endl; pair\u0026lt;char, int\u0026gt; p2; p2 = make_pair(\u0026#39;b\u0026#39;, 98); // c++98 需要借助函数定义  cout \u0026lt;\u0026lt; p2.x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p2.y \u0026lt;\u0026lt; endl; // pair 六种比较都有，双关键字比较  return 0; }   \u0026gt;\u0026gt;\u0026gt;\na 97\rb 98\r 支持比较运算（字典序），以 first 为第一关键字，以 second 为第二关键字 如果需要“三元组”，使用 struct 即可   ","description":"二元组","id":191,"section":"cpp","tags":null,"title":"08. pair","uri":"https://yorkfish.github.io/review/cpp/08-pair/"},{"content":" empty() size() begin(), end() ++, \u0026ndash;   insert() find() erase() count()   ps  一些哈希表，如 unordered_set, unordered_map, unordered_multiset, unordered_multimap 和 set/multiset, map/multimap 类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的 ++, \u0026ndash;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;iostream\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { unordered_set\u0026lt;int\u0026gt; a; // 哈系表，与 set 相比，没有 lower_bound(), upper_bound()  unordered_multiset\u0026lt;int\u0026gt; b; // 哈系表，可以存储重复元素  cout \u0026lt;\u0026lt; a.empty() \u0026lt;\u0026lt; endl; a.insert(1); cout \u0026lt;\u0026lt; *a.find(1) \u0026lt;\u0026lt; endl; a.erase(1); cout \u0026lt;\u0026lt; a.size() \u0026lt;\u0026lt; endl; // 没有 clear  a = unordered_set\u0026lt;int\u0026gt;(); // 可以队列那样通过初始化清空  return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1\r1\r0\r","description":"“集合”","id":192,"section":"cpp","tags":null,"title":"08. unordered_set","uri":"https://yorkfish.github.io/review/cpp/stl/08-unordered-set/"},{"content":"1. 贪婪  一般情况下，正则默认贪婪匹配 尽可能多得匹配 如  用 y.*h 去匹配 yorkfish-yorkfish 得到 yorkfish-yorkfish    2. 非贪婪  在相应规则之后加上 ?，表示使用非贪婪模式 尽可能少得匹配 如  用 y.*?h 去匹配 yorkfish-yorkfish 得到 yorkfish    ","description":"贪婪与非贪婪","id":193,"section":"regex","tags":null,"title":"08. greedy and non-greedy","uri":"https://yorkfish.github.io/review/regex/08-greedy-and-non-greedy/"},{"content":"例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  import multiprocessing as mp import os import time def sing(num, name): print(\u0026#34;唱歌进程的 pid：\u0026#34;, os.getpid()) print(\u0026#34;唱歌进程的父进程 pid：\u0026#34;, os.getppid()) for i in range(num): print(name, \u0026#34;唱歌...\u0026#34;) time.sleep(0.5) def dance(num, name): print(\u0026#34;跳舞进程的 pid：\u0026#34;, os.getpid()) print(\u0026#34;跳舞进程的父进程 pid：\u0026#34;, os.getppid()) for i in range(num): print(name, \u0026#34;跳舞...\u0026#34;) time.sleep(0.5) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;主进程的 pid：\u0026#34;, os.getpid()) sing_process = mp.Process(target=sing, args=(3, \u0026#34;李雷\u0026#34;)) dance_process = mp.Process(target=dance, kwargs={\u0026#34;name\u0026#34;: \u0026#34;韩梅梅\u0026#34;, \u0026#34;num\u0026#34;: 2}) sing_process.start() dance_process.start()   \u0026gt;\u0026gt;\u0026gt;\n主进程的 pid： 15740\r跳舞进程的 pid： 12868\r跳舞进程的父进程 pid： 15740\r韩梅梅 跳舞...\r韩梅梅 跳舞...\r唱歌进程的 pid： 14792\r唱歌进程的父进程 pid： 15740\r李雷 唱歌...\r李雷 唱歌...\r李雷 唱歌...\r","description":"当前进程的 pid 与父进程的 pid","id":194,"section":"python","tags":null,"title":"08. pid","uri":"https://yorkfish.github.io/review/python/multiprocessing/08-pid/"},{"content":"例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import threading import time semaphore = threading.Semaphore(3) # 最多 3 个线程同时使用资源 def func(): if semaphore.acquire(): for _ in range(5): print(threading.currentThread().getName(), \u0026#34;get semaphore\u0026#34;) time.sleep(5) semaphore.release() print(threading.currentThread().getName(), \u0026#34;release semaphore\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: for _ in range(8): t1 = threading.Thread(target=func) t1.start()   \u0026gt;\u0026gt;\u0026gt;\nThread-1 get semaphore\rThread-1 get semaphore\rThread-2 get semaphore\rThread-1 get semaphore\rThread-2 get semaphore\rThread-1 get semaphore\rThread-2 get semaphore\rThread-1 get semaphore\rThread-2 get semaphore\rThread-3 get semaphore\rThread-2 get semaphore\rThread-3 get semaphore\rThread-3 get semaphore\rThread-3 get semaphore\rThread-3 get semaphore\rThread-1 release semaphore\rThread-4 get semaphore\rThread-4 get semaphore\rThread-4 get semaphore\rThread-4 get semaphore\rThread-4 get semaphore\rThread-3 release semaphore\rThread-2 release semaphore\rThread-6 get semaphore\rThread-6 get semaphore\rThread-5 get semaphore\rThread-6 get semaphore\rThread-5 get semaphore\rThread-6 get semaphore\rThread-5 get semaphore\rThread-6 get semaphore\rThread-5 get semaphore\rThread-5 get semaphore\rThread-4 release semaphore\rThread-7 get semaphore\rThread-7 get semaphore\rThread-7 get semaphore\rThread-6 release semaphore\rThread-7 get semaphore\rThread-5 release semaphore\rThread-7 get semaphore\rThread-8 get semaphore\rThread-8 get semaphore\rThread-8 get semaphore\rThread-8 get semaphore\rThread-8 get semaphore\rThread-7 release semaphore\rThread-8 release semaphore\r说明  因为无序性，所以结果不唯一 简单地说，就是“三个一波”，直到结束  ","description":"线程上限","id":195,"section":"python","tags":null,"title":"08. semaphore","uri":"https://yorkfish.github.io/review/python/threading/08-semaphore/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, width=30, height=2) l.pack() window.mainloop()   2. 添加一个 scale 1 2 3 4 5 6 7 8 9  def print_selection(v): l.config(text=\u0026#34;you have selected \u0026#34; + v) s = tk.Scale(window, label=\u0026#34;try me\u0026#34;, orient=\u0026#39;horizontal\u0026#39;, from_=0, to=10, length=400, showvalue=0, tickinterval=2, resolution=0.01, command=print_selection) s.pack()   ps    参数 释义     label 设置标签值   orient 设置拖拽条（滚动条）方向   from_ 起始值   to 最终值   length 拖拽条的长度   showvalue 设置是否拖拽条上方显示数值\n0: 不显示，1: 显示   tickinterval 间隔   resolution 精度     一般地，tkinter 的 length 的单位是像素  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, width=30, height=2) l.pack() def print_selection(v): l.config(text=\u0026#34;you have selected \u0026#34; + v) s = tk.Scale(window, label=\u0026#34;try me\u0026#34;, orient=\u0026#39;horizontal\u0026#39;, from_=0, to=10, length=200, showvalue=0, tickinterval=2, resolution=0.01, command=print_selection) s.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"尺度","id":196,"section":"python","tags":null,"title":"08. Scale","uri":"https://yorkfish.github.io/review/python/tkinter/08-scale/"},{"content":"1. 简介  列表、集合、字典可以用生成式快速生成  2. 举例 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; [i for i in range(10)] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; {s for s in range(10)} {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; {d: d%2==0 for d in range(5)} {0: True, 1: False, 2: True, 3: False, 4: True} \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":197,"section":"python","tags":null,"title":"08. generator","uri":"https://yorkfish.github.io/review/python/basics/08-generator/"},{"content":"1. 提出问题  只安装了 Anaconda，想使用 IDLE  2. 解决方法  我的 Anaconda 装在 D:\\anaconda3  方式一  双击 D:\\anaconda3\\Lib\\idlelib\\idle.bat  方式二  双击 D:\\anaconda3\\Scripts\\idle.exe 双击后会先出现一个命令窗，再出来 IDLE  方式三  在桌面，右键 \u0026gt; 新建 \u0026gt; 快捷方式 在弹窗口中输入 D:\\anaconda3\\pythonw.exe \u0026quot;D:\\anaconda3\\Lib\\idlelib\\idle.pyw\u0026quot;，点击确定 在新弹窗中输入 IDLE，点击确定  ","description":"","id":198,"section":"python","tags":null,"title":"08. IDLE","uri":"https://yorkfish.github.io/review/python/operation/08-idle/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11  import numpy as np import matplotlib.pyplot as plt def square(x): return -x**2 + 1 a = np.linspace(-5, 5, 200) # [-5, 5] 之内取 200 个点 plt.plot(a, square(a)) plt.show()     得到图片\n  ","description":"","id":199,"section":"python","tags":null,"title":"08. matplotlib pyplot","uri":"https://yorkfish.github.io/review/python/numpy/08-matplotlib-pyplot/"},{"content":"1. 说明  sort() 是 list 的方法 sorted() 是 Python 的内置函数，不隶属于某种数据类型 sorted() 可以对所有的可迭代对象进行排序  2. 举例 例一 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; lst = [\u0026#34;Tony Black\u0026#34;, \u0026#34;Amy Green\u0026#34;, \u0026#34;Johnny Lee\u0026#34;] \u0026gt;\u0026gt;\u0026gt; lst.sort() \u0026gt;\u0026gt;\u0026gt; lst [\u0026#39;Amy Green\u0026#39;, \u0026#39;Johnny Lee\u0026#39;, \u0026#39;Tony Black\u0026#39;] \u0026gt;\u0026gt;\u0026gt; lst.sort(reverse=True) \u0026gt;\u0026gt;\u0026gt; lst [\u0026#39;Tony Black\u0026#39;, \u0026#39;Johnny Lee\u0026#39;, \u0026#39;Amy Green\u0026#39;] \u0026gt;\u0026gt;\u0026gt; lst.sort(key=lambda x: x[2]) \u0026gt;\u0026gt;\u0026gt; lst [\u0026#39;Johnny Lee\u0026#39;, \u0026#39;Tony Black\u0026#39;, \u0026#39;Amy Green\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; d = {\u0026#34;Tony\u0026#34;: 22, \u0026#34;Amy\u0026#34;: 19, \u0026#34;Johnny\u0026#34;: 25} \u0026gt;\u0026gt;\u0026gt; sorted(d.values()) [19, 22, 25] \u0026gt;\u0026gt;\u0026gt; sorted(d.items(), key=lambda x: x[0]) # 按字典的键排序 [(\u0026#39;Amy\u0026#39;, 19), (\u0026#39;Johnny\u0026#39;, 25), (\u0026#39;Tony\u0026#39;, 22)] \u0026gt;\u0026gt;\u0026gt; sorted(d.items(), key=lambda x: x[1], reverse=True) # 按字典的值排序 [(\u0026#39;Johnny\u0026#39;, 25), (\u0026#39;Tony\u0026#39;, 22), (\u0026#39;Amy\u0026#39;, 19)] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":200,"section":"python","tags":null,"title":"08. sorted()","uri":"https://yorkfish.github.io/review/python/bif/08-sorted/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Hero(object): # 类变量 game_name = \u0026#34;LOL\u0026#34; def __init__(self, name): # 实例变量 self.name = name # 实例方法 def flash(self): # 局部变量 count = 0 print(f\u0026#34;{self.name} used flash!\u0026#34;) # 类方法 @classmethod def heal(cls): print(cls.game_name) @classmethod def heals(cls, hero): print(hero.name) lijing = Hero(\u0026#34;Lijing\u0026#34;) # Hero.flash() # TypeError: flash() missing 1 required positional argument: \u0026#39;self\u0026#39; # Hero 无法传入一个实例对象的指针来对应形参 self Hero.heal() # 类使用类方法 lijing.heal() # 实例使用类方法 lijing.heals(lijing) # 实例使用类方法访问实例变量   \u0026gt;\u0026gt;\u0026gt;\nLOL\rLOL\rLijing\r","description":"","id":201,"section":"python","tags":null,"title":"08. 类方法与实例方法","uri":"https://yorkfish.github.io/review/python/class/08-class-method-and-instance-method/"},{"content":"1. rewind 简介  使位置指针重新返回文件的开头 此函数没有返回值  作用  文件的位置指针重新定位于开头 feof 的值恢复为 0（假）  2. fseek 简介  对流式文件可以进行顺序读写，也可以进行随机读写 此函数可以实现改变文件的位置指针 一般用于二进制文件，因为文本文件要发生字符转换，计算位置时往往会发生混乱 可以借助此函数实现随机读写  一般形式  fseek(文件类型指针, 位移量, 起始点);     起始点 名字 代表数字     文件开始 SEEK_SET 0   当前位置 SEEK_CUR 1   文件末尾 SEEK_END 2     位移量：以“起始点”为基点，向前移动的字节数  ANSI C 和大多数 C 版本要求位移量是 long 型数据 如此，当文件的长度大于 64kb 时，不致于出问题    举例 fseek(fp, 100L, 0); // 将位置指针移到离文件头 100 个字节处\rfseek(fp, 50L, 1); // 将位置指针移到离当前位置 50 个字节处\rfseek(fp, -10L, 2); // 将位置指针从文件末尾处向后退 10 个字节\r3. ftell 简介  得到流式文件中的当前位置，用相对于文件开头的位移量来表示 如果 ftell 返回的是 -1L，表示出错  4. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); float nums[5] = {11.0, 12.0, 13.0, 14.0, 15.0}; int fsize = sizeof(float); for (int i = 0; i \u0026lt; 5; i++) { fwrite(\u0026amp;nums[i], fsize, 1, fp); } fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); float temp; long addr = ftell(fp); printf(\u0026#34;addr: %ld\\n\u0026#34;, addr); // addr: 0  fread(\u0026amp;temp, fsize, 1, fp); printf(\u0026#34;num: %f\\n\u0026#34;, temp); // num: 11.000000  fseek(fp, 12L, 1); addr = ftell(fp); printf(\u0026#34;addr: %ld\\n\u0026#34;, addr); // addr: 16  fread(\u0026amp;temp, fsize, 1, fp); printf(\u0026#34;num: %f\\n\u0026#34;, temp); // num: 15.000000  rewind(fp); addr = ftell(fp); printf(\u0026#34;addr: %ld\\n\u0026#34;, addr); // addr: 0  fread(\u0026amp;temp, fsize, 1, fp); printf(\u0026#34;num: %f\\n\u0026#34;, temp); // num: 11.000000  fclose(fp); return 0; }   ","description":"","id":202,"section":"c","tags":null,"title":"08. rewind, fseek, ftell","uri":"https://yorkfish.github.io/review/c/file/08-rewind-fseek-ftell/"},{"content":"1. 关键字  static  2. 说明  若希望函数中的局部变量在函数调用结束后继续存在，即其占用的存储单元不释放，需使用静态局部变量 若之前调用过静态局部变量，则使用时默认为上次结束时的值 若非必要，不要多用静态变量  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; void test() { static int num = 1; printf(\u0026#34;%d\\n\u0026#34;, num); num++; } int main() { test(); // 1  test(); // 2  return 0; }   ","description":"","id":203,"section":"c","tags":null,"title":"08. static","uri":"https://yorkfish.github.io/review/c/function/08-static/"},{"content":"1. 一般定义形式 union 共用体 {\r成员表列\r} 变量表列;\r2. 说明  使几种不同的变量共占同一段内存的结构，称为“共用体” 共用体与结构体的定义形式相似，但它们的含义是不同的 结构体变量所占内存长度是各成员占的内存长度之和，每个成员分别占有其自己的内存单元 共用体变量所占内存长度等于最长的成员的长度 不能引用共用体变量，只能引用共用体变量的成员  3. 举例 例一 1 2 3 4 5 6 7  union data { int i; char ch; float f; }; union data a, b, c;   例二 1 2 3 4 5  union data { int i; char ch; float f; } a, b, c;   例三 1 2 3 4 5  union { int i; char ch; float f; } a, b, c;   ","description":"","id":204,"section":"c","tags":null,"title":"08. 共用体概述","uri":"https://yorkfish.github.io/review/c/struct-union-enum/08-overview-of-union/"},{"content":"1. malloc 函数原型 void * malloc(unsigned int size);\n作用  在内存的动态存储区中分配一个长度为 size 的连续空间 此函数的值（即返回值），是一个分配域的起始地址，类型为 void 如果此函数未能成功执行（如内存空间不足），则返回空指针 NULL  2. calloc 函数原型 void * calloc(unsigned n, unsigned size);\n作用   在内存的动态存储中分配 n 个长度为 size 的连续空间\n  函数返回一个指向分配域起始位置的指针\n  如果分配不成功，返回 NULL\n  calloc 函数可以为一维数组开辟动态存储空间，n 为数组元素个数，每个元素长度为 size\n  3. realloc 函数原型 void *realloc(void *p, unsigned size)\n作用  重新分配由 p 指向的动态存储区 函数返回一个指向分配域起始位置的指针 如果分配不成功，返回 NULL  4. free 函数原型 void free(void * p);\n作用  释放由 p 指向的动态存储区 使这部分内存区能被其他内存使用 p 是最近一次调用 calloc 或 malloc 函数时返回的值 free 函数无返回值  5. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int** initNums(int numsSize, int* numsColSize) { int** nums = malloc(numsSize * sizeof(int*)); for (int i = 0; i \u0026lt; numsSize; i++) { nums[i] = calloc(numsColSize[i], sizeof(int)); } return nums; } void printNums(int** nums, int numsSize, int* numsColSize) { for (int i = 0; i \u0026lt; numsSize; i++) { for (int j = 0; j \u0026lt; numsColSize[i]; j++) { printf(\u0026#34;%d \u0026#34;, nums[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } void resizeNums(int** nums, int row, int resize) { realloc(nums[row], resize); } void freeNums(int** nums, int numsSize) { for (int i = 0; i \u0026lt; numsSize; i++) { free(nums[i]); } free(nums); } int main() { int numsSize = 3; int numsColSize[] = {5, 5, 5}; int** nums = initNums(numsSize, numsColSize); printNums(nums, numsSize, numsColSize); printf(\u0026#34;=========\\n\u0026#34;); numsColSize[1]++; resizeNums(nums, 1, numsColSize[1]); printNums(nums, numsSize, numsColSize); freeNums(nums, numsSize); return 0; }   ","description":"","id":205,"section":"c","tags":null,"title":"08. 动态分配内存与释放","uri":"https://yorkfish.github.io/review/c/pointer/08-malloc-calloc-realloc-free/"},{"content":"常用格式    符号 释义     %o 八进制整型数   %d 十进制整型数，%i 也行   %Ld 十进制长整型数   %u 无符号整型数   %Lu 无符号长整型数   %x 十六进制整型数   %mc 字符占 m 个宽度，右对齐   %-mc 字符占 m 个宽度，左对齐   %f 以小数形式输出单、双精度数，隐含输出 6 位小数   %e 一般，输出占 13 列   %g 根据数值的大小，自动选 f 格式或 e 格式\n选择输出占宽度较小的一种，且不输出无意义的零    %f 与 %lf  scanf()  float 对应 %f double 对应 %lf   printf()  float 会被提升为 double，且 printf() 只会看到双精度数 float 与 double 都对应 %f %lf 在 printf() 下是未定义的，不过用它不会有 warning    ","description":"","id":206,"section":"c","tags":null,"title":"08. 输出格式","uri":"https://yorkfish.github.io/review/c/basics/08-format/"},{"content":"1. Markdown 方式  示例  ~~删除文本~~   效果  删除文本    2. HTML 方式  用法：借助 HTML 的标签 \u0026lt;del\u0026gt; 说明：从效果上看，\u0026lt;s\u0026gt; 也满足“删除线”的需求，不过它已经过时了  示例与效果   示例\n\u0026lt;del\u0026gt;del 标签也可删除\u0026lt;/del\u0026gt;\r\u0026lt;s\u0026gt;s 标签过时了\u0026lt;/s\u0026gt;\r  效果\ndel 标签也可删除 s 标签过时了\n  ","description":"","id":207,"section":"markdown","tags":null,"title":"09. 删除线","uri":"https://yorkfish.github.io/review/markdown/09-strikethrough/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;event binding\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;button v-on:click=\u0026#34;al\u0026#34;\u0026gt;单击\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;button v-on:dblclick=\u0026#34;al\u0026#34;\u0026gt;双击\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;button v-on:mouseover=\u0026#34;al\u0026#34;\u0026gt;鼠标移入\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;button v-on:mouseout=\u0026#34;al\u0026#34;\u0026gt;鼠标移出\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input @keydown=\u0026#34;down1\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input @keydown.50=\u0026#34;down2\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { msg: \u0026#34;ok\u0026#34;, }, // 主要用来写函数  methods: { al: function(){ alert(this.msg); }, down1: function(e){ // alert(\u0026#34;你按下了键盘\u0026#34;);  // console.log(e);  console.log(e.keyCode); }, down2: function(e){ console.log(\u0026#34;你按下了 2\u0026#34;); } } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   说明  v-on: 事件类型  简写：@事件类型 鼠标事件  mouseout mouseover mousemove click dblclick   键盘事件  keydown keyup      ","description":"事件绑定","id":208,"section":"web","tags":null,"title":"09. Event Binding","uri":"https://yorkfish.github.io/review/web/vue/09-event-binding/"},{"content":"说明  可以使用内置对象 document 上的 getElementById() 方法来获取页面上设置了 id 属性的元素 获取到的是一个 html 对象 然后将它赋值给一个变量  错误的写法 Code 1 2 3 4 5  \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var oDiv = document.getElementById(\u0026#39;div1\u0026#39;); \u0026lt;/script\u0026gt; ... \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt;这是一个 div 元素\u0026lt;/div\u0026gt;   出错原因  程序自上而下加载执行 Javascript 写在 div1 的上面 Javascript 去页面上获取元素 div1 的时候，元素 div1 还没有被加载  正确的写法 写法一  将 Javascript 放到页面最下边  1 2 3 4 5 6 7 8  \u0026lt;body\u0026gt; .... \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt;这是一个 div 元素\u0026lt;/div\u0026gt; .... \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var oDiv = document.getElementById(\u0026#39;div1\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt;   写法二  将 Javascript 语句放到 window.onload 触发的函数里面 获取元素的语句会在页面加载完后才执行  1 2 3 4 5 6 7 8 9  \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function(){ var oDiv = document.getElementById(\u0026#39;div1\u0026#39;); } \u0026lt;/script\u0026gt; .... \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt;这是一个div元素\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;   ","description":"获取元素","id":209,"section":"web","tags":null,"title":"09. Get Element","uri":"https://yorkfish.github.io/review/web/javascript/09-get-element/"},{"content":"简介  元素在页面中显示成一个方块，类似一个盒子 把元素叫做盒子，设置对应的样式分别为  margin: 盒子与盒子之间的间距 border: 盒子的边框 padding: 盒子内的内容和边框之间的间距    盒子真实尺寸 盒子宽度 = width + padding左右 + border左右\r盒子高度 = height + padding上下 + border上下\rbox-sizing 增大内容和边框的距离但不改变盒子的尺寸\rbox-sizing：content-box | border-box\r举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;box3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box4\u0026#34;\u0026gt;box4\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  *{ width: 100px; height: 100px; } .box1{ background: #a7ab86; border: 10px solid; padding: 20px; } .box2, .box3, .box4{ background: #b8d3ca; } .box3{ padding: 20px; box-sizing: border-box; /* 改变间距但不改变盒子大小 */ } .box4{ padding: 20px; border: 10px solid red; box-sizing: border-box; }   \u0026gt;\u0026gt;\u0026gt;\n","description":"盒子模型","id":210,"section":"web","tags":null,"title":"09. Box Model","uri":"https://yorkfish.github.io/review/web/css/09-box-model/"},{"content":"1. a 标签 1.1 简介  a 标签一般用于网址 需要闭合  1.2 属性说明    属性 释义     href 后面跟要跳转的网址   target target=\u0026quot;_blank\u0026quot; 表示在新标签页中打链接    1.3 打开网络链接 用法  \u0026lt;a href=\u0026quot;https://github.com/yorkfish\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;YorkFish\u0026lt;/a\u0026gt;  效果  YorkFish  1.4 打开本地链接 用法  \u0026lt;a href=\u0026quot;./本地链接.html\u0026quot;\u0026gt;跳转到本地的当前文件夹下的\u0026quot;本地链接.html\u0026quot;\u0026lt;/a\u0026gt;   绝对路径：Windows 中绝对路径的根是我们文件所在的盘符，如  C:\\Users\\York\\Desktop\\前端学习.html   注意：实际开发当中建议使用相对路径  ./当前目录 ../上级目录     2. \u0026lt;img\u0026gt; 标签 2.1 简介  img 标签一般用于图片 不需要闭合  2.2 属性说明    属性 释义     src 图片的地址，网络地址、本地地址均可   alt 图片加载失败时的替代文字（必须写）   title 鼠标移至图上时的提示信息（可写可不写）   width, height 设置图片的“宽度”、“高度”，一般二选一    一般地，图片的宽度与高度关联了纵横比\r 2.3 用法简介 1 2 3  \u0026lt;img src=\u0026#34;path/to/picture\u0026#34; height=\u0026#34;200px\u0026#34; alt=\u0026#34;加载失败了~\u0026#34; title=\u0026#34;picture\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./picture\u0026#34; width=\u0026#34;400px\u0026#34; alt=\u0026#34;加载失败了~\u0026#34; title=\u0026#34;picture\u0026#34;\u0026gt;   3. 锚点 用法 1 2 3 4 5 6 7 8 9 10  \u0026lt;b id=\u0026#34;top1\u0026#34;\u0026gt;图片一\u0026lt;/b\u0026gt; \u0026lt;br\u0026gt; \u0026lt;img src=\u0026#34;./imgs/001.png\u0026#34; alt=\u0026#34;不好意思，加载失败了~\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;b id=\u0026#34;top2\u0026#34;\u0026gt;图片二\u0026lt;/b\u0026gt; \u0026lt;br\u0026gt; \u0026lt;img src=\u0026#34;./imgs/002.png\u0026#34; alt=\u0026#34;不好意思，加载失败了~\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;b id=\u0026#34;top3\u0026#34;\u0026gt;图片三\u0026lt;/b\u0026gt; \u0026lt;br\u0026gt; \u0026lt;img src=\u0026#34;./imgs/003.png\u0026#34; alt=\u0026#34;不好意思，加载失败了~\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;#top1\u0026#34;\u0026gt;跳转到图片一\u0026lt;/a\u0026gt; \u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;#top2\u0026#34;\u0026gt;跳转到图片二\u0026lt;/a\u0026gt; \u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;#top3\u0026#34;\u0026gt;跳转到图片三\u0026lt;/a\u0026gt;   效果 图片一\n图片二\n图片三\n跳转到图片一\n跳转到图片二\n跳转到图片三\n说明：下方三个 a 标签相当于“超链接”，点哪个就回到哪张图 ","description":"链接标签","id":211,"section":"web","tags":null,"title":"09. Link Label","uri":"https://yorkfish.github.io/review/web/html/09-link-label/"},{"content":"1. 一些概念   放在堆里的数据\n 第一次使用前不会被分配空间，而是放到 .bss 段 第一次使用时会动态分配空间，同时初始化成 0，且分配的空间都在堆中    有返回值的函数不写 return，会返回随机值\n  静态变量相当于在函数内部定义了一个只有该函数才能使用的全局变量\n  静态变量不赋初值，默认为 0\n  静态的变量会开在堆里面\n  函数内部的变量会开在栈里面，如果开太大(\u0026gt;1M)，会爆栈\n  函数的名称与参数一致，则认为是一个函数，即使返回值不同，也没用\n  递归函数不支持 inline，或者说，递归函数加上 inline 没有效果\n  2. 引用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026lt;iostream\u0026gt; using namespace std; void change(int \u0026amp;a, int \u0026amp;b) // 有了引用，就可以省去指针那个 * { a ++ ; b ++ ; } int main() { int a = 10, b = 20; cout \u0026lt;\u0026lt; \u0026#34;before: a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; change(a, b); cout \u0026lt;\u0026lt; \u0026#34; after: a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\nbefore: a = 10, b = 20\rafter: a = 11, b = 21\r3. 默认参数 / 缺省参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include \u0026lt;cstdio\u0026gt; // 默认值可以有多个，但必须都放在最后 void foo(int x, int y = 10) { printf(\u0026#34;x = %d, y = %d\\n\u0026#34;, x, y); } // 使用函数时不调用，像 define 那样替换 inline void bar() { cout \u0026lt;\u0026lt; \u0026#34;inline\u0026#34; \u0026lt;\u0026lt; endl; } int main() { int a, b; a = 5, b = 8; foo(a, b); a = 5; foo(a); return 0; }   \u0026gt;\u0026gt;\u0026gt;\nx = 5, y = 8\rx = 5, y = 10\r4. 多维数组传参 一维  void print(int *a) {} void print(int a[]) {} void print(int a[10]) {} // 有范围限制  二维   多维数组只有最高维可以省写\n  void print(int (*a)[10]) {}\n  void print(int a[][10]) {}\n  ","description":"函数","id":212,"section":"cpp","tags":null,"title":"09. function","uri":"https://yorkfish.github.io/review/cpp/09-function/"},{"content":" empty() size() begin(), end() ++, \u0026ndash;   insert() find() erase() count()   1. 定义 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;iostream\u0026gt;#include \u0026lt;unordered_map\u0026gt; using namespace std; int main() { unordered_map\u0026lt;int, int\u0026gt; a; // C++11 开始支持  unordered_multimap\u0026lt;int, int\u0026gt; b; // 不常用  return 0; }   2. 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #include \u0026lt;algorithm\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; bool cmp(pair\u0026lt;int, int\u0026gt; a, pair\u0026lt;int, int\u0026gt; b) { return a.first \u0026gt; b.first; } int main() { unordered_map\u0026lt;int, int\u0026gt; um; // 无序的哈希结构  um[1] = 5; um[2] = 10; um[3] = 15; um[4] = 20; um[5] = 25; for (auto it = um.begin(); it != um.end(); it ++ ) cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; // “指针”  cout \u0026lt;\u0026lt; \u0026#34;===\u0026#34; \u0026lt;\u0026lt; endl; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; v(um.begin(), um.end()); sort(v.begin(), v.end(), cmp); for (auto p : v) cout \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; endl; // “实体”  return 0; }   \u0026gt;\u0026gt;\u0026gt;\n5 25\r4 20\r3 15\r1 5\r2 10\r===\r5 25\r4 20\r3 15\r2 10\r1 5\r","description":"“字典”","id":213,"section":"cpp","tags":null,"title":"09. unordered_map","uri":"https://yorkfish.github.io/review/cpp/stl/09-unordered-map/"},{"content":"1. 测试方法  方便起见，新建文档 test.html 写入 script 标签 在标签内写测试语句 用浏览器打开，按 F12 查看结果  2. 两种定义方式 方式一 直接量语法 1 2 3  var zz = /\\d/; console.log(zz); // /\\d/ console.log(typeof zz); // object   方式二 创建 RegExp 对象的语法 1 2 3  var zz = new RegExp(\u0026#34;\\\\d\u0026#34;); // 反斜线需要转义 console.log(zz); // /\\d/ console.log(typeof zz); // object   3. 三种模式 可以混搭 模式一 忽略大小写 1 2 3 4  var str = \u0026#34;YorkFish\u0026#34;; var zz = /york/i; var result = str.match(zz); console.log(result); // [\u0026#34;York\u0026#34;, index: 0, input: \u0026#34;YorkFish\u0026#34;, groups: undefined]   模式二 全局匹配 1 2 3 4 5 6 7  var str = \u0026#34;fish1 fish2 fish3\u0026#34;; var zz1 = /fish\\d/; // 默认只匹配第一个 var zz2 = /fish\\d/g; // 匹配所有 var result1 = str.match(zz1); var result2 = str.match(zz2); console.log(result1); // [\u0026#34;fish1\u0026#34;, index: 0, input: \u0026#34;fish1 fish2 fish3\u0026#34;, groups: undefined] console.log(result2); // (3) [\u0026#34;fish1\u0026#34;, \u0026#34;fish2\u0026#34;, \u0026#34;fish3\u0026#34;]   模式三 多行匹配 1 2 3 4 5 6 7  var str = \u0026#34;line1\\nline2\\nline3\u0026#34;; var zz1 = /^line\\d$/g; var zz2 = /^line\\d$/gm; var result1 = str.match(zz1); var result2 = str.match(zz2); console.log(result1); // null console.log(result2); // (3) [\u0026#34;line1\u0026#34;, \u0026#34;line2\u0026#34;, \u0026#34;line3\u0026#34;]   4. RegExp 对象方法 compile 1 2 3 4 5 6 7 8  var str = \u0026#34;fish1 fish2 fish3\u0026#34;; var zz = /[a-z]+/g; var result = zz.exec(str); console.log(result); // [\u0026#34;fish\u0026#34;, index: 0, input: \u0026#34;fish1 fish2 fish3\u0026#34;, groups: undefined]  zz.compile(\u0026#34;\\\\d\u0026#34;, \u0026#39;g\u0026#39;); // 废物利用，避免重新创建对象 result = zz.exec(str); console.log(result); // [\u0026#34;1\u0026#34;, index: 4, input: \u0026#34;fish1 fish2 fish3\u0026#34;, groups: undefined]   exec 1 2 3 4  var str = \u0026#34;fish1 fish2 fish3\u0026#34;; var zz = /fish\\d/g; var result = zz.exec(str); // 匹配一次，返回找到的值，并确定其位置 console.log(result); // [\u0026#34;fish1\u0026#34;, index: 0, input: \u0026#34;fish1 fish2 fish3\u0026#34;, groups: undefined]    exec 是正则的方法，g 模式下一次只找一个结果 match 是字符串的方法，g 模式下一次找出所有结果   test 1 2 3 4  var str = \u0026#34;fish1 fish2 fish3\u0026#34;; var zz = /fish\\d/g; var result = zz.test(str); // 仅用于测试，有结果返回 true，没结果返回 false console.log(result); // true   5. RegExp 对象属性 source 获取正则内容 1 2  var zz = /\\d/; console.log(zz.source); // \\d   lastIndex 下次匹配的起始索引 1 2 3 4  var str = \u0026#34;fish1 fish2 fish3\u0026#34;; var zz = /fish\\d/g; var result = zz.exec(str); console.log(zz.lastIndex); // 5；g 模式下生效，非 g 模式结果为 0    我只列了一部分，更多的可见 W3school 的文档：\u0026gt;\u0026gt;\u0026gt; 传送门  ","description":"Js 场景使用正则","id":214,"section":"regex","tags":null,"title":"09. re-javascript","uri":"https://yorkfish.github.io/review/regex/09-re-javascript/"},{"content":"例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import multiprocessing def job(x): return x*x def multi_core(): pool = multiprocessing.Pool(processes=2) # 若不加参数，默认使用所有的核 res = pool.map(job, range(10)) print(res) if __name__ == \u0026#34;__main__\u0026#34;: multi_core()   \u0026gt;\u0026gt;\u0026gt;\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\r","description":"进程池 - 小例子","id":215,"section":"python","tags":null,"title":"09. pool","uri":"https://yorkfish.github.io/review/python/multiprocessing/09-pool/"},{"content":"例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import threading import time def func(): print(\u0026#34;I am running.\u0026#34;) time.sleep(4) print(\u0026#34;I am done.\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: t = threading.Timer(6, func) # 6s 后执行 func t.start() i = 0 while True: print(i, \u0026#34;==========\u0026#34;) i += 1 time.sleep(3)   \u0026gt;\u0026gt;\u0026gt;\n0 ==========\r1 ==========\r2 ==========\rI am running.\r3 ==========\rI am done.\r4 ==========\r# 后面内容省略\r示意图 time main func\r0 0 === |\r1 | |\r2 | |\r3 1 === |\r4 | |\r5 | |\r6 2 === I am running.\r7 | |\r8 | |\r9 3 === |\r10 | I am done.\r11 |\r12 4 ===\r...\r","description":"定时器","id":216,"section":"python","tags":null,"title":"09. Timer","uri":"https://yorkfish.github.io/review/python/threading/09-timer/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8 9  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 18), width=20) l.pack() window.mainloop()   2. 添加两个 checkbutton 1 2 3 4 5 6 7 8 9 10  var1 = tk.BooleanVar() var2 = tk.BooleanVar() c1 = tk.Checkbutton(window, text=\u0026#34;C \u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), # 对齐~ variable=var1, onvalue=True, offvalue=False, command=print_selection) c2 = tk.Checkbutton(window, text=\u0026#34;Python\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), variable=var2, onvalue=True, offvalue=False, command=print_selection) c1.pack() c2.pack()   ps  onvalue, offvalue 和 tkinter.Radiobutton 中的 value 相似 以 c1 为例  选中 checkbutton 后  onvalue 的值会存入 var1 var1 将其赋值给参数 variable   没有选中 checkbutton 时  offvalue 的值会存入 var1 var1 将其赋值给参数 variable      3. print_selection 方法  需要写在调用它的语句的上方  1 2 3 4 5 6 7 8 9  def print_selection(): if var1.get() and var2.get(): l.config(text=\u0026#34;I love both\u0026#34;) elif var1.get(): l.config(text=\u0026#34;I love only C\u0026#34;) elif var2.get(): l.config(text=\u0026#34;I love only Python\u0026#34;) else: l.config(text=\u0026#34;I do not love either\u0026#34;)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 18), width=20) l.pack() def print_selection(): if var1.get() and var2.get(): l.config(text=\u0026#34;I love both\u0026#34;) elif var1.get(): l.config(text=\u0026#34;I love only C\u0026#34;) elif var2.get(): l.config(text=\u0026#34;I love only Python\u0026#34;) else: l.config(text=\u0026#34;I do not love either\u0026#34;) var1 = tk.BooleanVar() var2 = tk.BooleanVar() c1 = tk.Checkbutton(window, text=\u0026#34;C \u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), variable=var1, onvalue=True, offvalue=False, command=print_selection) c2 = tk.Checkbutton(window, text=\u0026#34;Python\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), variable=var2, onvalue=True, offvalue=False, command=print_selection) c1.pack() c2.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"勾选项","id":217,"section":"python","tags":null,"title":"09. Checkbutton","uri":"https://yorkfish.github.io/review/python/tkinter/09-checkbutton/"},{"content":"1. 简介  help() 可以查看开发者对于“模块、函数、类”所编写的详细描述文档  2. 说明 例一 1 2 3 4 5 6 7 8  \u0026#34;\u0026#34;\u0026#34; This module is for explain \u0026#34;help()\u0026#34;. help 函数可以查看开发者对于“模块、函数、类”所编写的详细描述文档 \u0026#34;\u0026#34;\u0026#34; import __main__ help(__main__)   \u0026gt;\u0026gt;\u0026gt;\nHelp on module __main__:\rNAME\r__main__\rDESCRIPTION\rThis module is for explain \u0026quot;help()\u0026quot;.\rhelp 函数可以查看开发者对于“模块、函数、类”所编写的详细描述文档\rDATA\r__annotations__ = {}\rFILE\rd:\\Test\\help.py\r例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026gt;\u0026gt;\u0026gt; import __main__ \u0026gt;\u0026gt;\u0026gt; help(__main__) Help on module __main__: NAME __main__ DATA __annotations__ = {} FILE (built-in) \u0026gt;\u0026gt;\u0026gt;   例三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def flash(): \u0026#34;\u0026#34;\u0026#34; This is a flash function. :return str. \u0026#34;\u0026#34;\u0026#34; pass class Hero(object): \u0026#34;\u0026#34;\u0026#34; This is a hero class. \u0026#34;\u0026#34;\u0026#34; def __init__(): pass if __name__ == \u0026#34;__main__\u0026#34;: help(flash) help(Hero)   \u0026gt;\u0026gt;\u0026gt;\nHelp on function flash in module __main__:\rflash()\rThis is a flash function.\r:return str.\rHelp on class Hero in module __main__:\rclass Hero(builtins.object)\r| This is a hero class.\r| | Methods defined here:\r| | __init__()\r| Initialize self. See help(type(self)) for accurate signature.\r| | ----------------------------------------------------------------------\r| Data descriptors defined here:\r| | __dict__\r| dictionary for instance variables (if defined)\r| | __weakref__\r| list of weak references to the object (if defined)\r","description":"","id":218,"section":"python","tags":null,"title":"09. help","uri":"https://yorkfish.github.io/review/python/basics/09-help/"},{"content":"1. 导入 1  import numpy as py   2. 一维 创建 1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; a = np.arange(4) \u0026gt;\u0026gt;\u0026gt; b = np.arange(4, 8) \u0026gt;\u0026gt;\u0026gt; print(a) [0 1 2 3] \u0026gt;\u0026gt;\u0026gt; print(b) [4 5 6 7] \u0026gt;\u0026gt;\u0026gt;   hstack 1 2 3  \u0026gt;\u0026gt;\u0026gt; print(np.hstack((a, b))) [0 1 2 3 4 5 6 7] \u0026gt;\u0026gt;\u0026gt;   vstack 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; print(np.vstack((a, b))) [[0 1 2 3] [4 5 6 7]] \u0026gt;\u0026gt;\u0026gt;   3. 二维  横向堆叠，行数需相同 纵向堆叠，列数需相同  创建 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; c = np.arange(4).reshape((2, 2)) \u0026gt;\u0026gt;\u0026gt; d = np.arange(4, 8).reshape((2, 2)) \u0026gt;\u0026gt;\u0026gt; print(c) [[0 1] [2 3]] \u0026gt;\u0026gt;\u0026gt; print(d) [[4 5] [6 7]] \u0026gt;\u0026gt;\u0026gt;   hstack 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; print(np.hstack((c, d))) [[0 1 4 5] [2 3 6 7]] \u0026gt;\u0026gt;\u0026gt;   vstack 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; print(np.vstack((c, d))) [[0 1] [2 3] [4 5] [6 7]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":219,"section":"python","tags":null,"title":"09. hstack \u0026 vstack","uri":"https://yorkfish.github.io/review/python/numpy/09-hstack-and-vstack/"},{"content":"1. 说明  一般地，除字符串外，能使用 + 操作的，都可以使用 sum()  2. 举例 例一 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; sum(a) 10 \u0026gt;\u0026gt;\u0026gt; sum(a, 5) 15 \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = [[1, 2, 3]] * 3 \u0026gt;\u0026gt;\u0026gt; sum(a, []) [1, 2, 3, 1, 2, 3, 1, 2, 3] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":220,"section":"python","tags":null,"title":"09. sum()","uri":"https://yorkfish.github.io/review/python/bif/09-sum/"},{"content":"1. 简介  “实例方法”只能由“实例对象”调用 “类”和“实例对象”都能调用“类方法”和“静态方法” “实例方法”、“类方法”和“静态方法”均能调用“类变量”和“实例变量”  2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  class Hero(object): # 类变量 game_name = \u0026#34;LOL\u0026#34; def __init__(self, name): # 实例变量 self.name = name # 实例方法 def flash(self): # 局部变量 count = 0 print(f\u0026#34;{self.name} used flash!\u0026#34;) # 类方法 @classmethod def heal(cls): print(cls.game_name) # 在类方法中使用类变量 @classmethod def heals(cls): print(lijing.name) # 在类方法中使用实例变量 # 静态方法 @staticmethod def ignit(): print(\u0026#34;used fire\u0026#34;) @staticmethod def say_game_name(): print(Hero.game_name) # 在静态方法中使用类变量 print(lijing.name) # 在静态方法中使用实例变量 lijing = Hero(\u0026#34;Lijing\u0026#34;) lijing.flash() # 实例调用实例方法 Hero.heal() # 类使用类方法 lijing.heal() # 实例使用类方法 Hero.ignit() # 类使用静态方法 lijing.ignit() # 实例使用静态方法 lijing.heals() # 实例使用类方法访问实例变量 lijing.say_game_name() # 实例使用静态方法访问类变量与实例变量 Hero.say_game_name() # 类使用静态方法访问类变量与实例变量   \u0026gt;\u0026gt;\u0026gt;\nLijing used flash!\rLOL\rLOL\rused fire\rused fire\rLijing\rLOL\rLijing\rLOL\rLijing\r","description":"","id":221,"section":"python","tags":null,"title":"09. 静态方法","uri":"https://yorkfish.github.io/review/python/class/09-static-method/"},{"content":"1. ferror 简介  除了在 getc, putc, fread, fwrite 等函数出错时有用 还可以主动使用以检查  一般形式 ferror(fp);\n说明  若返回值为 0，表示未出错 若返回一个非零值，表示出错 同一个文件每次调用输入输出函数，均产生一个新的 ferror 函数值 在调用一个输入输出函数后，应立即检查，否则信息会丢失  2. clearerr 作用  将文件错误标志和文件结束标志置为 0  说明   假设在调用一个输入输出函数时出现错误，ferror 函数值为一个非零值\n  在调用 clearerr(fp) 后，ferror(fp) 的值变为 0\n  只要出现错误标志，就一直保留，直到出现如下情况\n 对同一文件调用 clearerr 函数 对同一文件调用 rewind 函数 使用任何其他一个输入输出函数    3. 举例 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); fputs(\u0026#34;YorkFish\u0026#34;, fp); printf(\u0026#34;%d\\n\u0026#34;, ferror(fp)); // 0  fclose(fp); return 0; }   ","description":"","id":222,"section":"c","tags":null,"title":"09. ferror() \u0026 clearerr()","uri":"https://yorkfish.github.io/review/c/file/09-ferror-and-clearerr/"},{"content":"无条件转向语句 1. 形式  goto 语句标号;  语句标号：用标识符表示，命名规则与标识符相同（字母、数字、下划线，不用数字开头） 如：goto label_1;    2. 使用  一般不用，以下两种情形可以考虑  与 if 语句构成循环结构 从循环体中跳转到循环体外  因为有 break 与 continue，goto 的使用机会不多 需要从多重循环的内层跳转到循环的外层，可以使用 goto 即使是跳出多重循环，一般也不采用 goto      3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { int i = 1, sum = 0; loop: if (i \u0026lt;= 100) { sum += i; i++; goto loop; } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; }   ","description":"","id":223,"section":"c","tags":null,"title":"09. goto","uri":"https://yorkfish.github.io/review/c/basics/09-goto/"},{"content":"1. 结论  实际上，用 register 声明变量是不必要的 如今优化的编译系统能够识别频繁的变量，从而自动地将这些变量放在寄存器中 同理，若非习惯，没必要刻意把 for 中的 i++ 写成 ++i，因为编译器会优化  2. 了解  由于对寄存器的存取速度远高于对内存的存取速度，因此这样做可以提高执行效率 如果需要重复运算的 n 很大，使用 register 可以节约许多执行时间 一个计算机系统中的寄存器数目是有限的 有的系统只允许将 int, char 和指针型变量定义为寄存器 局部静态变量不能定义为寄存器变量 register static int a, b, c;  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int factorial(long n) { register long ans = 1; for (int i = 2; i \u0026lt;= n; i++) { ans *= i; } return ans; } int main() { int res = factorial(19); printf(\u0026#34;%d\\n\u0026#34;, res); // 109641728  return 0; }   ","description":"","id":224,"section":"c","tags":null,"title":"09. register","uri":"https://yorkfish.github.io/review/c/function/09-register/"},{"content":"1. 说明  每一瞬时，只有一个成员起作用 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后，原有的成员就失效 共用体变量的地址和它的各成员的地址都是同一地址  不可行的操作  不能对共用体变量名赋值 不能企图引用变量名来得到一个值 不能在定义共用体变量时对它初始化 不能把共用体变量作为函数参数 不能使函数返回共用体变量  可行的操作  可以使用指向共用体变量的指针（与结构体变量这种用法相仿） 共用体类型可以出现在结构体类型定义中 结构体类型可以出现在共用体类型定义中 可以定义共用体数组 数组可以作为共用体的成员  2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;stdio.h\u0026gt; typedef union data { int i; char c; } Data, *pData; int main() { Data test; pData pTest = \u0026amp;test; printf(\u0026#34;%d\\n\u0026#34;, sizeof(test)); // 4  test.i = 10; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;test.i); // 0061FEC8，每次编译分配的地址不一定相同  printf(\u0026#34;%d\\n\u0026#34;, test.i); // 10  test.c = \u0026#39;y\u0026#39;; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;test.c); // 0061FEC8  printf(\u0026#34;%c\\n\u0026#34;, test.c); // y  printf(\u0026#34;%c\\n\u0026#34;, pTest-\u0026gt;c); // y  return 0; }   ","description":"","id":225,"section":"c","tags":null,"title":"09. 共用体的特点与使用","uri":"https://yorkfish.github.io/review/c/struct-union-enum/09-characteristics-of-union/"},{"content":"1. 常见的数据类型    定义 含义     int i 定义整型变量   int * p p 为指向整型数据的指针变量   int a[n] 定义整型数组 a，它有 n 个元素   int * p[n] 定义指针数组 p，它由 n 个指向整型数据的指针元素组成   int (*p)[n] p 为指向含 n 个元素的一维数组的指针变量   int f() f 为返回整型函数值的函数   int * p() p 为返回一个指针的函数，该指针指向整型数据   int (*p)() p 为指向函数的指针，该函数返回一个整型值   int **p p 是一个指针变量，它指向一个指向整型数据的指针变量    2. 指针运算 指针变量加减一个整数  p++ p-- p+i p-i p += i p -= i  指针变量赋值   p = \u0026amp;arr;\n  p = arr;\n  p = \u0026amp;arr[i];\n  p = max;\n  p1 = p2;\n  不应把一个整数赋给指针变量\n  不应把指针变量的值赋给一个整型变量\n  指针变量可以有空值  NULL 是整数 0，它的存储单元中所有二进位均为 0 一般，NULL 是这样定义的：#define NULL 0 系统保证 NULL 不作他用（不存放有效数据），即有效数据的指针不指向 0 单元 int* p = NULL; 与 int* p; 是两个不同的概念 任何指针变量或地址都可以与 NULL 作相等或不相等的比较  两个指针变量可以相减  两个指针变量之差是两个指针之间的元素的个数 p1 + p2 是没有意义的  两个指针变量的比较  若两个指针指向同一个数组的元素，则可以进行比较 指向前面的指针变量“小于”指向后面元素的指针变量  3. void 指针类型  (void *)p1: 将 p1 的值转换成 void * 类型 将一个函数定义为 void * 类型  函数返回的是一个地址，它指向“空类型” 可以对该函数调用得到的地址进行强制类型转换，如 char* p2 = (char*)func(str, n);    ","description":"","id":226,"section":"c","tags":null,"title":"09. 小结","uri":"https://yorkfish.github.io/review/c/pointer/09-summary/"},{"content":"1. 简介  博客：不求全，方便回忆 本人：野生的，菜鸟一只  2. 参考 / 感谢   C\n “谭爷爷”的绿皮书 正月点灯笼(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门    C++\n 大雪菜(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门    LaTeX\n 跟着宁哥学物理(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门 奇乐编程学院(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门 LaTeX_工作室(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门 xiaoxie5002(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门    Python\n 刘大拿老师 \u0026gt;\u0026gt;\u0026gt; 传送门 麦叔编程(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门 莫烦Python(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门 棋子、棋子(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门 DavyCloud(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门    Regular Expression\n 胶囊大人(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门    Web\n W3school \u0026gt;\u0026gt;\u0026gt; 传送门 宇哥 \u0026gt;\u0026gt;\u0026gt; 传送门    ","description":"YorkFish about page","id":227,"section":"","tags":null,"title":"About","uri":"https://yorkfish.github.io/review/about/"},{"content":" 这里的“三体”是指  粗体 斜体 粗斜体    1. 示例与效果   示例\n **左右各两个星号是粗体效果** *左右各一个星号是斜体效果* ***左右各三个星号是粗斜体效果***    效果\n 左右各两个星号是粗体效果 左右各一个星号是斜体效果 左右各三个星号是粗斜体效果    2. 说明  * 可用 _ 代替  ","description":"","id":228,"section":"markdown","tags":null,"title":"10. “三体”","uri":"https://yorkfish.github.io/review/markdown/10-emphasis/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-show\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .box1{ width: 200px; height: 200px; background: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;!-- a --\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;button @click=\u0026#34;show\u0026#34;\u0026gt;show\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34; v-show=\u0026#34;flag\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { flag: false, }, methods: { show: function(){ // this.flag = true;  this.flag = ~this.flag; // this.flag = !this.flag; 也行  } } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   说明  与元素的 display 属性有紧密的关联  ","description":"","id":229,"section":"web","tags":null,"title":"10. v-show","uri":"https://yorkfish.github.io/review/web/vue/10-v-show/"},{"content":"样式操作  形式：标签对象.style.css属性名 = \u0026quot;值\u0026quot;; // 改变标签对象的样式 示例：id.style.color = \u0026quot;red\u0026quot;; 注意  属性名相当于变量名 若 css属性名 中含有双拼词（形如 font-size），要改成小驼峰（形如 fontSize）    文本操作  形式：标签对象.innerHTML = \u0026quot;内容\u0026quot;; // 在标签对象内放置指定内容 获取一般使用 innerText  表单中值的操作  形式  标签对象.value; // 获取标签对象的 value 值 标签对象.value = \u0026quot;值\u0026quot;; // 设置标签对象的 value 值    ","description":"元素操作","id":230,"section":"web","tags":null,"title":"10. Element Operation","uri":"https://yorkfish.github.io/review/web/javascript/10-element-operation/"},{"content":" 块元素 内联元素 内联块元素   1. 块元素  也称为“行元素” 布局中常用的标签，如 div, p, ul, li, h1~h6, dl, dt, dd, \u0026hellip; 在布局中  支持全部的样式 如果没有设置宽度，默认的宽度为父级宽度的 100% 盒子占据一行，即使设置了宽度，也一样独占一行    2. 内联元素  也称为“行内元素” 布局中常用的标签，如 a, span, em, b, strong, i, \u0026hellip; 在布局中  支持部分样式，如 margin 的左右值 不支持 width, heigh 属性 宽高由内容决定/撑开 不独占一行 盒子并在一行 代码换行会产生一个空格的间距 子元素是内联元素 父元素可以  用 text-align 属性设置子元素水平对齐方式 用 line-height 属性值设置垂直对齐方式      3. 内联块元素  也称“内块元素” 是新增的元素类型 现有元素没有归于此类别的 img 和 input 元素的行为类似这种元素，但是它们归类于内联元素 在布局中  支持全部样式 如果没有设置宽高，宽高由内容决定 盒子并在一行 代码换行，盒子会产生间距 子元素是内联块元素 父元素可以  用 text-align 属性设置子元素水平对齐方式 用 line-height 属性值设置子元素垂直对齐方式      举例 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;box\u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;内联元素不独占一行\u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  *{ width: 500px; height: 100px; } .box{ /* 块级元素 */ background: orange; margin: 20px; padding: 20px; text-align: center; /* 文字水平居中 */ line-height: 100px; /* 设置行高 */ } span{ /* 内联元素 */ background-color: red; margin: 20px; padding: 20px; background: yellow; } input{ /* 行内块元素 */ width: 100px; margin: 20px; padding: 10px; }   \u0026gt;\u0026gt;\u0026gt;\n","description":"三种元素","id":231,"section":"web","tags":null,"title":"10. 3 Elements","uri":"https://yorkfish.github.io/review/web/css/10-3-elements/"},{"content":"1. 常用标签    标签 作用     b 加粗   strong 具有强调意义   i 斜体   em 斜体，具有强调意义    2. 示例与效果 示例 1 2 3 4  \u0026lt;b\u0026gt;加粗\u0026lt;/b\u0026gt; \u0026lt;br\u0026gt; \u0026lt;strong\u0026gt;着重\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt; \u0026lt;i\u0026gt;斜体\u0026lt;/i\u0026gt; \u0026lt;br\u0026gt; \u0026lt;em\u0026gt;强调\u0026lt;/em\u0026gt;   效果 加粗\n着重\n斜体\n强调\n","description":"文本标签","id":232,"section":"web","tags":null,"title":"10. Text Label","uri":"https://yorkfish.github.io/review/web/html/10-text-label/"},{"content":" empty() size() begin(), end() push_front(), push_back() pop_front(), pop_back() emplace_front(), emplace_back() insert() sort() merge() remove() unique()   1. 简介  在任意位置插入与删除一个元素时间是固定的 优点：元素可快速插入与删除 缺点：不能随机访问 插入或删除元素之后，迭代器指向的元素不变，不移动已有元素，只修改链表信息  forword_list  C++11 新添加的容器类 主要实现了单向链表，功能较少，但比较简单 只需要正向迭代器 是不可逆转容器  2. 举例 例1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;iostream\u0026gt;#include \u0026lt;list\u0026gt; using namespace std; int main() { list\u0026lt;int\u0026gt; li; li.push_back(2); li.push_front(1); li.emplace_front(0); // 主要用于插入自定义的 struct  li.emplace_back(3); li.insert(++ li.begin(), 6); // 增删 O(1)，查询 O(n)  for (auto tmp : li) cout \u0026lt;\u0026lt; tmp \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n0 6 1 2 3 例2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include \u0026lt;iostream\u0026gt;#include \u0026lt;list\u0026gt; using namespace std; void print_list(list\u0026lt;int\u0026gt;\u0026amp; arr) { for (int x : arr) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; } int main() { list\u0026lt;int\u0026gt; a{1, 9, 3, 7, 2, 5, 8}; a.sort(); // 使用 \u0026lt; 排序，时间复杂度 O(nlogn)  print_list(a); list\u0026lt;int\u0026gt; b{3, 4, 5, 6}; a.merge(b); // 将 b 归并到 a，必须是两个排序链表，线性时间复杂度  print_list(a); a.remove(5); // 删除所有的 5  print_list(a); list\u0026lt;int\u0026gt; c{0, 0, 0}; a.splice(a.begin(), c); // (pos, list) 将 c 加到 a 之前，时间复杂度为固定时间  print_list(a); a.unique(); // 去重，线性时间  print_list(a); return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 5 7 8 9 1 2 3 3 4 5 5 6 7 8 9 1 2 3 3 4 6 7 8 9 0 0 0 1 2 3 3 4 6 7 8 9 0 1 2 3 4 6 7 8 9 ","description":"双向链表","id":233,"section":"cpp","tags":null,"title":"10. list","uri":"https://yorkfish.github.io/review/cpp/stl/10-list/"},{"content":"1. 一些概念  和 C 相比  多了一个“构造函数” C 需要使用 struct struct_name var_name; C++ 只需使用 struct_name var_name;   可以添加 private 使成员变量变成私有的  2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include \u0026lt;iostream\u0026gt; using namespace std; struct Student { int age, blogs; double height; // 构造函数，名字与结构体的一致  Student() {} // 空构造函数，默认自动给出，若有自定义的构造函数，则不主动给出  // 构造函数可以有多个  Student(int _age) {} Student(int _age, double _height) : age(_age), height(_height) {} // 初始化，把 _age 赋给 age ...  Student(int _age, double _height, int _blogs) { age = _age; height = _height; blogs = _blogs; } }; int main() { Student st1; Student st2 = {18, 180}; cout \u0026lt;\u0026lt; st2.blogs \u0026lt;\u0026lt; endl; Student st3 = {18, 180, 100}; cout \u0026lt;\u0026lt; st3.blogs \u0026lt;\u0026lt; endl; Student st4(18, 180, 100); return 0; }   \u0026gt;\u0026gt;\u0026gt;\n65535\r100\r","description":"结构体","id":234,"section":"cpp","tags":null,"title":"10. struct","uri":"https://yorkfish.github.io/review/cpp/10-struct/"},{"content":"Python3-re: \u0026gt;\u0026gt;\u0026gt; 传送门\r 1. 必要的导入 1  \u0026gt;\u0026gt;\u0026gt; import re   2. 临时测试  findall  1 2 3  \u0026gt;\u0026gt;\u0026gt; re.findall(\u0026#34;york\u0026#34;, \u0026#34;york yorkfish\u0026#34;) # 方法有许多，这种比较方便 [\u0026#39;york\u0026#39;, \u0026#39;york\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   3. match \u0026amp; finditer match 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; re.match(\u0026#34;\\d+\u0026#34;, \u0026#34;123 yorkfish\u0026#34;) \u0026lt;re.Match object; span=(0, 3), match=\u0026#39;123\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; re.match(\u0026#34;\\d+\u0026#34;, \u0026#34;yorkfish 123\u0026#34;) \u0026gt;\u0026gt;\u0026gt; re.match(\u0026#34;\\d+\u0026#34;, \u0026#34;yorkfish 123\u0026#34;) is None # 一般，匹配不到会返回 None True \u0026gt;\u0026gt;\u0026gt;    match 从字符串开头开始匹配 search 在字符串的任意位置检查匹配项（Perl 的传统），但只返回一个   finditer 1 2 3 4 5  import re it = re.finditer(r\u0026#34;\\d+\u0026#34;, \u0026#34;york 123 fish 456 789\u0026#34;) for m in it: print(m) # m 返回 match 对象   \u0026gt;\u0026gt;\u0026gt;\n\u0026lt;re.Match object; span=(5, 8), match='123'\u0026gt;\r\u0026lt;re.Match object; span=(14, 17), match='456'\u0026gt;\r\u0026lt;re.Match object; span=(18, 21), match='789'\u0026gt;\r4. search 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; re.search(\u0026#34;york\u0026#34;, \u0026#34;york yorkfish\u0026#34;) \u0026lt;re.Match object; span=(0, 4), match=\u0026#39;york\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; string = \u0026#34;\u0026#34;\u0026#34; york yorkfish \u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; re.search(r\u0026#34;^york\u0026#34;, string, flags=re.M) \u0026lt;re.Match object; span=(1, 5), match=\u0026#39;york\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;   flags: 指定匹配模式 5. group 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt;\u0026gt;\u0026gt; result = re.search(\u0026#34;(\\w+)-(\\w+)\u0026#34;, \u0026#34;york-fish\u0026#34;) \u0026gt;\u0026gt;\u0026gt; result.groups() (\u0026#39;york\u0026#39;, \u0026#39;fish\u0026#39;) \u0026gt;\u0026gt;\u0026gt; result.group(0) # result.group() 也行 \u0026#39;york-fish\u0026#39; \u0026gt;\u0026gt;\u0026gt; result.group(1) \u0026#39;york\u0026#39; \u0026gt;\u0026gt;\u0026gt; result.group(2) \u0026#39;fish\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; result = re.search(\u0026#34;(?P\u0026lt;name\u0026gt;\\w+) (?P\u0026lt;id\u0026gt;\\w+)\u0026#34;, \u0026#34;yorkfish 123\u0026#34;) \u0026gt;\u0026gt;\u0026gt; result.group(\u0026#34;name\u0026#34;) \u0026#39;yorkfish\u0026#39; \u0026gt;\u0026gt;\u0026gt; result.group(\u0026#34;id\u0026#34;) \u0026#39;123\u0026#39; \u0026gt;\u0026gt;\u0026gt;   6. sub \u0026amp; subn 效果是 replace 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; re.sub(\u0026#39;y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#34;york yorkfish\u0026#34;) # 将后方字符串中的 y 都替换成 Y \u0026#39;York Yorkfish\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; re.subn(\u0026#39;y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#34;york1 york2 york3 york4 york5\u0026#34;) # 默认全部替换；返回二元组 (\u0026#39;York1 York2 York3 York4 York5\u0026#39;, 5) \u0026gt;\u0026gt;\u0026gt; re.subn(\u0026#39;y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#34;york1 york2 york3 york4 york5\u0026#34;, 3) # 可以指定替换次数 (\u0026#39;York1 York2 York3 york4 york5\u0026#39;, 3) \u0026gt;\u0026gt;\u0026gt;   7. split 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; re.split(\u0026#34;[,.;]\u0026#34;, \u0026#34;a,b.c;e\u0026#34;) [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; re.split(r\u0026#34;\\s*[,;?./]\\s*\u0026#34;, \u0026#34;abc, def; ghi? jkl . mno / pqr\u0026#34;) [\u0026#39;abc\u0026#39;, \u0026#39;def\u0026#39;, \u0026#39;ghi\u0026#39;, \u0026#39;jkl\u0026#39;, \u0026#39;mno\u0026#39;, \u0026#39;pqr\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   8. compile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026gt;\u0026gt;\u0026gt; zz = re.compile(\u0026#34;\\d+\u0026#34;) # 保险起见，最好使用 r\u0026#34;\\d\u0026#34; \u0026gt;\u0026gt;\u0026gt; zz.match(\u0026#34;yorkfish 123\u0026#34;) # 相比 Js，形式与 zz.exec(str) 一致，与 str.match(zz) 相反 \u0026gt;\u0026gt;\u0026gt; zz.match(\u0026#34;yorkfish 123\u0026#34;, 9) # 指定起始位置 \u0026lt;re.Match object; span=(9, 12), match=\u0026#39;123\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; zz.match(\u0026#34;yorkfish 123\u0026#34;, 9, 11) # 指定 [开始, 结束) 位置 \u0026lt;re.Match object; span=(9, 11), match=\u0026#39;12\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; p = re.compile(r\u0026#34;\\d+\u0026#34;) \u0026gt;\u0026gt;\u0026gt; m = p.match(\u0026#34;yorkfish 123\u0026#34;, 9) \u0026gt;\u0026gt;\u0026gt; m[0] \u0026#39;123\u0026#39; \u0026gt;\u0026gt;\u0026gt; m.start(0) 9 \u0026gt;\u0026gt;\u0026gt; m.end(0) 12 \u0026gt;\u0026gt;\u0026gt;   1 2 3 4  \u0026gt;\u0026gt;\u0026gt; pattern = re.compile(r\u0026#34;\\d\u0026#34;) \u0026gt;\u0026gt;\u0026gt; pattern.search(\u0026#34;yorkfish123\u0026#34;) \u0026lt;re.Match object; span=(8, 9), match=\u0026#39;1\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;   9. 匹配中文 1 2 3  \u0026gt;\u0026gt;\u0026gt; re.findall(r\u0026#34;[\\u4e00-\\u9fa5]+\u0026#34;, u\u0026#34;你好，我是 yorkfish\u0026#34;) [\u0026#39;你好\u0026#39;, \u0026#39;我是\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   \\u4e00-\\u9fa5 包括了大部分中文，但不是全部，且不包括全角标点 10. 多行注释 1 2 3 4 5 6 7 8 9 10  import re email_regex = re.compile(r\u0026#39;\u0026#39;\u0026#39;( [a-zA-Z0-9._%+-]{6,16} # username @ [a-zA-Z0-9]+([-.][a-zA-Z0-9]+)* # domail name (\\.[a-zA-Z]{2,4}) # dot-something )\u0026#39;\u0026#39;\u0026#39;, re.VERBOSE) result = email_regex.match(\u0026#34;example_example@example.example.com\u0026#34;) print(result)   \u0026gt;\u0026gt;\u0026gt;\n\u0026lt;re.Match object; span=(0, 35), match='example_example@example.example.com'\u0026gt;\r","description":"Python3 场景使用正则","id":235,"section":"regex","tags":null,"title":"10. re-python3","uri":"https://yorkfish.github.io/review/regex/10-re-python3/"},{"content":"例一 数据类型 1 2 3 4 5  import multiprocessing as mp # 简单列举两项 value = mp.Value(\u0026#39;d\u0026#39;, 1) array = mp.Array(\u0026#39;i\u0026#39;, [1, 2, 3])   例二 未加锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import multiprocessing as mp import time def job(v, num): for _ in range(10): time.sleep(0.1) v.value += num print(v.value) def multi_core(): v = mp.Value(\u0026#39;i\u0026#39;, 0) p1 = mp.Process(target=job, args=(v, 1)) p2 = mp.Process(target=job, args=(v, 3)) p1.start() p2.start() p1.join() p2.join() if __name__ == \u0026#34;__main__\u0026#34;: multi_core()   例三 加锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import multiprocessing as mp import time def job(v, num, l): l.acquire() for _ in range(10): time.sleep(0.1) v.value += num print(v.value) l.release() def multi_core(): l = mp.Lock() v = mp.Value(\u0026#39;i\u0026#39;, 0) p1 = mp.Process(target=job, args=(v, 1, l)) p2 = mp.Process(target=job, args=(v, 3, l)) p1.start() p2.start() p1.join() p2.join() if __name__ == \u0026#34;__main__\u0026#34;: multi_core()   ","description":"锁","id":236,"section":"python","tags":null,"title":"10. lock","uri":"https://yorkfish.github.io/review/python/multiprocessing/10-lock/"},{"content":"1. threading 之前的版本  Python2 用的是 thread，Python3 将其改为 _thread 现在很少使用 _thread，不过认识一下也没坏处  例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  import _thread as thread import time def loop1(): ft = time.strftime(\u0026#34;%H:%M:%S\u0026#34;, time.localtime()) print(\u0026#34;Start loop1 at \u0026#34; + ft) time.sleep(4) ft = time.strftime(\u0026#34;%H:%M:%S\u0026#34;, time.localtime()) print(\u0026#34;Stop loop1 at \u0026#34; + ft) def loop2(num): ft = time.strftime(\u0026#34;%H:%M:%S\u0026#34;, time.localtime()) print(\u0026#34;Start loop2 at \u0026#34; + ft) print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; num =\u0026#34;, num) time.sleep(2) ft = time.strftime(\u0026#34;%H:%M:%S\u0026#34;, time.localtime()) print(\u0026#34;Stop loop2 at \u0026#34; + ft) def main(): print(\u0026#34;starting\u0026#34;) # 启动多线程函数为start_new_thead # 第一个参数：需要运行的函数名，第二个参数：函数的参数（使用元组，无参则使用空元组） thread.start_new_thread(loop1, ()) thread.start_new_thread(loop2, (666,)) print(\u0026#34;all done\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() # 需要有 while 语句，保证子线程执行完 while True: time.sleep(1)   \u0026gt;\u0026gt;\u0026gt;\nstarting\rall done\rStart loop1 at 10:30:20\rStart loop2 at 10:30:20\r\u0026gt;\u0026gt;\u0026gt; num = 666\rStop loop2 at 10:30:22\rStop loop1 at 10:30:24\r2. GIL   相关文章：\u0026gt;\u0026gt;\u0026gt; 传送门\n  大部分环境下，默认的 Python 执行环境是 CPython\n  在 CPython 解释器中\n 同一个进程下开启的多线程，同一时刻只能有一个线程执行 无法利用多核优势    JPython 没有 GIL\n  GIL 本质就是一把互斥锁\n 与所有互斥锁的本质一样，都是将并发运行变成串行 以此控制同一时间内共享数据只能被一个任务所修改，进而保证数据安全    在一个 Python 的进程内\n 不仅有主线程或者由该主线程开启的其他线程 还有解释器开启的垃圾回收等解释器级别的线程    ","description":"补充","id":237,"section":"python","tags":null,"title":"10. supplement","uri":"https://yorkfish.github.io/review/python/threading/10-supplement/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;500x300\u0026#34;) window.mainloop()   2. 添加一个 canvas 1 2 3  canvas = tk.Canvas(window, bg=\u0026#34;gray\u0026#34;, width=500, height=250) # ... canvas.pack()   3. 添加图片 1 2  image_file = tk.PhotoImage(file=\u0026#34;test.png\u0026#34;) image = canvas.create_image(0, 0, anchor=\u0026#34;nw\u0026#34;, image=image_file)   ps   Python 3.8 的 tkinter 支持 PGM, PPM, GIF, PNG 四种格式\n  想使用 JPG 格式的话，可以借助 Pillow\n  anchor 属性有如下几种方位\nNR N NE\rW CENTER E\rSW S SE\r  4. 画线 1  line = canvas.create_line(0, 0, 100, 100)   5. 画圆 1  oval = canvas.create_oval(0, 0, 100, 100, fill=\u0026#34;red\u0026#34;)   6. 画扇形 1  arc = canvas.create_arc(0, 0, 100, 100, start=30, extent=120)   7. 画矩形 1  rect = canvas.create_rectangle(0, 0, 200, 100)   8. 移动图形 1 2 3 4 5  def move_down(): canvas.move(rect, 0, 2) # 横坐标移动 0 个单位，纵坐标移动 2 个单位 tk.Button(window, text=\u0026#34;move down\u0026#34;, width=10, command=move_down).pack()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;500x300\u0026#34;) canvas = tk.Canvas(window, bg=\u0026#34;gray\u0026#34;, width=500, height=250) image_file = tk.PhotoImage(file=\u0026#34;ins.gif\u0026#34;) image = canvas.create_image(0, 0, anchor=\u0026#34;nw\u0026#34;, image=image_file) x0, y0, x1, y1 = 100, 100, 200, 200 line = canvas.create_line(x0, y0, x1, y1) oval = canvas.create_oval(x0, y0, x1, y1, fill=\u0026#34;red\u0026#34;) arc = canvas.create_arc(200, 100, 300, 200, start=30, extent=120) rect = canvas.create_rectangle(300, 100, 400, 200) canvas.pack() def move_down(): canvas.move(rect, 0, 2) # 横坐标移动 0 个单位，纵坐标移动 2 个单位 tk.Button(window, text=\u0026#34;move down\u0026#34;, width=10, command=move_down).pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"画布","id":238,"section":"python","tags":null,"title":"10. Canvas","uri":"https://yorkfish.github.io/review/python/tkinter/10-canvas/"},{"content":"1. 简介  np.hstack() 与 np.vstack() 无法指定 axis  2. 操作 导入 1  import numpy as np   创建 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2], [3, 4]]) \u0026gt;\u0026gt;\u0026gt; b = np.array([[5, 6]]) \u0026gt;\u0026gt;\u0026gt; print(a) [[1 2] [3 4]] \u0026gt;\u0026gt;\u0026gt; print(b) [[5 6]] \u0026gt;\u0026gt;\u0026gt;   显示形状 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a.shape (2, 2) \u0026gt;\u0026gt;\u0026gt; b.shape (1, 2) \u0026gt;\u0026gt;\u0026gt;   连接 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; c = np.concatenate((a, b)) \u0026gt;\u0026gt;\u0026gt; print(c) [[1 2] [3 4] [5 6]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d = np.concatenate((a, b.T), axis=1) \u0026gt;\u0026gt;\u0026gt; print(d) [[1 2 5] [3 4 6]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":239,"section":"python","tags":null,"title":"10. concatenate","uri":"https://yorkfish.github.io/review/python/numpy/10-concatenate/"},{"content":"例一 导入时避免使用相对路径   文件结构\nD:\\test\rprints.py\rimport_issue.py\r  import_issue.py\n1  from .prints import *     运行结果\n...\rImportError: attempted relative import with no known parent package\r...\r  说明\n . 所表示的根路径也是 '__main__' 的值 在入口文件中，应该避免使用相对路径进行模块导入    例二 查看模块信息 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; import time \u0026gt;\u0026gt;\u0026gt; time \u0026lt;module \u0026#39;time\u0026#39; (built-in)\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random \u0026lt;module \u0026#39;random\u0026#39; from \u0026#39;D:\\\\anaconda3\\\\lib\\\\random.py\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;   例三 查看模块路径 1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; __import__(\u0026#39;random\u0026#39;) \u0026lt;module \u0026#39;random\u0026#39; from \u0026#39;D:\\\\anaconda3\\\\lib\\\\random.py\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import http.server \u0026gt;\u0026gt;\u0026gt; http.server \u0026lt;module \u0026#39;http.server\u0026#39; from \u0026#39;D:\\\\anaconda3\\\\lib\\\\http\\\\server.py\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;   例四 一行导入并使用 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; __import__(\u0026#39;random\u0026#39;).randint(1, 10) 6 \u0026gt;\u0026gt;\u0026gt; __import__(\u0026#39;random\u0026#39;).randint(1, 10) 1 \u0026gt;\u0026gt;\u0026gt; random Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; NameError: name \u0026#39;random\u0026#39; is not defined \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random \u0026lt;module \u0026#39;random\u0026#39; from \u0026#39;D:\\\\anaconda3\\\\lib\\\\random.py\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":240,"section":"python","tags":null,"title":"10. import","uri":"https://yorkfish.github.io/review/python/basics/10-import/"},{"content":"例一 1 2 3 4  lst_a = [\u0026#39;a1\u0026#39;, \u0026#39;b1\u0026#39;, \u0026#39;c1\u0026#39;] lst_b = [\u0026#39;a2\u0026#39;, \u0026#39;b2\u0026#39;, \u0026#39;c2\u0026#39;] for a, b in zip(lst_a, lst_b): print(a, b)   \u0026gt;\u0026gt;\u0026gt;\na1 a2\rb1 b2\rc1 c2\r例二  有点像木桶原理，多出的数据不作处理  1 2 3 4  lst_c = [\u0026#39;a3\u0026#39;, \u0026#39;b3\u0026#39;, \u0026#39;c3\u0026#39;, \u0026#39;d3\u0026#39;, \u0026#39;e3\u0026#39;] lst_d = [\u0026#39;a4\u0026#39;, \u0026#39;b4\u0026#39;, \u0026#39;c4\u0026#39;] for c, d in zip(lst_c, lst_d): print(c, d)   \u0026gt;\u0026gt;\u0026gt;\na3 a4\rb3 b4\rc3 c4\r","description":"","id":241,"section":"python","tags":null,"title":"10. zip()","uri":"https://yorkfish.github.io/review/python/bif/10-zip/"},{"content":"公共部分 1 2 3  class Hero(object): def __init__(self, name): self.name = name   例一 1 2 3 4 5 6 7 8  class AD1(Hero): def __init__(self, name, gender): self.name = name self.gender = gender ashe = AD1(\u0026#34;艾希\u0026#34;, \u0026#34;female\u0026#34;) print(ashe.__dict__)   \u0026gt;\u0026gt;\u0026gt;\n{'name': '艾希', 'gender': 'female'}\r例二 1 2 3 4 5 6 7 8  class AD2(Hero): def __init__(self, name, gender): Hero.__init__(self, name) self.gender = gender jinx = AD2(\u0026#34;金克丝\u0026#34;, \u0026#34;female\u0026#34;) print(jinx.__dict__)   \u0026gt;\u0026gt;\u0026gt;\n{'name': '金克丝', 'gender': 'female'}\r例三 1 2 3 4 5 6 7 8  class AD3(Hero): def __init__(self, name, gender): super(AD3, self).__init__(name) self.gender = gender vayne = AD3(\u0026#34;薇恩\u0026#34;, \u0026#34;female\u0026#34;) print(vayne.__dict__)   \u0026gt;\u0026gt;\u0026gt;\n{'name': '薇恩', 'gender': 'female'}\r","description":"","id":242,"section":"python","tags":null,"title":"10. 继承","uri":"https://yorkfish.github.io/review/python/class/10-inheritance/"},{"content":"1. 声明外部变量  一般的做法：将外部变量的定义放在引用它的所有函数之前 类型名可写可不写  写：extern int A, B; 不写：extern A, B;，会有 warning    2. 编译时的顺序  先在文本中找外部变量的定义  如果找到，就在文本文件中扩展作用域 如果找不到，就在连接时从其他文件中找外部变量的定义   若从其他文件中找外部变量的定义  如果从其他文件中找到了，就将作用域扩展到本文件 如果再找不到，就按出错处理    3. 举例 例一   main.c\n1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; extern int count; int main() { printf(\u0026#34;%d\\n\u0026#34;, count); return 0; }     test.c\n1  int count = 100;     编译命令：gcc main.c test.c -o main\n  运行结果：100\n  例二   更改例一的 test.c\n1  static int count = 100;     其他不变\n  编译结果\n undefined reference to `count'\r   解释\n 用 static 声明，只能用于本文件 这种外部变量称为“静态外部变量”    4. 使用  若干个人独立地在其设计的文件中使用相同的外部变量名，若要不受影响，就在每个文件中的外部变量前加上 static 如果其他文件不需要引用本文件的外部变量，可以对本文件中的外部变量都加上 static，成为静态外部变量，以免被其他文件误用  5. 说明   静态存储方式（存放在静态存储区中）\n  动态存储方式（存放在动态存储区中）\n  不要误认为对外部变量加 static 声明后才是静态存储方式，而不加 static 的是动态存储\n 其实加与不加都是静态存储方式 只是作用范围不同而已 都是在编译时分配内存的    ","description":"","id":243,"section":"c","tags":null,"title":"10. extern","uri":"https://yorkfish.github.io/review/c/function/10-extern/"},{"content":"1. 说明  若格式中有两个空格，应对应给到两个或更多的空格 输入数据时，遇到以下情况，认为结束  遇空格、回车、跳格键 超过指定宽度 非法输入    2. 举例 例一 因空格中断输入 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { char str[13]; scanf(\u0026#34;%s\u0026#34;, str); printf(\u0026#34;%s\\n\u0026#34;, str); return 0; }    Input: How are you? Output: How  例二 因设定值中断输入 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { char str[13]; scanf(\u0026#34;%6s\u0026#34;, str); printf(\u0026#34;%s\\n\u0026#34;, str); return 0; }    Input: How_are_you? Output: How_ar  例三 因格式不符导致结果有误 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { int a, b, c; scanf(\u0026#34;%d, %d, %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); printf(\u0026#34;a = %d, b = %d, c = %d\\n\u0026#34;, a, b, c); return 0; }    Input: 1,2,3 Output: a = 1, b = 30, c = 0 Explain: 没有按照 scanf() 中的设定输入，少了空格  ","description":"","id":244,"section":"c","tags":null,"title":"10. scanf","uri":"https://yorkfish.github.io/review/c/basics/10-scanf/"},{"content":"   分类 函数名 功能     打开文件 fopen() 打开文件   关闭文件 fclose() 关闭文件   文件定位 fseek() 改变文件位置指针的位置    rewind() 使文件位置指针重新至于文件开头    ftell() 返回文件位置指针的当前值   文件读写 fgetc(), getc() 从指定文件取得一个字符    fputc(), putc() 把字符输出到指定文件    fgets() 从指定文件读取字符串    fputs() 把字符串输出到指定文件    getw() 从指定文件读取一个字 int    putw() 把一个字 int 输出到指定文件    fread() 从指定文件中读取数据项    fwrite() 把数据项写到指定文件    fscanf() 从指定文件按格式输入数据    fprintf() 按指定格式将数据写到指定文件中   文件状态 feof() 若到文件末尾，函数值为真（非 0）    ferror() 若对文件操作出错，函数值为真    clearerr() 使 ferror 和 feof 函数值置零    ","description":"","id":245,"section":"c","tags":null,"title":"10. 小结","uri":"https://yorkfish.github.io/review/c/file/10-summary/"},{"content":"1. 使用场景  如果一个变量只有几种可能的值，则可以定义为枚举类型 变量的值只限于列举出来的值的范围  2. 一般定义形式 enum weekday {sun, mon, tue, wed, thu, fri, sat};\n3. 用法 例一  C 编译中，对枚举元素按常量处理，故称枚举常量 因为是常量，所以不能像变量那样对它们赋值 枚举元素作为常量是有值的，按顺序，默认为 0, 1, 2, \u0026hellip;  1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; enum weekday {sun, mon, tue, wed, thu, fri, sat}; int main() { enum weekday weekend, workday; weekend = sun; workday = mon; printf(\u0026#34;%d, %d\\n\u0026#34;, weekend, workday); // 0, 1  return 0; }   例二  可以改变枚举元素的值  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; enum weekday { sun = 7, mon = 1, tue, wed, thu, fri, sat } weekend, workday; // tue = 2, ...  int main() { weekend = sun; workday = tue; printf(\u0026#34;%d, %d\\n\u0026#34;, weekend, workday); // 7, 2  return 0; }   例三  枚举值可以用来作判断比较 一个整数不能直接赋给一个枚举变量，需要先进行强制类型转换  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt; typedef enum weekday { sun = 7, mon = 1, tue, wed, thu, fri, sat } Weekday; int main() { Weekday weekend = sun; Weekday workday1 = (Weekday)1; Weekday workday2 = (Weekday)(5-3); // 相当于 \u0026#34;workday = tue;\u0026#34;  if (workday1) { printf(\u0026#34;%d, %d\\n\u0026#34;, weekend, workday2); // 7, 2  } return 0; }   ","description":"","id":246,"section":"c","tags":null,"title":"10. 枚举","uri":"https://yorkfish.github.io/review/c/struct-union-enum/10-enum/"},{"content":"1. 注脚 示例与效果   示例\n点击句末的注脚试试[^one]\r[^one]: 这个可以放到文中，但有些平台不支持；保险起见，放在文末吧\r  效果\n点击句末的注脚试试1\n  说明  注脚解释的冒号是英文冒号，且冒号后的一个空格不能省略  2. 上下标 用法  上标：借助 HTML 的标签 \u0026lt;sup\u0026gt; 下标：借助 HTML 的标签 \u0026lt;sub\u0026gt;  示例与效果   用法\n 2\u0026lt;sup\u0026gt;10\u0026lt;/sup\u0026gt; H\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;O    效果\n 210 H2O     这个可以放到文中，但有些平台不支持；保险起见，放在文末吧 \u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":247,"section":"markdown","tags":null,"title":"11. 注脚与上下标","uri":"https://yorkfish.github.io/review/markdown/11-footnotes-and-sup-sub/"},{"content":" ~, \u0026amp;, |, ^ \u0026laquo;, \u0026raquo; ==, != []   size() count() test() any() none() all() set() set(k, v) set(k) reset() flip() flip(k) to_string() to_ulong() to_ullong()   定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #include \u0026lt;iostream\u0026gt;#include \u0026lt;bitset\u0026gt; using namespace std; int main() { bitset\u0026lt;8\u0026gt; s1; // 无参构造，长度为 8，默认每一位均为 0  bitset\u0026lt;4\u0026gt; s2(6); // 长度为 4，二进制保存，前面补 0  bitset\u0026lt;2\u0026gt; s3(6); // 长度为 2，110 取后两位  string str = \u0026#34;110111\u0026#34;; bitset\u0026lt;4\u0026gt; s4(str); // 长度为 4，取前四位  cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // 00000000  cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; // 0110  cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; // 10  cout \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; // 1101  return 0; }   ps  构造时需要指定长度 用字符串构造时，字符串只能包含 \u0026lsquo;0\u0026rsquo; 或 \u0026lsquo;1\u0026rsquo; ，否则会抛异常 有参构造时  若参数的二进制表示比指定长度小，则在前面补 0 若参数的二进制表示比指定长度大，“从小往大”看  参数为字符串时，从索引值小处开始分割，取够长度为止 参数为整数时，从低位开始分割，取够长度为止      二进制位操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;iostream\u0026gt;#include \u0026lt;bitset\u0026gt; using namespace std; int main() { bitset\u0026lt;4\u0026gt; foo(string(\u0026#34;1001\u0026#34;)); bitset\u0026lt;4\u0026gt; bar(string(\u0026#34;0011\u0026#34;)); cout \u0026lt;\u0026lt; (~foo) \u0026lt;\u0026lt; endl; // 0110 按位取反  cout \u0026lt;\u0026lt; (foo \u0026amp; bar) \u0026lt;\u0026lt; endl; // 0001  cout \u0026lt;\u0026lt; (foo | bar) \u0026lt;\u0026lt; endl; // 1011  cout \u0026lt;\u0026lt; (foo ^ bar) \u0026lt;\u0026lt; endl; // 1010  cout \u0026lt;\u0026lt; (foo \u0026lt;\u0026lt; 2) \u0026lt;\u0026lt; endl; // 0100 低位补 0  cout \u0026lt;\u0026lt; (foo \u0026gt;\u0026gt; 1) \u0026lt;\u0026lt; endl; // 0100 高位补 0  cout \u0026lt;\u0026lt; (foo == bar) \u0026lt;\u0026lt; endl; // false  cout \u0026lt;\u0026lt; (foo != bar) \u0026lt;\u0026lt; endl; // true  return 0; }   访问元素  类似数组  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;iostream\u0026gt;#include \u0026lt;bitset\u0026gt; using namespace std; int main() { bitset\u0026lt;4\u0026gt; foo(\u0026#34;1011\u0026#34;); cout \u0026lt;\u0026lt; foo[0] \u0026lt;\u0026lt; endl; // 1  cout \u0026lt;\u0026lt; foo[1] \u0026lt;\u0026lt; endl; // 1  cout \u0026lt;\u0026lt; foo[2] \u0026lt;\u0026lt; endl; // 0 从右往左索引  foo[2] = 1; cout \u0026lt;\u0026lt; foo[2] \u0026lt;\u0026lt; endl; // 1  return 0; }   一些函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #include \u0026lt;iostream\u0026gt;#include \u0026lt;bitset\u0026gt; using namespace std; int main() { bitset\u0026lt;4\u0026gt; foo(\u0026#34;1011\u0026#34;); cout \u0026lt;\u0026lt; foo.size() \u0026lt;\u0026lt; endl; // 4 返回 bitset 的大小  cout \u0026lt;\u0026lt; foo.count() \u0026lt;\u0026lt; endl; // 3 返回有多少个 1  cout \u0026lt;\u0026lt; foo.test(0) \u0026lt;\u0026lt; endl; // true 查询索引处的元素是 0 是 1  cout \u0026lt;\u0026lt; foo.test(2) \u0026lt;\u0026lt; endl; // false  cout \u0026lt;\u0026lt; foo.any() \u0026lt;\u0026lt; endl; // true 判断是否至少有一个 1  cout \u0026lt;\u0026lt; foo.none() \u0026lt;\u0026lt; endl; // false 判断是否全为 0  cout \u0026lt;\u0026lt; foo.all() \u0026lt;\u0026lt; endl; // false 判断是否全为 １  return 0; }   ps  test() 会检查越界 [] 访问元素不会经过检查  另一些函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #include \u0026lt;iostream\u0026gt;#include \u0026lt;bitset\u0026gt; using namespace std; int main() { bitset\u0026lt;8\u0026gt; foo (\u0026#34;11001011\u0026#34;); cout \u0026lt;\u0026lt; foo.set() \u0026lt;\u0026lt; endl; // 11111111 所有位置 1  cout \u0026lt;\u0026lt; foo.set(3, 0) \u0026lt;\u0026lt; endl; // 11110111 将第 3 位变成 0  cout \u0026lt;\u0026lt; foo.set(3) \u0026lt;\u0026lt; endl; // 11111111 将第 3 位变成 1  cout \u0026lt;\u0026lt; foo.reset(4) \u0026lt;\u0026lt; endl; // 11101111 将第 4 位变成 0  cout \u0026lt;\u0026lt; foo.reset() \u0026lt;\u0026lt; endl; // 00000000 所有位置 0  cout \u0026lt;\u0026lt; foo.flip() \u0026lt;\u0026lt; endl; // 11111111 等价于 ~  cout \u0026lt;\u0026lt; foo.flip(2) \u0026lt;\u0026lt; endl; // 11111011 将第 2 位取反  return 0; }    如果越界，会抛出异常  一些类型转换函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;iostream\u0026gt;#include \u0026lt;bitset\u0026gt; using namespace std; int main() { bitset\u0026lt;8\u0026gt; foo(\u0026#34;11001011\u0026#34;); string s = foo.to_string(); // 将 bitset 转成 string  unsigned long a = foo.to_ulong(); // 转成 unsigned long  unsigned long long b = foo.to_ullong(); // 转成 unsigned long long  cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // 11001011  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 203  cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; // 203  return 0; }   ","description":"压位","id":248,"section":"cpp","tags":null,"title":"11. bitset","uri":"https://yorkfish.github.io/review/cpp/stl/11-bitset/"},{"content":"举例 \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;filter\u0026lt;/title\u0026gt;\r\u0026lt;script src=\u0026quot;./vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;style\u0026gt;\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r{{msg}} \u0026lt;br\u0026gt;\r{{msg|capitalize}} \u0026lt;br\u0026gt;\r{{price}} \u0026lt;br\u0026gt;\r{{price|currency}} \u0026lt;br\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rnew Vue({\rel: \u0026quot;#app\u0026quot;,\rdata: {\rmsg: \u0026quot;hello\u0026quot;,\rprice: 20\r},\rfilters: {\r// 官网的例子\rcapitalize: function(val){\rreturn val.charAt(0).toUpperCase() + val.slice(1);\r},\rcurrency: function(val){\rreturn val + \u0026quot; $\u0026quot;;\r}\r}\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r","description":"过滤器","id":249,"section":"web","tags":null,"title":"11. filter","uri":"https://yorkfish.github.io/review/web/vue/11-filter/"},{"content":"计时事件  设定一个间隔，时间到了后准时执行代码，此为“计时事件”  作用  制作动画 异步操作  类型  单次定时器 多次定时器  语法  setInterval() 和 setTimeout() 是 Window 对象的两个方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  /* setTimeout 设置单次的定时器 clearTimeout 关闭单次的定时器 setInterval 设置多次的定时器 clearInterval 关闭多次的定时器 */ function timeGoesBy() { console.log(\u0026#34;Time flies by.\u0026#34;); } var time1 = setTimeout(timeGoesBy, 5000); var time2 = setInterval(timeGoesBy, 500); setTimeout(function() { clearTimeout(time1); console.log(\u0026#34;time1 has no chance to carry it out.\u0026#34;); clearInterval(time2); console.log(\u0026#34;time2 was executed 6 times.\u0026#34;); }, 3000);   \u0026gt;\u0026gt;\u0026gt;\n⑥ Time flies by.\rtime1 has no chance to carry it out.\rtime2 was executed 6 times.\r","description":"定时器","id":250,"section":"web","tags":null,"title":"11. Timer","uri":"https://yorkfish.github.io/review/web/javascript/11-timer/"},{"content":"display  作用：设置元素的类型及隐藏 常用的属性  none 元素隐藏且不占位置 block 元素以块元素显示 inline 元素以内联元素显示 inline-block 元素以内联块元素显示（此属性在 Html5 中被弃了，不过还能使用）    举例 例1 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;box3\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  div{ width: 100px; height: 100px; display:inline; /* 将块元素转换成内联元素，效果见截图1 */ /*display:inline-block; 将块元素转换成内联块元素，效果见截图2 */ } .box1{ background: red; } .box2{ background: green; } .box3{ background: blue; }     截图1\n  截图2\n  例2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; display 常用的属性 \u0026lt;span\u0026gt;1. none 元素隐藏且不占位置\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;2. block 以块元素显示\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;3. inline 以内联元素显示\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;4. inline-block 以内联块元素显示\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8  span{ width: 150px; height: 100px; background: pink; display:block; /* 将内联元素转换成块元素，效果见截图3 */ /*display: inline-block; 将内联元素转换成内联块元素，效果见截图4 */ }     截图3\n  截图4\n  例3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box1 box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;!-- 类可以取多个名字 --\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt; \u0026lt;span\u0026gt;我显示了！\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  .box1{ width: 100px; height: 100px; background-color: red; display: none; /* 让元素隐藏，并且隐藏元素不会再占据位置 */ } .box2{ display:block; /* block 把元素转换成块元素，还可以显示隐藏的元素 */ } .box3{ width: 100px; height: 100px; background: green; } .box3 span{ display: none; } .box3:hover span{ /* 当鼠标移入 box3 的时候，让字体显示 */ color: pink; text-align: center; line-height: 100px; font-size: 20px; display: block; }     截图5\n  截图6\n  ","description":"元素的转换","id":251,"section":"web","tags":null,"title":"11. display","uri":"https://yorkfish.github.io/review/web/css/11-display/"},{"content":"1. \u0026lt;span\u0026gt; 简介  一般 span 标签是配合 css 使用的，用以设置文本中的一部分内容  2. 示例与效果 示例 \u0026lt;span style=\u0026quot;color:red\u0026quot;\u0026gt;红色\u0026lt;/span\u0026gt;\n效果 红色\n","description":"无语义行级标签","id":252,"section":"web","tags":null,"title":"11. Line Level Element","uri":"https://yorkfish.github.io/review/web/html/11-line-level-element-without-semantics/"},{"content":"1. 一些概念  类中的变量和函数被统一称为类的成员变量 private 的内容是私有成员变量，在类的外部不能访问 public 的内容是公有成员变量，在类的外部可以访问 类与结构体的作用是一样的，只不过  类默认是 private 结构体默认是 public    2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000; class Person { private: // 如果不写 private，默认是 private  int age; double height = 175; public: string name; void introduce() { cout \u0026lt;\u0026lt; \u0026#34;Hi, I am \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#39;.\u0026#39; \u0026lt;\u0026lt; endl; } void set_age(int a) { age = a; } int get_age() { return age; } void grow_taller(double h) { height += h; cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;\u0026#39;s height: \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; endl; } private: string blog_posts[N]; }; // } york, persons[100]; // 这个也可以像结构体那样用  int main() { Person york; york.name = \u0026#34;YorkFish\u0026#34;; york.introduce(); cout \u0026lt;\u0026lt; york.name \u0026lt;\u0026lt; endl; york.set_age(18); // cout \u0026lt;\u0026lt; york.age \u0026lt;\u0026lt; endl; // error: \u0026#39;int Person::age\u0026#39; is private within this context  cout \u0026lt;\u0026lt; york.get_age() \u0026lt;\u0026lt; endl; york.grow_taller(5.5); return 0; }   \u0026gt;\u0026gt;\u0026gt;\nHi, I am YorkFish.\rYorkFish\r18\rYorkFish's height: 180.5\r","description":"类","id":253,"section":"cpp","tags":null,"title":"11. class","uri":"https://yorkfish.github.io/review/cpp/11-class/"},{"content":"嫌虚拟机打开慢，可以使用 cmder, cygwin, gitbash 之类的工具 1. awk  形式：york$ awk '/正则表达式/{print($0)}' test.txt 功能：用相应的正则表达式去匹配文档 test.txt 中的内容  2. grep  形式：york$ grep 正则表达式 test.txt 功能：用相应的正则表达式去匹配文档 test.txt 中的内容 补充：可以配合 wc 命令进行统计  ","description":"临时测试用","id":254,"section":"regex","tags":null,"title":"11. re-terminal","uri":"https://yorkfish.github.io/review/regex/11-re-terminal/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;do 0\u0026#34;, bg=\u0026#34;yellow\u0026#34;) l.pack() window.mainloop()   2. 添加 menubar 1 2 3 4 5  menubar = tk.Menu(window) filemenu = tk.Menu(menubar, tearoff=0) menubar.add_cascade(label=\u0026#34;File\u0026#34;, menu=filemenu, underline=1) filemenu.add_command(label=\u0026#34;New\u0026#34;, command=do_job) window.config(menu=menubar) # 将 window 的 menu 设置为自定义的 menubar   ps  tearoff 默认值为 1  1: 可分 0: 不可分   underline 为 1 的选项，按下 Alt 时，有下划线提示，对应快捷键  3. 添加一个 submenu 1 2 3 4  submenu = tk.Menu(filemenu, tearoff=0) filemenu.add_cascade(label=\u0026#34;Import\u0026#34;, menu=submenu) submenu.add_command(label=\u0026#34;submenu1\u0026#34;, command=do_job) submenu.add_command(label=\u0026#34;submenu2\u0026#34;, command=do_job)   4. 添加一个 separator 1  filemenu.add_separator()   5. 添加一个 quit 1  filemenu.add_command(label=\u0026#34;Exit\u0026#34;, command=window.quit) # window.quit 是 tkinter 自带的   6. do_job 方法  需要写在调用它语句的上方  1 2 3 4 5 6 7 8 9  l = tk.Label(window, text=\u0026#34;do 0\u0026#34;, bg=\u0026#34;yellow\u0026#34;) l.pack() counter = 0 def do_job(): global counter counter += 1 l.config(text=\u0026#34;do \u0026#34; + str(counter))   ps  config 可以改变参数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;do 0\u0026#34;, bg=\u0026#34;yellow\u0026#34;) l.pack() counter = 0 def do_job(): global counter counter += 1 l.config(text=\u0026#34;do \u0026#34; + str(counter)) menubar = tk.Menu(window) filemenu = tk.Menu(menubar, tearoff=0) # 0: 不可分，1: 可分 menubar.add_cascade(label=\u0026#34;File\u0026#34;, menu=filemenu, underline=1) # menubar 添加 File 栏目 filemenu.add_command(label=\u0026#34;New\u0026#34;, command=do_job) filemenu.add_command(label=\u0026#34;Open\u0026#34;, command=do_job) filemenu.add_command(label=\u0026#34;Save\u0026#34;, command=do_job) filemenu.add_separator() # 分割线 filemenu.add_command(label=\u0026#34;Exit\u0026#34;, command=window.quit) editmenu = tk.Menu(menubar, tearoff=0) menubar.add_cascade(label=\u0026#34;Edit\u0026#34;, menu=editmenu, underline=1) # menubar 添加 Edit 栏目 editmenu.add_command(label=\u0026#34;Cut\u0026#34;, command=do_job) editmenu.add_command(label=\u0026#34;Copy\u0026#34;, command=do_job) editmenu.add_command(label=\u0026#34;Paste\u0026#34;, command=do_job) submenu = tk.Menu(editmenu, tearoff=0) editmenu.add_cascade(label=\u0026#34;Import\u0026#34;, menu=submenu) # Edit 添加 submenu 栏目 submenu.add_command(label=\u0026#34;submenu1\u0026#34;, command=do_job) submenu.add_command(label=\u0026#34;submenu2\u0026#34;, command=do_job) window.config(menu=menubar) window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"菜单","id":255,"section":"python","tags":null,"title":"11. Menu","uri":"https://yorkfish.github.io/review/python/tkinter/11-menu/"},{"content":"例一 平方 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = lambda x: x ** 2 \u0026gt;\u0026gt;\u0026gt; a(3) 9 \u0026gt;\u0026gt;\u0026gt;   例二 最小值 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; b = lambda x, y: x if x \u0026lt; y else y \u0026gt;\u0026gt;\u0026gt; b(66, 88) 66 \u0026gt;\u0026gt;\u0026gt;   例三 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; lst = [lambda x: x.strip(), lambda x: x ** 2] \u0026gt;\u0026gt;\u0026gt; lst [\u0026lt;function \u0026lt;lambda\u0026gt; at 0x00000259206ED5E0\u0026gt;, \u0026lt;function \u0026lt;lambda\u0026gt; at 0x00000259206ED8B0\u0026gt;] \u0026gt;\u0026gt;\u0026gt; lst[0](\u0026#34; YorkFish \u0026#34;) \u0026#39;YorkFish\u0026#39; \u0026gt;\u0026gt;\u0026gt; lst[1](3) 9 \u0026gt;\u0026gt;\u0026gt;   例四 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; def test(): ... return lambda x: x ** 2 ... \u0026gt;\u0026gt;\u0026gt; test() \u0026lt;function test.\u0026lt;locals\u0026gt;.\u0026lt;lambda\u0026gt; at 0x00000259206EDA60\u0026gt; \u0026gt;\u0026gt;\u0026gt; test()(3) 9 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":256,"section":"python","tags":null,"title":"11. lambda","uri":"https://yorkfish.github.io/review/python/basics/11-lambda/"},{"content":"1. 导入 1  import numpy as np   2. 举例 例一 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.arange(4) \u0026gt;\u0026gt;\u0026gt; print(a) [0 1 2 3] \u0026gt;\u0026gt;\u0026gt; a.shape (4,) \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; b = a.reshape((4, 1)) \u0026gt;\u0026gt;\u0026gt; print(b) [[0] [1] [2] [3]] \u0026gt;\u0026gt;\u0026gt; b.shape (4, 1) \u0026gt;\u0026gt;\u0026gt;   例三 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; c = a[:, np.newaxis] \u0026gt;\u0026gt;\u0026gt; print(c) [[0] [1] [2] [3]] \u0026gt;\u0026gt;\u0026gt; c.shape (4, 1) \u0026gt;\u0026gt;\u0026gt;   例四 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; d = a[np.newaxis, ] \u0026gt;\u0026gt;\u0026gt; print(d) [[0 1 2 3]] \u0026gt;\u0026gt;\u0026gt; d.shape (1, 4) \u0026gt;\u0026gt;\u0026gt;   例五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  \u0026gt;\u0026gt;\u0026gt; e = a.reshape((2, 2)) \u0026gt;\u0026gt;\u0026gt; print(e) [[0 1] [2 3]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(e[np.newaxis, ]) [[[0 1] [2 3]]] \u0026gt;\u0026gt;\u0026gt; e[np.newaxis, ].shape (1, 2, 2) \u0026gt;\u0026gt;\u0026gt; # [] 内有 1 个二维数据，每个二维数据内有 2 个一维数据，每个一维数据内有 2 个数据 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(e[:, np.newaxis]) [[[0 1]] [[2 3]]] \u0026gt;\u0026gt;\u0026gt; e[:, np.newaxis].shape (2, 1, 2) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(e[:, :, np.newaxis]) [[[0] [1]] [[2] [3]]] \u0026gt;\u0026gt;\u0026gt; e[:, :, np.newaxis].shape (2, 2, 1) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(e[:, :, None]) [[[0] [1]] [[2] [3]]] \u0026gt;\u0026gt;\u0026gt; e[:, :, None].shape (2, 2, 1) \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":257,"section":"python","tags":null,"title":"11. newaxis","uri":"https://yorkfish.github.io/review/python/numpy/11-newaxis/"},{"content":"1. getchar() 说明  字符输入函数 从终端或系统隐含指定的输入设备，输入一个字符  举例 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { char c; c = getchar(); printf(\u0026#34;%c\\n\u0026#34;, c); return 0; }    Input: y Output: y  2. putchar() 说明  字符输出函数 向终端输出一个字符  举例 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { char s1 = \u0026#39;A\u0026#39;; putchar(s1); putchar(\u0026#39;B\u0026#39;); putchar(\u0026#39;\\103\u0026#39;); putchar(68); putchar(\u0026#39;\\n\u0026#39;); return 0; }   \u0026gt;\u0026gt;\u0026gt;\nABCD\r","description":"","id":258,"section":"c","tags":null,"title":"11. getchar() \u0026 putchar()","uri":"https://yorkfish.github.io/review/c/basics/11-getchar-and-putchar/"},{"content":"1. 简介 组成  一个函数一般由两部分组成  声明部分 执行语句    声明与定义   函数的声明是函数的原型\n  函数的定义是函数的本身\n  int a; 既是声明，也是定义\n  extern a; 是声明，但不是定义\n  int a;\nstatic a; // 这样会被认为是重新定义\r 2. static 声明变量的作用  局部变量用 static 声明，则使该变量在整个程序执行期间不释放，为其分配的空间始终存在 全局变量用 static 声明，则该变量的作用域只限于本文件模块（即被声明的文件中）  3. 小结   对一个数据的定义，需要指定两种属性\n 数据类型 存储类别    使用两个关键字，如\n auto char c; static int a; register int d;    用 extern 声明变量为已定义的外部变量\n extern b; —— 声明 b 是一个已被定义的外部变量    ","description":"","id":259,"section":"c","tags":null,"title":"11. 变量的声明与定义","uri":"https://yorkfish.github.io/review/c/function/11-declaration-and-definition/"},{"content":"1. Markdown 方式 示例与效果 方式一  示例  [address](https://github.com/YorkFish)   效果  address    方式二   示例\n[address][01]\r[01]: https://github.com/YorkFish\r  效果\naddress\n  加 \u0026ldquo;title\u0026rdquo;  示例  [address](https://github.com/YorkFish \u0026quot;GitHub\u0026quot;)   效果  address    2. HTML 方式  用法：借助 HTML 的标签 \u0026lt;a\u0026gt; 说明  地址可以是“网络地址”/“本地地址” 若是本地地址，可以用“绝对路径”/“相对路径”    示例与效果   示例\n \u0026lt;a href=\u0026quot;https://github.com/YorkFish\u0026quot;\u0026gt;GitHub\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://github.com/YorkFish\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;GitHub\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://github.com/YorkFish\u0026quot; target=\u0026quot;_blank\u0026quot; title=\u0026quot;GitHub\u0026quot;\u0026gt;GitHub\u0026lt;/a\u0026gt;    效果\n GitHub GitHub GitHub    ","description":"","id":260,"section":"markdown","tags":null,"title":"12. 插入链接","uri":"https://yorkfish.github.io/review/markdown/12-links/"},{"content":"例1 \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;calculation properties\u0026lt;/title\u0026gt;\r\u0026lt;script src=\u0026quot;./vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;style\u0026gt;\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;!-- 当 a 发生变化时，输出 a+1 --\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; v-model=\u0026quot;a\u0026quot;\u0026gt; \u0026lt;br\u0026gt;\r{{a+1}} \u0026lt;br\u0026gt;\r{{parseInt(a)+1}} \u0026lt;br\u0026gt;\r{{b}} \u0026lt;br\u0026gt;\r{{c()}} \u0026lt;br\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rvar vm = new Vue({\rel: \u0026quot;#app\u0026quot;,\rdata: {\ra: 1\r},\rcomputed: {\r// 写业务逻辑，有缓存\rb: function(){\rreturn parseInt(this.a) + 1;\r}\r},\rmethods: {\rc: function(){\rreturn parseInt(this.a) + 1;\r}\r}\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r例2 \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;calculation properties\u0026lt;/title\u0026gt;\r\u0026lt;script src=\u0026quot;./vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;style\u0026gt;\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;!-- 当 a 发生变化时，输出 a+1 --\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; v-model=\u0026quot;a\u0026quot;\u0026gt; \u0026lt;br\u0026gt;\r{{b}} \u0026lt;br\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rvar vm = new Vue({\rel: \u0026quot;#app\u0026quot;,\rdata: {\ra: 1\r},\rcomputed: {\r// 简单地说，设置时调用 set，输出时调用 get\rb: {\r// 默认就是 get 属性\rget: function(){\rreturn parseInt(this.a) + 1;\r},\r// 在控制台输入 vm.b = 10 运行照旧\rset: function(value){\rreturn this.a = value;\r}\r}\r}\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r","description":"计算属性","id":261,"section":"web","tags":null,"title":"12. Calculation Properties","uri":"https://yorkfish.github.io/review/web/vue/12-calculation-properties/"},{"content":"定义 使用 function 语句 1 2 3  function abc() { alert(\u0026#39;abc\u0026#39;); }   在表达式中定义 1 2 3 4 5 6 7 8 9 10 11  /* 形式 var 函数名 = function(参数1, 参数2, ...) {...}; */ var add = function(a, b) { return a + b; } // 调用函数 document.write(add(50, 20));   arguments 说明  在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们 例如，在函数 sayHi() 中，第一个参数是 message，用 arguments[0] 也可以访问这个值 即，参数的索引从 0 开始  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* 使用 function 关键字定义函数 此法优先级较高，不限调用地点 JS 中没有默认值参数 小发现：把 console.log() 写成 print() 会调出打印机 */ function demo(a, b) { console.log(\u0026#34;函数被调用了！\u0026#34;); console.log(a, b); console.log(arguments); for (i in arguments) { console.log(i, arguments[i]); } } demo(1, 2); // demo(); // 少传参数 -\u0026gt; undefined // demo(1, 2, 3); // 多传参数 -\u0026gt; 调用时多余的参数会被忽略，但 arguments 不会忽略   \u0026gt;\u0026gt;\u0026gt;\n函数被调用了！\r1 2\rArguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]\r0 1\r1 2\r全局变量与局部变量 说明  函数外面定义的变量是全局变量，函数内可以直接使用 在函数内部没有使用 var 定义的变量也是全局变量（限非严格模式） 在函数内使用 var 关键字定义的变量是局部变量，即，出了函数会无效  举例 例1 1 2 3 4 5 6 7 8  var g1 = 1; function demo() { var l1 = 2; console.log(\u0026#39;g1 = %d, l1 = %d\u0026#39;, g1, l1); } demo(); console.log(\u0026#39;g1 =\u0026#39;, g1); // console.log(\u0026#39;l1 =\u0026#39;, l1); // 会报错   例2.1 1 2 3 4 5 6 7 8 9 10  var g2 = 5; function demo() { console.log(g2); // 5  g2 = 10; console.log(g2); // 10 } console.log(g2); // 5 demo(); console.log(g2); // 10   例2.2 1 2 3 4 5 6 7 8 9 10 11 12 13  var g3 = 5; function demo() { // 一旦函数内部 var 了变量 n，那么函数中所有的 n 都变成了局部变量  console.log(g3); // undefined  g3 = 10; console.log(g3); // 10  var g3 = 15; console.log(g3); // 15 } console.log(g3); // 5 demo(); console.log(g3); // 5   例2.3 1 2 3 4 5 6 7 8  function demo() { l3 = 10; // 这里没使用 var，意为将 l3 视为全局变量（限非严格模式）  console.log(l3); // 10 } demo(); // 非严格模式下，函数内不用 var 声明的变量可以在函数外部使用 console.log(l3); // 10   ","description":"函数","id":262,"section":"web","tags":null,"title":"12. function","uri":"https://yorkfish.github.io/review/web/javascript/12-function/"},{"content":"文档流  文档流指盒子按照 HTML 标签编写的顺序依次从上到下，从左到右排列 块元素占一行 行内元素在一行之内  从左到右排列 先写的先排列，后写的后排列 每个盒子都占据自己的位置    浮动的特性  浮动元素有左浮动(float:left)和右浮动(float:right)两种 浮动的元素会向左或向右浮动，碰到父元素边界、浮动元素、未浮动的元素才停下来 相邻浮动的块元素可以并在一行，超出父级宽度就换行 浮动让行内元素或块元素自动转化为行内块元素 浮动元素后面没有浮动的元素会占据浮动元素的位置 对没有浮动的元素而言，其内部的文字会避开浮动的元素，形成文字绕图的效果 若父元素内整体浮动的元素无法撑开父元素，则需要清除浮动 浮动元素之间没有垂直 margin 的合并  举例 例1  例1.1 ~ 例1.5 共用下方的 HTML  1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   例1.1 1 2 3 4 5 6 7 8 9 10  .box1{ width: 100px; height: 100px; background: red; } .box2{ width: 120px; height: 120px; background: green; }   \u0026gt;\u0026gt;\u0026gt;\n例1.2 1 2 3 4 5 6 7 8 9 10 11  .box1{ width: 100px; height: 100px; background: red; float: left; } .box2{ width: 120px; height: 120px; background: green; }   \u0026gt;\u0026gt;\u0026gt;\n例1.3 1 2 3 4 5 6 7 8 9 10 11  div{ width: 100px; height: 100px; } .box1{ background: red; } .box2{ background: green; float: left; }   \u0026gt;\u0026gt;\u0026gt;\n例1.4 1 2 3 4 5 6 7 8 9 10 11 12  div{ width: 100px; height: 100px; } .box1{ background: red; float: left; } .box2{ background: green; float: left; }   \u0026gt;\u0026gt;\u0026gt;\n\n例1.5 1 2 3 4 5 6 7 8 9 10 11 12  div{ width: 100px; height: 100px; } .box1{ background: red; float: right; } .box2{ background: green; float: left; }   \u0026gt;\u0026gt;\u0026gt;\n这个图就不截了，绿色的 box2 在左上角，红色的 box1 在右上角\n例 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;box3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box4\u0026#34;\u0026gt;box4\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  div{ width: 100px; height: 100px; } .box1{ width: 100px; height: 100px; background: red; float: left; } .box2{ width: 120px; height: 120px; background: green; float: left; } .box3{ width: 140px; height: 140px; background: blue; } .box4{ background: yellow; float: left; }   \u0026gt;\u0026gt;\u0026gt;\n例 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item1\u0026#34;\u0026gt;item1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item2\u0026#34;\u0026gt;item2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item3\u0026#34;\u0026gt;item3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item4\u0026#34;\u0026gt;item4\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  .wrap{ width: 500px; border: 2px solid; /* float: left; 加上这句的效果见下方第二张截图 */ } .item1{ width: 100px; height: 100px; background: red; float: left; } .item2{ width: 100px; height: 100px; background: green; float: left; } .item3{ width: 200px; height: 100px; background: blue; float: left; } .item4{ width: 200px; height: 100px; background: yellow; float: left; }   \u0026gt;\u0026gt;\u0026gt;\n\u0026gt;\u0026gt;\u0026gt;\n","description":"浮动","id":263,"section":"web","tags":null,"title":"12. float","uri":"https://yorkfish.github.io/review/web/css/12-float/"},{"content":"1. 符号的写法与样式    名称 写法 样式     大于号 \u0026amp;gt; \u0026gt;   小于号 \u0026amp;lt; \u0026lt;   版权 (copyright) \u0026amp;copy; ©   空格 \u0026amp;nbsp;     2. 简单的对比    不用实体字符 使用实体字符     1 \u0026lt; 2 =\u0026gt; 1 \u0026lt; 2 1 \u0026amp;lt; 2 =\u0026gt; 1 \u0026lt; 2;   2 \u0026gt; 1 =\u0026gt; 2 \u0026gt; 1 2 \u0026amp;gt; 1 =\u0026gt; 2 \u0026gt; 1;   a + b =\u0026gt; a + b a\u0026amp;nbsp;+\u0026amp;nbsp;b =\u0026gt; a + b    ","description":"HTML 中的实体字符","id":264,"section":"web","tags":null,"title":"12. Entity Character","uri":"https://yorkfish.github.io/review/web/html/12-entity-character/"},{"content":"1. 名称    符号 英文 中文     \u0026amp; and 与   ` ` or   ~ not 取反   ^ xor 异或    2. 常用操作  -a 与 (~a + 1) 的二进制是一样的 求 x 的第 k 位数字：x \u0026gt;\u0026gt; k \u0026amp; 1 返回 x 的最后一位 1  x \u0026amp; -x lowbit(x)    3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;iostream\u0026gt; using namespace std; inline int lowbit(int x) { return x \u0026amp; -x; } int main() { cout \u0026lt;\u0026lt; lowbit(100) \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n4\rps  100 = 0b01100100 最后一位 1 是 0b100，表示 4  4. bitset 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include \u0026lt;iostream\u0026gt;#include \u0026lt;bitset\u0026gt; using namespace std; int main() { bitset\u0026lt;1000\u0026gt; a, b; // 二进制串，1000 为长度  a[0] = 1; a[1] = 1; cout \u0026lt;\u0026lt; a[2] \u0026lt;\u0026lt; endl; a.set(2); // 将 a[2] 设为 1  cout \u0026lt;\u0026lt; a[2] \u0026lt;\u0026lt; endl; a.reset(2); // 将 a[2] 重设为 0  cout \u0026lt;\u0026lt; a[2] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a.count() \u0026lt;\u0026lt; endl; // 返回里面 1 的个数  a |= b; cout \u0026lt;\u0026lt; a.count() \u0026lt;\u0026lt; endl; a \u0026amp;= b; cout \u0026lt;\u0026lt; a.count() \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n0\r1\r0\r2\r2\r0\r","description":"位运算","id":265,"section":"cpp","tags":null,"title":"12. bit operation","uri":"https://yorkfish.github.io/review/cpp/12-bit-operation/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. 定义主 frame 1 2  frm = tk.Frame(window) frm.pack()   3. 定义左 frame 1 2  frm_l = tk.Frame(frm) frm_l.pack(side=\u0026#34;left\u0026#34;)    frm_r 同理  4. 在左 frame 上添加 label 1  tk.Label(frm_l, text=\u0026#34;on the frm_l1\u0026#34;).pack()    frm_r 同理  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) tk.Label(window, text=\u0026#34;on the window\u0026#34;).pack() frm = tk.Frame(window) frm.pack() frm_l = tk.Frame(frm) frm_r = tk.Frame(frm) frm_l.pack(side=\u0026#34;left\u0026#34;) frm_r.pack(side=\u0026#34;right\u0026#34;) tk.Label(frm_l, text=\u0026#34;on the frm_l1\u0026#34;).pack() tk.Label(frm_l, text=\u0026#34;on the frm_l2\u0026#34;).pack() tk.Label(frm_r, text=\u0026#34;on the frm_r1\u0026#34;).pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"框架","id":266,"section":"python","tags":null,"title":"12. Frame","uri":"https://yorkfish.github.io/review/python/tkinter/12-frame/"},{"content":"1. copy \u0026amp; deepcopy 例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = a \u0026gt;\u0026gt;\u0026gt; id(a) 2581819681792 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819681792 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a[1] = 22 \u0026gt;\u0026gt;\u0026gt; id(a) 2581819681792 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819681792 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = [4, 5, 6] \u0026gt;\u0026gt;\u0026gt; id(a) 2581819678848 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819681792 \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt; b = a.copy() \u0026gt;\u0026gt;\u0026gt; id(a) 2581819650560 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819700352 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a[1] = 22 \u0026gt;\u0026gt;\u0026gt; id(a) 2581819650560 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819700352 \u0026gt;\u0026gt;\u0026gt; a [1, 22, 3, [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a[3].append(7) # 第二层是浅拷贝 \u0026gt;\u0026gt;\u0026gt; id(a) 2581819650560 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819700352 \u0026gt;\u0026gt;\u0026gt; a [1, 22, 3, [4, 5, 6, 7]] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, [4, 5, 6, 7]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; id(a[3]) 2581819653056 \u0026gt;\u0026gt;\u0026gt; id(b[3]) 2581819653056 \u0026gt;\u0026gt;\u0026gt;   例三 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; from copy import deepcopy \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt; b = deepcopy(a) \u0026gt;\u0026gt;\u0026gt; id(a) 2581819729408 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819741760 \u0026gt;\u0026gt;\u0026gt; a[3].append(7) \u0026gt;\u0026gt;\u0026gt; a [1, 2, 3, [4, 5, 6, 7]] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt;   2. slice 例四 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; lst = list(range(10)) \u0026gt;\u0026gt;\u0026gt; lst [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt; lst[:-2:] [0, 1, 2, 3, 4, 5, 6, 7] \u0026gt;\u0026gt;\u0026gt; lst[:-2] [0, 1, 2, 3, 4, 5, 6, 7] \u0026gt;\u0026gt;\u0026gt; lst[-1:-7] [] \u0026gt;\u0026gt;\u0026gt; lst[-1:-7:-1] [9, 8, 7, 6, 5, 4] \u0026gt;\u0026gt;\u0026gt; lst[-3:-15:-1] [7, 6, 5, 4, 3, 2, 1, 0] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":267,"section":"python","tags":null,"title":"12. list","uri":"https://yorkfish.github.io/review/python/basics/12-list/"},{"content":"1. 简介  此 stack() 非彼 stack stack()  对每一个数组在 axis=0 上添加一维 把它们沿着这个新的维度串起来    2. 操作 导入 1  import numpy as np   例一 创建  沿着新的维度串起来  1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2]) \u0026gt;\u0026gt;\u0026gt; b = np.array([3, 4]) \u0026gt;\u0026gt;\u0026gt; c = np.array([5, 6]) \u0026gt;\u0026gt;\u0026gt; a.shape # a, b, c 都是 (2,) 的一维数组 (2,) \u0026gt;\u0026gt;\u0026gt;   堆叠 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; d = np.stack((a, b, c)) \u0026gt;\u0026gt;\u0026gt; print(d) [[1 2] [3 4] [5 6]] \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2])[np.newaxis] \u0026gt;\u0026gt;\u0026gt; b = np.array([3, 4])[np.newaxis] \u0026gt;\u0026gt;\u0026gt; c = np.array([5, 6])[np.newaxis] \u0026gt;\u0026gt;\u0026gt; d = np.concatenate((a, b, c), axis=0) \u0026gt;\u0026gt;\u0026gt; print(a) [[1 2]] \u0026gt;\u0026gt;\u0026gt; print(d) [[1 2] [3 4] [5 6]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":268,"section":"python","tags":null,"title":"12. stack()","uri":"https://yorkfish.github.io/review/python/numpy/12-stack/"},{"content":"1. gets(字符数组) 说明  只针对一个字符串 从终端输入一个字符串到字符数组，并得到一个函数值 该函数值是字符数组的起始地址 不进行数组范围检查  若写得不对，编译也许可以通过，但运行时可能导致数组越界或内存泄露 C++ 中，在 C++11 之后，去除了这个函数    举例 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { char str[80]; int num; printf(\u0026#34;please input a string: \u0026#34;); num = gets(str); printf(\u0026#34;\u0026gt;\u0026gt;\u0026gt; str: %s\\n\u0026#34;, str); printf(\u0026#34;\u0026gt;\u0026gt;\u0026gt; num: %d\\n\u0026#34;, num); return 0; }   \u0026gt;\u0026gt;\u0026gt;\nplease input a string: york fish\r\u0026gt;\u0026gt;\u0026gt; str: york fish\r\u0026gt;\u0026gt;\u0026gt; num: 6422140\r2. puts(字符数组) 说明  只针对一个字符串 将一个字符串（以 '\\0' 结束的字符序列）输出到终端 因为有 printf()，所以 puts() 用到不多 用 puts() 输出的字符串中可以包含转义字符 可以在输出时将字符串结束标志 '\\0' 转换成 '\\n'，即输出完字符串后换行  举例 1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { puts(\u0026#34;hello world\u0026#34;); puts(\u0026#34;york\\nfish\u0026#34;); return 0; }   \u0026gt;\u0026gt;\u0026gt;\nhello world\ryork\rfish\r","description":"","id":269,"section":"c","tags":null,"title":"12. gets() \u0026 puts()","uri":"https://yorkfish.github.io/review/c/basics/12-gets-and-puts/"},{"content":"1. 内部函数   如果一个函数只能被本文件中其他函数所调用，它称为内部函数\n  在定义内部函数时，在函数名和函数类型的前面加 static，即\n static 类型标识符 函数名(形参表); static int fun(int a, int b);    内部函数又称静态函数\n  在不同的文件中有同名的内部函数，互不干扰\n  2. 外部函数   形如 extern int fun(int a, int b);\n  C 语言规定，如果在定义函数时省略 extern，则隐含为外部函数\n  用 extern 对函数作声明，表示该函数是其他文件中定义的外部函数\n  函数在本质上是外部的，在程序中经常要调用外部函数\n 为方便编程，C 语言允许在声明函数时省写 extern 一般也都是省写    3. 例外  如，三角函数 三角函数不是由用户在本文件中定义的，而是存放在数学函数库中的 在本文件中使用（如 sin 函数），必须写出函数的原型（如 double sin(double x);）  例一 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt; #define PI 3.14159265  double sin(double x); // sin() 函数的参数是弧度  int main() { printf(\u0026#34;%f\\n\u0026#34;, sin(30.0 * PI/180)); // 0.500000  return 0; }    程序设计者在调用库函数时，需要先从手册中查出所用的库函数的原型 不过可以简化，如，使用头文件 math.h  例二 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;math.h\u0026gt; #define PI 3.14159265  int main() { printf(\u0026#34;%f\\n\u0026#34;, sin(30.0 * PI/180)); return 0; }   ","description":"","id":270,"section":"c","tags":null,"title":"12. 内部函数和外部函数","uri":"https://yorkfish.github.io/review/c/function/12-internal-and-external-functions/"},{"content":"1. 示例与效果 用法一   示例\n![Totodile](/imgs/markdown/13_totodile.png)\n  效果\n  用法二   示例\n![Totodile][01]\r[01]: /imgs/markdown/13_totodile.png\r  效果\n  2. 说明  第一个中括号内填名称或空着  若填了，在图片没有正常显示时，会显示填写的信息   地址可以是“网络地址”/“本地地址” 若是本地地址，可以用“绝对路径”/“相对路径”  3. 加 \u0026ldquo;title\u0026rdquo;   示例\n![Totodile](/imgs/markdown/13_totodile.png \u0026quot;Totodile\u0026quot;)\n  效果\n  4. 指定图片大小   借用 HTML 的标签 \u0026lt;img\u0026gt;\n  示例\n\u0026lt;img src=\u0026quot;/imgs/markdown/13_totodile.png\u0026quot; alt=\u0026quot;PokeMMO\u0026quot; title=\u0026quot;Totodile\u0026quot; width=\u0026quot;250\u0026quot; height=\u0026quot;200\u0026quot; /\u0026gt;\n  效果\n  ","description":"","id":271,"section":"markdown","tags":null,"title":"13. 插入图片","uri":"https://yorkfish.github.io/review/markdown/13-images/"},{"content":"举例 \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;listening properties\u0026lt;/title\u0026gt;\r\u0026lt;script src=\u0026quot;./vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;style\u0026gt;\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; v-model=\u0026quot;firstName\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; v-model=\u0026quot;lastName\u0026quot;\u0026gt; \u0026lt;br\u0026gt;\r{{firstName + lastName}} \u0026lt;br\u0026gt;\r{{fullName}} \u0026lt;br\u0026gt;\r{{num}}\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rnew Vue({\rel: \u0026quot;#app\u0026quot;,\rdata: {\rfirstName: \u0026quot;\u0026quot;,\rlastName: \u0026quot;\u0026quot;,\rnum: 0\r},\rcomputed: {\rfullName: function(){\rreturn this.firstName + this.lastName;\r}\r},\rwatch: {\rfullName: function(){\rthis.num++;\r}\r}\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r","description":"监听属性","id":272,"section":"web","tags":null,"title":"13. Listening Properties","uri":"https://yorkfish.github.io/review/web/vue/13-listening-properties/"},{"content":"创建对象 创建内置对象 1 2 3 4  var myObject = new Object(); myObject.name = \u0026#34;LiJie\u0026#34;; myObject.age = 18; myObject.say = function() {...};   创建自定义对象  形式：var 对象名 = {属性名1: 属性值, 属性名2: 属性值2, ...}  使用自定义构造函数创建对象 1 2 3 4 5 6 7 8 9  function pen(name, color, price) { this.name = name; this.color = color; this.price = price; this.say = function() {}; } var pen = new pen(\u0026#34;铅笔\u0026#34;, \u0026#34;红色\u0026#34;, 20); pen.say();   this  关键字 当对象调用某个方法时，方法中的 this 就代表着这个对象 类似 Python 中的 self，C++ 中的 this  遍历  for-in 语句可以遍历对象中的所有属性或数组中的所有元素  1 2 3  for (var i in window) { document.write(i + \u0026#34;---\u0026#34; + window[i]); }   类型 测试类型 1 2 3 4 5 6 7 8 9 10  // 1. global 对象的其中一个方法 typeof(); // 2. 查看当前对象的构造函数 对象.constructor; // 3. 数组推荐用这种方法，因为 typeof() 得到是 object if (arr.constructor == Array) { alert(\u0026#34;数组\u0026#34;); }   ","description":"对象","id":273,"section":"web","tags":null,"title":"13. Object","uri":"https://yorkfish.github.io/review/web/javascript/13-object/"},{"content":"摘要  例1：加 clear: ... 例2.1：父级上增加属性 overflow：hidden 例2.2：在最后一个子元素的后面加一个空的 div，给它一个样式属性 clear: both（不推荐） 例3：使用成熟的清浮动样式类 clearfix  举例 例1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;box3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box4\u0026#34;\u0026gt;box4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box5\u0026#34;\u0026gt;box5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box6\u0026#34;\u0026gt;box6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box7\u0026#34;\u0026gt;box7\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  div{ width: 100px; height: 100px; float: left; } .box1{ background: red; } .box2{ background: orange; } .box3{ background: yellow; } .box4{ background: green; /* 清除浮动 left: 清除左浮动 right: 清除有浮动 both: 清除左右两边的浮动 */ /*clear: left; 只加上这句，效果见截图2 */ /*clear: right; 只加上这句，效果同截图1-1 */ } .box5{ background: blue; } .box6{ background: indigo; } .box7{ background: purple; }     截图1-1\n  截图1-2（缩小浏览器宽度后的截图）\n  截图2\n  例 2  例2.1 与 例2.2 共用下方的 HTML  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;box3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box4\u0026#34;\u0026gt;box4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box5\u0026#34;\u0026gt;box5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box6\u0026#34;\u0026gt;box6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box7\u0026#34;\u0026gt;box7\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   例2.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  .wrap{ border: 2px solid; /* 清除浮动 解决父级元素高度无法撑开问题 注意: 是给浮动元素的父级添加 */ /*overflow: hidden; 加上这句，效果见下方截图1-2 */ } .box1, .box2, .box3, .box4, .box5, .box6, .box7{ width: 100px; height: 100px; float: left; } .box1{ background: red; } .box2{ background: orange; } .box3{ background: yellow; } .box4{ background: green; clear: left; } .box5{ background: blue; } .box6{ background: indigo; } .box7{ background: purple; }     截图3-1\n  截图3-2\n  例2.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  .wrap{ border: 2px solid; } .wrap:after{ /* 伪类选择器 */ /* 也有 before，但一般使用 after 这种方法的思路： 1. 在父级元素后插入一个空的字符串 2. 将这个字符串转成块级元素 3. 用 clear: both 给此元素清除浮动 4. 没有添加不必要的标签，不影响页面结构 注意：给浮动元素的父级添加 */ content: \u0026#39;\u0026#39;; display: table; /* display: block; 从效果上看，block 与 table 一致 */ clear: both; } .box1, .box2, .box3, .box4, .box5, .box6, .box7{ width: 100px; height: 100px; float: left; } .box1{ background: red; } .box2{ background: orange; } .box3{ background: yellow; } .box4{ background: green; clear: left; } .box5{ background: blue; } .box6{ background: indigo; } .box7{ background: purple; }    效果同截图3-2  例 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;box3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box4\u0026#34;\u0026gt;box4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box5\u0026#34;\u0026gt;box5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box6\u0026#34;\u0026gt;box6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box7\u0026#34;\u0026gt;box7\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;cl\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 多了这句 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  .wrap{ border: 2px solid; } .cl{ /* 可行，但不推荐，因为会对页面结构产生影响 */ clear: both; } .box1, .box2, .box3, .box4, .box5, .box6, .box7{ width: 100px; height: 100px; float: left; } .box1{ background: red; } .box2{ background: orange; } .box3{ background: yellow; } .box4{ background: green; clear: left; } .box5{ background: blue; } .box6{ background: indigo; } .box7{ background: purple; }    效果同截图3-2  补充  CSS 中加 zoom: 1;，表示不缩放 这样做可以兼容 IE  ","description":"清除浮动的四种方法","id":274,"section":"web","tags":null,"title":"13. clear float","uri":"https://yorkfish.github.io/review/web/css/13-4-methods-of-clearing-floating/"},{"content":"1. code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; 用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; value=\u0026#34;\u0026#34; placeholder=\u0026#34;请输入用户名\u0026#34;\u0026gt; \u0026lt;br\u0026gt; 密 码：\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 性别: \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34; checked\u0026gt; 男 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;0\u0026#34;\u0026gt; 女 \u0026lt;br\u0026gt; 爱好: \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobbies[]\u0026#34; value=\u0026#34;s\u0026#34; checked\u0026gt; 足球 \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobbies[]\u0026#34; value=\u0026#34;b\u0026#34;\u0026gt; 羽毛球 \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobbies[]\u0026#34; value=\u0026#34;p\u0026#34;\u0026gt; 乒乓球 \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 学历: \u0026lt;select name=\u0026#34;education\u0026#34; \u0026gt; \u0026lt;option value=\u0026#34;0\u0026#34;\u0026gt;小学\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;初中\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;高中\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;3\u0026#34;\u0026gt;大学\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 请选择要上传的文件：\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 请输入个人说明: \u0026lt;br\u0026gt; \u0026lt;textarea name=\u0026#34;text\u0026#34; id=\u0026#34;\u0026#34;\u0026gt;请输入个人信息\u0026lt;/textarea\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;确定\u0026#34; \u0026gt; \u0026lt;br\u0026gt; \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;reset\u0026#34; disabled\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;id\u0026#34; value=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;   2. 说明  上方的 code 将由 14-19 逐步解释  3. 作用  划定一个表单区域  4. 用法  \u0026lt;form action=\u0026quot;\u0026quot; method=\u0026quot;post\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot;\u0026gt; ... \u0026lt;/form\u0026gt; action: 数据的提交地址 method: 提交方式  get  （默认方式）通过 url 地址传输数据，数据会显示在 url 地址栏中 传输数据有大小限制，不同浏览器传输的数据大小不同 相对来说不安全   post  数据不通过 url 地址传参，相对来说较安全 数据传输没有具体的大小限制 一般表单指定使用 post 方式提交数据   enctype  如果表单当中有文件上传，必须添加这个属性 若需文件转码，可指定属性值为 multipart/form-data      ","description":"from 标签","id":275,"section":"web","tags":null,"title":"13. Form","uri":"https://yorkfish.github.io/review/web/html/13-form/"},{"content":"1. reverse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; int main() { // reverse - vector  vector\u0026lt;int\u0026gt; nums1{1, 2, 3, 4, 5}; reverse(nums1.begin(), nums1.end()); for (int num : nums1) cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; // reverse - array  int nums2[] = {1, 2, 3, 4, 5}; reverse(nums2, nums2 + 5); for (int num : nums2) cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n5 4 3 2 1 5 4 3 2 1 2. unique  返回去重之后的尾迭代器，因为左闭右开，所以是最后一个数的下一个位置 利用迭代器的减法，可计算出去重后的元素个数 常用于离散化  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; int main() { // unique - vector  vector\u0026lt;int\u0026gt; nums1{1, 1, 2, 2, 3, 3, 4}; int m = unique(nums1.begin(), nums1.end()) - nums1.begin(); cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; m; i ++ ) cout \u0026lt;\u0026lt; nums1[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; for (int num : nums1) cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; nums1 = {1, 1, 2, 2, 3, 3, 4}; nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end()); for (int num : nums1) cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; // unique - array  int nums2[] = {1, 1, 2, 2, 3, 3, 4}; m = unique(nums2, nums2 + 7) - nums2; cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; m; i ++ ) cout \u0026lt;\u0026lt; nums2[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n4\r1 2 3 4 1 2 3 4 3 3 4 1 2 3 4 4\r1 2 3 4\r3. random_shuffle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;ctime\u0026gt; using namespace std; int main() { // srand(1); // 伪随机  srand(time(0)); // time(0) 返回时间戳  vector\u0026lt;int\u0026gt; nums{1, 2, 3, 4, 5, 6, 7, 8, 9}; random_shuffle(nums.begin(), nums.end()); for (int num : nums) cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; }    输出效果：每次不同，就是打乱 nums  4. sort  对两个迭代器指定的部分进行快速排序 可以在第三个参数传入自定义的比较函数，或者重载“小于号”运算符 可以看成是 C 的 qsort() 的升级版（其实 C++ 仍有 qsort()）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; // a 是否应该排在 b 的前面 bool cmp(int a, int b) { return a \u0026lt; b; // a \u0026lt; b 时，a 在 b 的前面  // return a \u0026gt; b; // a \u0026gt; b 时，a 在 b 的前面 } struct Rect1 { int x, y; }; bool cmp_struct(Rect1 a, Rect1 b) { return a.x \u0026lt; b.x; // 按 x 升序 } struct Rect2 { int x, y; bool operator\u0026lt; (const Rect2\u0026amp; t) const { return x \u0026lt; t.x; } }; int main() { // sort - vector  vector\u0026lt;int\u0026gt; nums1{1, 8, 3, 2, 5}; // sort(nums1.begin(), nums1.end(), less\u0026lt;int\u0026gt;()); // 默认是 less，可以不写  sort(nums1.begin(), nums1.end()); for (int num : nums1) cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; sort(nums1.begin(), nums1.end(), greater\u0026lt;int\u0026gt;()); for (int num : nums1) cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; sort(nums1.begin(), nums1.end(), cmp); for (int num : nums1) cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; // sort - struct, use DIY cmp  Rect1 r1[5]; for (int i = 0; i \u0026lt; 5; i ++ ) { r1[i].x = -i; r1[i].y = i; } for (int i = 0; i \u0026lt; 5; i ++ ) cout \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; r1[i].x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; r1[i].y \u0026lt;\u0026lt; \u0026#34;) \u0026#34;; cout \u0026lt;\u0026lt; endl; sort(r1, r1 + 5, cmp_struct); for (int i = 0; i \u0026lt; 5; i ++ ) cout \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; r1[i].x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; r1[i].y \u0026lt;\u0026lt; \u0026#34;) \u0026#34;; cout \u0026lt;\u0026lt; endl; // sort - struct, use reload  Rect2 r2[5]; for (int i = 0; i \u0026lt; 5; i ++ ) { r2[i].x = -i; r2[i].y = i; } for (int i = 0; i \u0026lt; 5; i ++ ) cout \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; r2[i].x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; r2[i].y \u0026lt;\u0026lt; \u0026#34;) \u0026#34;; cout \u0026lt;\u0026lt; endl; sort(r2, r2 + 5); for (int i = 0; i \u0026lt; 5; i ++ ) cout \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; r2[i].x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; r2[i].y \u0026lt;\u0026lt; \u0026#34;) \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; }   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 5 8 8 5 3 2 1 1 2 3 5 8 (0, 0) (-1, 1) (-2, 2) (-3, 3) (-4, 4) (-4, 4) (-3, 3) (-2, 2) (-1, 1) (0, 0) (0, 0) (-1, 1) (-2, 2) (-3, 3) (-4, 4) (-4, 4) (-3, 3) (-2, 2) (-1, 1) (0, 0)\r5. lower_bound \u0026amp; upper_bound  两者用法大致相同 唯一的区别是查找 lower_bound 是大于等于，upper_bound 是大于 两个迭代器指定的部分需要有序  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int main() { // lower_bound 针对排好序的数据  int nums[] = {1, 2, 3, 4, 5}; int* p = lower_bound(nums, nums + 5, 3); // 返回大于等于 3 的第一个元素  cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; int idx = lower_bound(nums, nums + 5, 6) - nums; // 找不到的话就返回 end()  cout \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; endl; // upper_bound 针对排好序的数据  idx = upper_bound(nums, nums + 5, 3) - nums; // 返回大于 3 的第一个元素  cout \u0026lt;\u0026lt; nums[idx] \u0026lt;\u0026lt; endl; idx = upper_bound(nums, nums + 5, 6) - nums; // 找不到的话就返回 end()  cout \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; endl; // vector 也一样适用  return 0; }   \u0026gt;\u0026gt;\u0026gt;\n3\r5\r4\r5\r","description":"库函数","id":276,"section":"cpp","tags":null,"title":"13. library function","uri":"https://yorkfish.github.io/review/cpp/13-library-function/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7  import tkinter as tk import tkinter.messagebox # messagebox 需要另外导入 window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. 添加一个 button 并关联弹窗 1 2 3 4 5  def hit_me(): tk.messagebox.showinfo(title=\u0026#34;showinfo\u0026#34;, message=\u0026#34;This is showinfo.\u0026#34;) tk.Button(window, text=\u0026#34;hit me\u0026#34;, command=hit_me).pack()   \u0026gt;\u0026gt;\u0026gt;\n ps: 有声音，与更改文件后缀的提示音一样  3. 其他弹窗 showwarning 1  tk.messagebox.showwarning(title=\u0026#34;showwarning\u0026#34;, message=\u0026#34;This is showwarning.\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\n ps: 有声音，与更改文件后缀的提示音一样  showerror 1  tk.messagebox.showerror(title=\u0026#34;showerror\u0026#34;, message=\u0026#34;This is showerror.\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\n ps: 有声音，与 U 盘弹出失败的提示音一样  askquestion 1  print(tk.messagebox.askquestion(title=\u0026#34;askquestion\u0026#34;, message=\u0026#34;yes or no?\u0026#34;))   \u0026gt;\u0026gt;\u0026gt;\n ps  是(Y)：return \u0026ldquo;yes\u0026rdquo; 否(N)：return \u0026ldquo;no\u0026rdquo;    askyesno 1  print(tk.messagebox.askyesno(title=\u0026#34;askyesno\u0026#34;, message=\u0026#34;yes or no\u0026#34;))   \u0026gt;\u0026gt;\u0026gt;\n ps  是(Y)：return True 否(N)：return False    askretrycancel 1  print(tk.messagebox.askretrycancel(title=\u0026#34;askretrycancel\u0026#34;, message=\u0026#34;yes or no\u0026#34;))   \u0026gt;\u0026gt;\u0026gt;\n ps  有声音，与更改文件后缀的提示音一样 重试(R)：return True 取消：return False 右上角的叉：return False    askokcancel 1  print(tk.messagebox.askokcancel(title=\u0026#34;askokcancel\u0026#34;, message=\u0026#34;yes or no\u0026#34;))   \u0026gt;\u0026gt;\u0026gt;\n ps  确定：return True 取消：return False 右上角的叉：return False    ","description":"弹窗","id":277,"section":"python","tags":null,"title":"13. Massagebox","uri":"https://yorkfish.github.io/review/python/tkinter/13-massagebox/"},{"content":"1. 导入 1  import numpy as np   colstack 例一 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; b = np.array([4, 5, 6]) \u0026gt;\u0026gt;\u0026gt; c = np.column_stack((a, b)) \u0026gt;\u0026gt;\u0026gt; print(c) [[1 4] [2 5] [3 6]] \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; b = np.array([[9, 8, 7], [6, 5, 4]]) \u0026gt;\u0026gt;\u0026gt; c = np.column_stack((a, b)) \u0026gt;\u0026gt;\u0026gt; print(c) [[1 2 3 9 8 7] [4 5 6 6 5 4]] \u0026gt;\u0026gt;\u0026gt;   rowstack 例三 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; b = np.array([[9, 8, 7], [6, 5, 4]]) \u0026gt;\u0026gt;\u0026gt; c = np.row_stack((a, b)) \u0026gt;\u0026gt;\u0026gt; print(c) [[1 2 3] [4 5 6] [9 8 7] [6 5 4]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":278,"section":"python","tags":null,"title":"13. colstack \u0026 rowstack","uri":"https://yorkfish.github.io/review/python/numpy/13-colstack-and-rowstack/"},{"content":"1. 举例 例一 加数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 1 \u0026gt;\u0026gt;\u0026gt; id(a) 140724528887584 \u0026gt;\u0026gt;\u0026gt; a += b \u0026gt;\u0026gt;\u0026gt; id(a) 140724528887616 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 1 \u0026gt;\u0026gt;\u0026gt; id(a) 140724528887584 \u0026gt;\u0026gt;\u0026gt; a = a + b \u0026gt;\u0026gt;\u0026gt; id(a) 140724528887616 \u0026gt;\u0026gt;\u0026gt;   ps  数字的相加，a += b 与 a = a + b 等价 a 的新老 id 相差 32，即 1 与 2 的 id 相差 32  如果再定义一个 3，2 与 3 的 id 也会相差 32 不过数字大了，就没这个规律了    例二 “加列表” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; a = [1, 2] \u0026gt;\u0026gt;\u0026gt; b = [3, 4] \u0026gt;\u0026gt;\u0026gt; id(a) 2581819664704 \u0026gt;\u0026gt;\u0026gt; a += b \u0026gt;\u0026gt;\u0026gt; id(a) 2581819664704 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = [1, 2] \u0026gt;\u0026gt;\u0026gt; b = [3, 4] \u0026gt;\u0026gt;\u0026gt; id(a) 2581819665152 \u0026gt;\u0026gt;\u0026gt; a = a + b \u0026gt;\u0026gt;\u0026gt; id(a) 2581819752512 \u0026gt;\u0026gt;\u0026gt;   ps  列表的相加，a += b 与 a = a + b 等价  例三 “加元组” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026gt;\u0026gt;\u0026gt; a = [1, 2] \u0026gt;\u0026gt;\u0026gt; b = (3, 4) \u0026gt;\u0026gt;\u0026gt; id(a) 2581819687104 \u0026gt;\u0026gt;\u0026gt; a += b \u0026gt;\u0026gt;\u0026gt; id(a) 2581819687104 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; try: ... a = a + b ... except TypeError as e: ... print(e) ... can only concatenate list (not \u0026#34;tuple\u0026#34;) to list \u0026gt;\u0026gt;\u0026gt;   ps  列表是不能加元组的 上面的列表 += 元组，实际上是调用了 extend 方法  2. 结论   有两个魔法方法\n __iadd__() __add__()    可变对象，如 list, set 等，两个方法都有\n  不可变对象，如 tuple, int 等，只有 __add__()\n  += 优先调用 __iadd__()，若没有，再调用 __add__()\n  __iadd__() 是由 extend 实现的\n1 2 3  def __iadd__(self, values): self.extend(values) return self     ","description":"","id":279,"section":"python","tags":null,"title":"13. plus","uri":"https://yorkfish.github.io/review/python/basics/13-plus/"},{"content":"strcat(字符数组1, 字符数组2) 简介  string catenate 把“字符串2”接到“字符串1”的后面  使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[] = \u0026#34;abcde\u0026#34;; char str2[] = \u0026#34;123\u0026#34;; printf(\u0026#34;%d\\n\u0026#34;, strlen(str1)); // 5  strcat(str1, str2); printf(\u0026#34;%d\\n\u0026#34;, strlen(str1)); // 8  printf(\u0026#34;%s\\n\u0026#34;, str1); // abcde123  return 0; }   ","description":"","id":280,"section":"c","tags":null,"title":"13. strcat()","uri":"https://yorkfish.github.io/review/c/basics/13-strcat/"},{"content":"1. 用法  必须写在开头 用两行 --- 包起来  里面是 “属性名” + ： + 至少 1 个空格 + 解释    2. 说明  又称“YAML 标头” 是一种直观的能够被电脑识别的数据序列化格式 是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言 Hexo 与 Hugo 中用得更多  3. 示例   示例\n---\rtitle: 进阶语法 YAML\rdate: 2019/04/25\rtags: Markdown\rsummary: Markdown 进阶语法\r---\r  关于效果\n Typora 这类软件中，效果类似代码块 Hexo, Hugo 等博客工具，不会在生成的静态网页中显示    ","description":"","id":281,"section":"markdown","tags":null,"title":"14. YMAL 题头","uri":"https://yorkfish.github.io/review/markdown/14-yaml/"},{"content":"简介  数组就是一组数据的集合 JS 中，数组里面的数据可以是不同类型的  定义 1 2 3 4 5  // 1. 用对象的实例创建 var array1 = new Array(1, 2, 3); // 2. 直接量创建 var array2 = [1, 2, 3, \u0026#34;abc\u0026#34;];   操作 获取数组的长度 1 2  var list = [1, 2, 3, 4, 5]; console.log(list.length); // 5   访问 1 2  var list = [1, 2, 3, 4, 5]; console.log(list[0]); // 1   push() 与 pop() 1 2 3 4 5  var list = [1, 2, 3, 4, 5]; list.push(6); console.log(list); // [1, 2, 3, 4, 5, 6] list.pop(); console.log(list); // [1, 2, 3, 4, 5]   unshift() 与 shift() 1 2 3 4 5  var list = [1, 2, 3, 4, 5]; list.unshift(0); console.log(list); // [0, 1, 2, 3, 4, 5] list.shift(); console.log(list); // [1, 2, 3, 4, 5]   splice() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]; // 1. 若 splice() 只接受 1 个参数，表示删除该索引至末尾的所有元素，包括该索引 list.splice(11); console.log(list); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  // 2. 若 splice() 只接受 2 个参数，表示删除这两个索引间的所有元素，包括索引 list.splice(1, 3); console.log(list); // [0, 4, 5, 6, 7, 8, 9, 10]  // 3. 若 splice() 只接受 3 个参数，前 2 个意思同上，第 3 个元素用来填补删除处 list.splice(1, 3, 100); // [0, 100, 7, 8, 9, 10] console.log(list); // 4. 若 splice() 接受 3 个以上参数，前 3 个意思同上，第 4 个及之后的元素也用来填补删除处 list.splice(1, 3, 101, 102, 103, 104); console.log(\u0026#34;4. list =\u0026#34;, list); // [0, 101, 102, 103, 104, 9, 10]   多维数组 1 2  var list = [[1, 2, 3], [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]]; console.log(list[0][1]); // 2   ","description":"数组","id":282,"section":"web","tags":null,"title":"14. Array","uri":"https://yorkfish.github.io/review/web/javascript/14-array/"},{"content":"可以使用 css 的 position 属性来设置元素的定位类型 postion 的设置项    设置项 释义     relative 生成相对定位元素\n元素所占据的文档流的位置不变\n元素本身相对文档流的位置进行偏移   absolute 生成绝对定位元素\n元素脱离文档流\n不占据文档流的位置\n可以理解为漂浮在文档流的上方，相对于上一个设置了相对或者绝对或者固定定位的父级元素来进行定位\n如果找不到，则相对于 body 元素进行定位   fixed 生成固定定位元素\n元素脱离文档流\n不占据文档流的位置\n可以理解为漂浮在文档流的上方，相对于浏览器窗口进行定位   static 默认值，没有定位\n元素出现在正常的文档流中\n相当于取消定位属性或者不设置定位属性    简单归纳  relative  相对定位 不脱离文档流 相对于自己本身的位置进行定位   absolute  绝对定位 脱离文档流 位置相对于已定位的父级 如果没有父级，或父级没有定位，那么相对于文档(body)的 00 点   fixed  固定定位 脱离文档流 位置相对于浏览器窗口进行定位    举例 例1  例1.1 ~ 例1.4 共用下方的 HTML  1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   例1.1 1 2 3 4 5 6 7 8 9 10 11 12  *{ margin: 0; padding: 0; background: rgb(40, 41, 35); } div{ width: 100px; height: 100px; } .box1{ background: red; }   \u0026gt;\u0026gt;\u0026gt;\n例1.2 1 2 3 4 5 6 7 8 9 10 11 12 13  *{ margin: 0; padding: 0; background: rgb(40, 41, 35); } div{ width: 100px; height: 100px; } .box1{ background: red; margin:0 100px; /* 加了这句 */ }   \u0026gt;\u0026gt;\u0026gt;\n例1.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  *{ margin: 0; padding: 0; background: rgb(40, 41, 35); } div{ width: 100px; height: 100px; } .box1{ background: red; /* 通过 position: 设置元素的定位 relative: 相对定位 以元素本身位置为参考点进行偏移 不会脱离文档流 */ position: relative; left: 100px; top: 100px; }   \u0026gt;\u0026gt;\u0026gt;\n例1.4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  *{ margin: 0; padding: 0; background: rgb(40, 41, 35); } div{ width: 100px; height: 100px; } .box1{ background: red; margin:0 100px; /* 加了这句 */ position: relative; left: 100px; top: 100px; }   \u0026gt;\u0026gt;\u0026gt;\n例 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  *{ margin: 0; padding: 0; background: rgb(40, 41, 35); } div{ width: 200px; height: 200px; } .wrap{ width: 500px; height: 300px; margin: 0 100px; border: 2px solid; /* position: relative; 添加定位属性，若加上这一句，效果见下方第二张截图 */ } .box1{ background: red; margin:0 200px; position: relative; left: 200px; top: 100px; } .box2{ background: green; /* 设置绝对定位 position: absolute; 以有定位属性的父级为参考点进行偏移， 如果父级元素没有定位属性，继续向上一级元素找 如果找到，就以该级元素为参考进行偏移， 如果找不到，一直想向上寻找，直到 body 为止 会脱离文档流，不占文档位置 */ position: absolute; left: 100px; top: 100px; }   \u0026gt;\u0026gt;\u0026gt;\n\u0026gt;\u0026gt;\u0026gt;\n定位元素 特性  绝对定位和固定定位的块元素和行内元素会自动转化为行内块元素  层级  定位元素是浮动在正常的文档流之上的 可以用 z-index 属性来设置元素的层级  举例 1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;./static/css/test.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;box1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;box2\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  *{ margin: 0; padding: 0; background: rgb(40, 41, 35); } div{ width: 100px; height: 100px; } .box1{ background: red; position: relative; left: 100px; top: 100px; /* 设置定位的层级 谁在后面定位谁就在上面 改变层级使用 z-index: */ /* z-index: 2; 若加上这句，效果见下方第二张截图 */ } .box2{ background: green; position: absolute; left: 100px; top: 100px; }   \u0026gt;\u0026gt;\u0026gt;\n\u0026gt;\u0026gt;\u0026gt;\n","description":"绝对定位与相对定位","id":283,"section":"web","tags":null,"title":"14. position - I","uri":"https://yorkfish.github.io/review/web/css/14-position-relative-absolute/"},{"content":"1. 简介  \u0026lt;input type=\u0026quot;\u0026quot; name=\u0026quot;\u0026quot; value=\u0026quot;\u0026quot; placeholder=\u0026quot;\u0026quot;\u0026gt; type: 指定表单类型  text: 普通文本 password: 密码框 radio: 单选框 checkbox: 多选框 \u0026hellip;   name: 必须填写 value: 设置默认值 placeholder: 预期值的提示信息  2. 示例与效果 示例 1 2  用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; value=\u0026#34;\u0026#34; placeholder=\u0026#34;请输入用户名\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 密 码：\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;   效果 用户名：密 码：","description":"表单控件","id":284,"section":"web","tags":null,"title":"14. Form Control","uri":"https://yorkfish.github.io/review/web/html/14-form-control/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. pack 1  tk.Label(window, text=1).pack(side=\u0026#34;top\u0026#34;)    ps: 除了 top，还有 bottom, left, right  3. grid  简单地说，就是按照格子摆放  1 2 3  for i in range(3): for j in range(4): tk.Label(window, text=1).grid(row=i, column=j)   ps  pad 参数（向外展开）\ntk.Label(window, text=1).grid(row=i, column=j, padx=10, pady=10) ipad 参数（内部扩展）  tk.Label(window, text=1).grid(row=i, column=j, ipadx=10, ipady=10)    4. place  精确到具体的像素点摆放  1  tk.Label(window, text=1).place(x=10, y=100)   ps   anchor 参数与 tkinter.Canvas 的一致\nNR N NE\rW CENTER E\rSW S SE\r  1 2 3 4 5 6 7 8 9 10 11 12  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) tk.Label(window, text=1).pack(side=\u0026#34;top\u0026#34;) tk.Label(window, text=1).pack(side=\u0026#34;bottom\u0026#34;) tk.Label(window, text=1).pack(side=\u0026#34;left\u0026#34;) tk.Label(window, text=1).pack(side=\u0026#34;right\u0026#34;) window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) for i in range(3): for j in range(4): tk.Label(window, text=1).grid(row=i, column=j, ipadx=10, ipady=10) window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 4 5 6 7 8 9  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) tk.Label(window, text=1).place(x=150, y=100) window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"摆放位置","id":285,"section":"python","tags":null,"title":"14. pack \u0026 grid \u0026 place","uri":"https://yorkfish.github.io/review/python/tkinter/14-pack-grid-place/"},{"content":"1. set 间的运算 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; a = {1, 2, 3} \u0026gt;\u0026gt;\u0026gt; b = {2, 3, 4} \u0026gt;\u0026gt;\u0026gt; a \u0026amp; b # intersection {2, 3} \u0026gt;\u0026gt;\u0026gt; a | b # union set {1, 2, 3, 4} \u0026gt;\u0026gt;\u0026gt; a - b {1} \u0026gt;\u0026gt;\u0026gt; a ^ b # difference set {1, 4} \u0026gt;\u0026gt;\u0026gt;   2. list 借助 set 解决问题 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; lst1 = [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] \u0026gt;\u0026gt;\u0026gt; lst2 = list(set(lst1)) \u0026gt;\u0026gt;\u0026gt; lst2 [\u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; sorted(list(set(lst1)), key=lambda x: lst1.index(x)) [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; lst2.sort(key=lst1.index) \u0026gt;\u0026gt;\u0026gt; lst2 [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":286,"section":"python","tags":null,"title":"14. set","uri":"https://yorkfish.github.io/review/python/basics/14-set/"},{"content":"1. strcpy(字符数组1, 字符串2) 简介  string copy 字符串赋值函数 将“字符串2”复制到“字符数组1”中去  注意事项   “字符数组1”必须定义得足够大，以便容纳被复制的字符串\n  “字符数组1”必须写成数组名形式，“字符串2”可以是字符数组名，也可以是字符串常量\n  复制时，“字符串2”连带它末尾的 '\\0' 一并复制\n  不能用赋值语句将一个字符串常量或字符数组直接给一个字符数组，如\n1 2 3  char str1[10], str2[10]; str1 = \u0026#34;China\u0026#34;; str2 = str1; // error!     使用 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[] = \u0026#34;abcde\u0026#34;; char str2[] = \u0026#34;123\u0026#34;; strcpy(str1, str2); printf(\u0026#34;%s\\n\u0026#34;, str1); // 123  return 0; }   2. strncpy(str1, str2, n) 简介  将 str2 中前 n 个字符复制到 str1 中去 strncpy(str1, str2, 2)  将 str2 中最前面 2 个字符复制到 str1 中，取代 str1 中原有的最前面的 2 个字符    注意事项  复制的字符个数 n 不应多于 str1 中原有的字符（不包括 '\\0'）  使用 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[10] = \u0026#34;abcde\u0026#34;; char str2[10] = \u0026#34;12345\u0026#34;; strncpy(str1, str2, 3); printf(\u0026#34;%s\\n\u0026#34;, str1); // 123de  return 0; }   ","description":"","id":287,"section":"c","tags":null,"title":"14. strcpy() \u0026 strncpy()","uri":"https://yorkfish.github.io/review/c/basics/14-strcpy-and-strncpy/"},{"content":" 用法：借助 HTML 的标签 \u0026lt;abbr\u0026gt; 说明  与注脚不同，缩写不需要在下文写补充语句 查看的时候，悬停鼠标即可    示例与效果   示例\n\u0026lt;abbr title=\u0026quot;Hypertext Markup Language\u0026quot;\u0026gt;HTML\u0026lt;/abbr\u0026gt;\n  效果\nHTML\n  ","description":"","id":288,"section":"markdown","tags":null,"title":"15. 缩写","uri":"https://yorkfish.github.io/review/markdown/15-abbreviation/"},{"content":"Math 例1. 四舍五入 1 2 3 4  var num1 = Math.round(5.921); var num2 = Math.round(5.321); console.log(num1); // 6 console.log(num2); // 5   例2 最值 1 2 3 4 5 6 7  // 获取最大值 var num1 = Math.max(10, 20, 30, 41, 52, 14, 28, 39); console.log(num1); // 52  // 获取最小值 var num2 = Math.min(10, 20, 30, 41, 52, 14, 28, 39); console.log(num2); // 10   例3 绝对值 1 2  var num = Math.abs(-100); console.log(num); // 100   例4 取整 1 2 3 4 5 6 7 8 9 10 11  // 退一取整/向下取整 var num1 = Math.floor(1.1); var num2 = Math.floor(1.9); console.log(num1); // 1 console.log(num2); // 1  // 进一取整/向上取整 var num3 = Math.ceil(1.1); var num4 = Math.ceil(1.9); console.log(num3); // 2 console.log(num4); // 2   例5 幂运算 1 2  var num = Math.pow(2, 3); console.log(num); // 8   例6 开平方 1 2  var num = Math.sqrt(9); console.log(num); // 3   random() 说明  获取一个随机数，返回 (0, 1] 之间的随机小数 可能取到 1，但取到的概率为 0  手动封装函数 1 2 3 4 5  function rand(m, n) { return Math.floor(Math.random() * (n-m+1)) + m; } var res = rand(20, 30); // [20, 30]   ","description":"数学对象","id":289,"section":"web","tags":null,"title":"15. Math Object","uri":"https://yorkfish.github.io/review/web/javascript/15-math-object/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; div{ height: 150px; background: rgb(40, 41, 35); border: 2px solid; box-sizing: border-box; } .box{ width: 100px; height: 50px; text-align: center; line-height: 40px; background: cyan; /* 绑定定位 以浏览器窗口为参考进行定位 主要用在：固定在头部的导航栏、返回顶部、网页的侧边栏菜单 */ position: fixed; bottom: 20px; right: 20px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;返回顶部\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;1\u0026lt;/font\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;2\u0026lt;/font\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;3\u0026lt;/font\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;4\u0026lt;/font\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;5\u0026lt;/font\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   \u0026gt;\u0026gt;\u0026gt;\n","description":"绑定定位","id":290,"section":"web","tags":null,"title":"15. position - II","uri":"https://yorkfish.github.io/review/web/css/15-position-fixed/"},{"content":"1. 单选框 1.1 简介  \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;\u0026quot; value=\u0026quot;1\u0026quot; checked\u0026gt; xxx 必须有 name 属性和 value 属性 若是一组单选框，name 属性的值必须相同  1.2 示例与效果 示例 1 2  \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34; checked\u0026gt; 男\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;0\u0026#34;\u0026gt; 女   效果 男\n女\n2. 多选框 2.1 简介  \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;hobbies[]\u0026quot; value=\u0026quot;\u0026quot; checked\u0026gt; xxx 必须指定 name 属性和 value 属性 若是一组多选框，name 属性的值必须相同  2.2 示例与效果 示例 1 2 3 4  爱好：\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobbies[]\u0026#34; value=\u0026#34;s\u0026#34; checked\u0026gt; 足球\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobbies[]\u0026#34; value=\u0026#34;b\u0026#34;\u0026gt; 羽毛球\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobbies[]\u0026#34; value=\u0026#34;p\u0026#34;\u0026gt; 乒乓球   效果 爱好：\n足球\n羽毛球\n乒乓球\n3. 下拉选项框 3.1 简介   形如\n1 2 3 4  \u0026lt;select name=\u0026#34;\u0026#34; \u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;xxx\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;xxx\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt;     必须配合 option 标签来使用\n  3.2 示例与效果 示例 1 2 3 4 5 6 7  学历： \u0026lt;select name=\u0026#34;education\u0026#34; \u0026gt; \u0026lt;option value=\u0026#34;0\u0026#34;\u0026gt;小学\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;初中\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;高中\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;3\u0026#34;\u0026gt;大学\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt;   效果 学历：\n小学\n初中\n高中\n大学\n\n","description":"选择框","id":291,"section":"web","tags":null,"title":"15. Selection Box","uri":"https://yorkfish.github.io/review/web/html/15-selection-box/"},{"content":"例一  C 的话有溢出风险，Python 就不用担心了  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 2 \u0026gt;\u0026gt;\u0026gt; a = a + b \u0026gt;\u0026gt;\u0026gt; b = a - b \u0026gt;\u0026gt;\u0026gt; a = a - b \u0026gt;\u0026gt;\u0026gt; a 2 \u0026gt;\u0026gt;\u0026gt; b 1 \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 2 \u0026gt;\u0026gt;\u0026gt; a = a ^ b \u0026gt;\u0026gt;\u0026gt; b = a ^ b \u0026gt;\u0026gt;\u0026gt; a = a ^ b \u0026gt;\u0026gt;\u0026gt; a 2 \u0026gt;\u0026gt;\u0026gt; b 1 \u0026gt;\u0026gt;\u0026gt;   例三  golang 等别的语言也有这种方法  1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 2 \u0026gt;\u0026gt;\u0026gt; a, b = b, a \u0026gt;\u0026gt;\u0026gt; a 2 \u0026gt;\u0026gt;\u0026gt; b 1 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":292,"section":"python","tags":null,"title":"15. swap","uri":"https://yorkfish.github.io/review/python/basics/15-swap/"},{"content":"strcmp(字符串1, 字符串2) 简介  string compare 比较“字符串1”与“字符串2”  比较规则  若出现不同字符，以第一个不相同的字符的比较结果为准 str1 == str2 返回 0 str1 \u0026gt; str2 返回某正整数 str1 \u0026lt; str2 返回某负整数  使用 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;york\u0026#34;, \u0026#34;york\u0026#34;)); // 0  printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;york\u0026#34;, \u0026#34;fish\u0026#34;)); // 1  printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;fish\u0026#34;, \u0026#34;york\u0026#34;)); // -1  printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;york\u0026#34;, \u0026#34;yorkfish\u0026#34;)); // -1  return 0; }   ","description":"","id":293,"section":"c","tags":null,"title":"15. strcmp()","uri":"https://yorkfish.github.io/review/c/basics/15-strcmp/"},{"content":"1. 按键  用法：借助 HTML 的标签 \u0026lt;kbd\u0026gt; 说明：有的平台不显示边框  示例与效果   示例\n\u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt; + \u0026lt;kbd\u0026gt;a\u0026lt;/kbd\u0026gt;\n  效果\nCtrl + a\n  2. 任务列表 示例与效果   示例\n- [ ] 党参\r- [x] 枸杞\r  效果\n 党参 枸杞    说明  x 表示打勾 有些编辑器支持鼠标点击  ","description":"","id":294,"section":"markdown","tags":null,"title":"16. 按键与任务列表","uri":"https://yorkfish.github.io/review/markdown/16-kbd-and-task-list/"},{"content":"1. 简介  \u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;\u0026quot;\u0026gt; type=\u0026quot;file\u0026quot;: 一般用于文件上传  2. 示例与效果 示例 请选择要上传的文件：\u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;file\u0026quot;\u0026gt;\n效果 请选择要上传的文件：","description":"文件上传","id":295,"section":"web","tags":null,"title":"16. File Upload","uri":"https://yorkfish.github.io/review/web/html/16-file-upload/"},{"content":"1. 说明  若参数为不可变对象，如 int, str, tuple 等，采用的是“值传递”，相当于用形参接收参数，不影响原值 若参数为可变对象，如 list, dict 等，采用的是“引用传递”，相当于用指针接收参数，影响原值  2. 举例 例一 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def test(num): ... num += 1 ... return num ... \u0026gt;\u0026gt;\u0026gt; num = 10 \u0026gt;\u0026gt;\u0026gt; test(num) 11 \u0026gt;\u0026gt;\u0026gt; num 10 \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def test(lst): ... lst[0] += 1 ... return lst ... \u0026gt;\u0026gt;\u0026gt; alist = [10, 20, 30] \u0026gt;\u0026gt;\u0026gt; test(alist) [11, 20, 30] \u0026gt;\u0026gt;\u0026gt; alist [11, 20, 30] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":296,"section":"python","tags":null,"title":"16. transmit","uri":"https://yorkfish.github.io/review/python/basics/16-transmit/"},{"content":"strlen(字符数组) 简介  string length 测试字符串长度  注意事项  函数的值位字符串的实际长度，不包括 '\\0'  使用 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[] = \u0026#34;york\u0026#34;; char str2[10] = \u0026#34;fish\u0026#34;; printf(\u0026#34;%d\\n\u0026#34;, strlen(str1)); // 4  printf(\u0026#34;%d\\n\u0026#34;, sizeof(str1)); // 5  printf(\u0026#34;%d\\n\u0026#34;, strlen(str2)); // 4  printf(\u0026#34;%d\\n\u0026#34;, sizeof(str2)); // 10  return 0; }   ","description":"","id":297,"section":"c","tags":null,"title":"16. strlen()","uri":"https://yorkfish.github.io/review/c/basics/16-strlen/"},{"content":"1. 用法  两个英文冒号中间加一个参数  2. 说明  Win10 在“微软拼音”切到中文时可以调出表情符号面板，快捷键是 Ctrl + Shift + b Win10 搜索 Charmap，点击“字符印射表”，字体选择 Segoe UI Emoji 可以得到黑白的表情编码  3. 示例与效果   示例\n😄\n  效果\n😄\n  ","description":"","id":298,"section":"markdown","tags":null,"title":"17. Emoji","uri":"https://yorkfish.github.io/review/markdown/17-emoji/"},{"content":"1. 简介  \u0026lt;textarea name=\u0026quot;\u0026quot; id=\u0026quot;\u0026quot;\u0026gt;xxx\u0026lt;/textarea\u0026gt; 可以拖动右下角来改变输入框的大小  2. 示例与效果 示例 1 2  请输入个人说明：\u0026lt;br\u0026gt; \u0026lt;textarea name=\u0026#34;text\u0026#34; id=\u0026#34;\u0026#34;\u0026gt;请输入个人信息\u0026lt;/textarea\u0026gt;   效果 请输入个人说明：\n请输入个人信息\n","description":"多行文本输入","id":299,"section":"web","tags":null,"title":"17. Multiline Text Input","uri":"https://yorkfish.github.io/review/web/html/17-multiline-text-input/"},{"content":"例一 有点像 switch-case 1 2 3 4 5 6 7 8 9 10  try: a = b except ArithmeticError: print(\u0026#34;ArithmeticError!\u0026#34;) except KeyError: print(\u0026#34;KeyError!\u0026#34;) except TypeError: print(\u0026#34;TypeError!\u0026#34;) except Exception: print(\u0026#34;Some error!\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\nSome error!\r例二 1 2 3 4  try: a = b except Exception as e: print(e)   \u0026gt;\u0026gt;\u0026gt;\nname 'b' is not defined\r例三 1 2 3 4 5 6  try: a = b except NameError: print(\u0026#34;NameError!\u0026#34;) finally: print(\u0026#34;You must enter into finally!\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\nNameError!\rYou must enter into finally!\r例四 1 2 3 4 5 6 7 8  try: a = 1 except NameError: print(\u0026#34;NameError!\u0026#34;) else: print(\u0026#34;No error!\u0026#34;) finally: print(\u0026#34;You must enter into finally!\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\nNo error!\rYou must enter into finally!\r","description":"","id":300,"section":"python","tags":null,"title":"17. try-except-else-finally","uri":"https://yorkfish.github.io/review/python/basics/17-try-except-else-finally/"},{"content":"1. strlwr(字符串)  string lowercase 将字符串中的大写字母换成小写字母  2. strupr(字符车)  string uppercase 将字符串中的小写字母换成大写字母  3. 使用 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;YorkFish\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, strlwr(str)); // yorkfish  printf(\u0026#34;%s\\n\u0026#34;, strupr(str)); // YORKFISH  return 0; }   ","description":"","id":301,"section":"c","tags":null,"title":"17. strlwr() \u0026 strupr()","uri":"https://yorkfish.github.io/review/c/basics/17-strlwr-and-strupr/"},{"content":"1. 用法  $$ + 编辑的内容 + $$  2. 说明 几个名词解释    名称 释义     TeX 学术排版   LaTe 相当于 TeX 的简化版本；对公式编辑精细至像素级别   MathJax 相当于 LaTeX 的简化版本，用于显示数学表达式式   Markdown 不支持 TaTeX 所有的语法，对数学公式的支持比较好    注意事项  LaTex 区分大小写  3. 示例与效果   示例\n$$\r\\pi(x) = \\int_0^x \\frac{dt}{lnt} + C\r$$\r  效果\n  ","description":"","id":302,"section":"markdown","tags":null,"title":"18. LaTeX","uri":"https://yorkfish.github.io/review/markdown/18-latex/"},{"content":"1. 简介  \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;\u0026quot; value=\u0026quot;\u0026quot;\u0026gt; hidden: 不需要用户查看和填写的信息  2. 示例与效果 示例 \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;id\u0026quot; value=\u0026quot;0\u0026quot;\u0026gt;\n效果 因为是“隐藏域”，所以“看不出效果”\r ","description":"隐藏域","id":303,"section":"web","tags":null,"title":"18. Hidden Domain","uri":"https://yorkfish.github.io/review/web/html/18-hidden-domain/"},{"content":"情形一 说明  后置单下划线 撞了关键字，但又懒得想变量名  举例 1  class_ = \u0026#34;101\u0026#34;    tkinter.Scale() 的 from_ 参数  情形二 说明  下划线作占位符 少起一个名字  举例 1  a = [[1, 2, 3] for _ in range(10)]   情形三 说明  下划线作占位符 解包时对应用不到的数据  举例 1 2  nums = [1, 2, 3, 4] n1, _, _, n4 = nums   情形四 说明  下划线作分割符 方便数字多的时候看 “格式化”指定下划线为填充物时  十进制默认隔 3 位 其他进制默认隔 4 位    举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026gt;\u0026gt;\u0026gt; num = 1_000_000 \u0026gt;\u0026gt;\u0026gt; num 1000000 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; num = 0xFF_FF \u0026gt;\u0026gt;\u0026gt; num 65535 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; num = 1000000 \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:_}\u0026#34; \u0026#39;1_000_000\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:_b}\u0026#34; \u0026#39;1111_0100_0010_0100_0000\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:_o}\u0026#34; \u0026#39;364_1100\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:_x}\u0026#34; \u0026#39;f_4240\u0026#39; \u0026gt;\u0026gt;\u0026gt;   情形五 说明  前置单下划线 Python 中没有对 public 和 private 进行严格的定义 为了区分，社区的程序员达成了一个约定 当看到以下划线开头的变量或方法时，最好只在内部使用  举例 1 2 3 4  class Hero(object): def __init__(self, name, chinesename): self.name = name self._chinesename = chinesename   情形六 说明  前置双下划线 使属性变量私有，不被派生类去继承 避免了派生类和父类属性名称的冲突  举例 1 2 3 4 5 6 7 8 9 10 11 12 13  class Hero(object): def __init__(self, name, chinesename): self.name = name self.__chinesename = chinesename garen = Hero(\u0026#34;garen\u0026#34;, \u0026#34;盖伦\u0026#34;) try: print(garen.__chinesename) except AttributeError as e: print(e) finally: print(garen._Hero__chinesename)   \u0026gt;\u0026gt;\u0026gt;\n'Hero' object has no attribute '__chinesename'\r盖伦\r情形七 说明  前置双下划线 如果类内的方法也加上了前置双下划线，那么它也无法在外部用实例.方法名访问  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Hero(object): def __init__(self, name, chinesename): self.name = name self.__chinesename = chinesename def __flash(self): print(\u0026#34;F!\u0026#34;) garen = Hero(\u0026#34;garen\u0026#34;, \u0026#34;盖伦\u0026#34;) try: garen.__flash() except AttributeError as e: print(e) finally: garen._Hero__flash()   \u0026gt;\u0026gt;\u0026gt;\n'Hero' object has no attribute '__flash'\rF!\r情形八 说明  在交互模式下，自动保存上一个值  举例 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; _ Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; NameError: name \u0026#39;_\u0026#39; is not defined \u0026gt;\u0026gt;\u0026gt; a 1 \u0026gt;\u0026gt;\u0026gt; _ 1 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":304,"section":"python","tags":null,"title":"18. underscore","uri":"https://yorkfish.github.io/review/python/basics/18-underscroe/"},{"content":"1. 用法   初始化变量\nstart=\u0026gt;start: 开始\rend=\u0026gt;end: 结束\roperation=\u0026gt;operation: 操作\rcondition=\u0026gt;condition: 条件\r  设置路径\nstart-\u0026gt;operation-\u0026gt;condition\n  添加线路上的标记\ncondition(yes)-\u0026gt;end\rcondition(no)-\u0026gt;operation\r  2. 说明  代码语言填 flow  3. 示例与效果   示例\n ```flow\rstart=\u0026gt;start: 开始\rend=\u0026gt;end: 结束\roperation=\u0026gt;operation: 操作\rcondition=\u0026gt;condition: 条件\rstart-\u0026gt;operation-\u0026gt;condition\rcondition(yes)-\u0026gt;end\rcondition(no)-\u0026gt;operation\r```\r   效果\n  另一种 示例 ```mermaid\rgraph TD\rA[Hard] --\u0026gt;|Text| B(Round)\rB --\u0026gt; C{Decision}\rC --\u0026gt;|One| D[Result 1]\rC --\u0026gt;|Two| E[Result 2]\r```\r 效果 ps  有些平台上，行尾需要加分号  ","description":"","id":305,"section":"markdown","tags":null,"title":"19. Flow Chart","uri":"https://yorkfish.github.io/review/markdown/19-flow/"},{"content":"1. 按钮一 示例 \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;确定\u0026quot;\u0026gt;\n效果 2. 按钮二 示例 \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt;\n效果 提交\n3. 按钮三 示例 \u0026lt;input type=\u0026quot;reset\u0026quot; disabled\u0026gt;\n效果 ","description":"三种按钮","id":306,"section":"web","tags":null,"title":"19. Button","uri":"https://yorkfish.github.io/review/web/html/19-button/"},{"content":"1. 全局变量 例一 1 2 3 4 5 6 7 8 9  def test(): global num num = 2 print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; num =\u0026#34;, num) num = 1 test() print(\u0026#34;\u0026lt;\u0026lt;\u0026lt; num =\u0026#34;, num)   \u0026gt;\u0026gt;\u0026gt;\n\u0026gt;\u0026gt;\u0026gt; num = 2\r\u0026lt;\u0026lt;\u0026lt; num = 2\r例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def test(): num = 1 def inside(): global num num *= 2 print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; num =\u0026#34;, num) print(\u0026#34;before use inside():\u0026#34;, num) inside() print(\u0026#34; after use inside():\u0026#34;, num) num = 1 test() print(\u0026#34;\u0026lt;\u0026lt;\u0026lt; num =\u0026#34;, num)   \u0026gt;\u0026gt;\u0026gt;\nbefore use inside(): 1\r\u0026gt;\u0026gt;\u0026gt; num = 2\rafter use inside(): 1\r\u0026lt;\u0026lt;\u0026lt; num = 2\r2. 局部变量 例三 1 2 3 4 5 6 7 8 9 10 11  def test(): num = 1 def inside(): nonlocal num num *= 2 print(\u0026#34;before use inside():\u0026#34;, num) inside() print(\u0026#34; after use inside():\u0026#34;, num) test()   \u0026gt;\u0026gt;\u0026gt;\nbefore use inside(): 1\rafter use inside(): 2\r3. 不可变对象  常见的不可变对象：str, int, float, complex, tuple, bool  i = 5 | i += 2\r--------------------\ri -\u0026gt; 5 | i -- 5 -\u0026gt; Garbage collection\r| \\\r| --\u0026gt; 7\rps  一开始，i 指向存储 5 的那片空间 运算后，新增了一片存储 7 的空间，i 改变指向，指向存储 7 的那片空间 存储 5 的那片空间，如果没有“人”去使用，就会被回收  4. 可变对象  常见的可变对象：list, dict, set  1 2  lst = [0, 1, 2, 3] lst[0] = 10   ps  lst[0] = 10  先找到 lst[0] 的地址 再把这片地址上的数据修改为 10（整个过程没有创建新的对象）    ","description":"","id":307,"section":"python","tags":null,"title":"19. variable","uri":"https://yorkfish.github.io/review/python/basics/19-variable/"},{"content":"1. 示例与效果   示例\n ```mermaid\rgantt\rdateFormat YYYY-MM-DD\rtitle Adding GANTT diagram functionality to mermaid\rsection 现有任务\r已完成 :done, des1, 2020-01-01, 2020-01-05\r进行中 :active, des2, 2020-01-05, 3d\r计划一 : des3, after des2, 5d\r计划二 : des4, after des3, 5d\r```\r   效果\n  2. 说明  代码语言填 mermaid 此图被称为“甘特图” 若当前日期在图中范围之内，则甘特图中会以一条“细红竖线”表示当前日子  ","description":"","id":308,"section":"markdown","tags":null,"title":"20. GANTT","uri":"https://yorkfish.github.io/review/markdown/20-gantt/"},{"content":"用法 1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;用户名：\u0026lt;/label\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; value=\u0026#34;阿强\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;密 码：\u0026lt;/label\u0026gt;\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;reset\u0026#34; name=\u0026#34;\u0026#34; value=\u0026#34;重置\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt;   效果 用户名：密 码：\r\r","description":"label 标签","id":309,"section":"web","tags":null,"title":"20. Label","uri":"https://yorkfish.github.io/review/web/html/20-label/"},{"content":"1. 说明  属于 generator 有速度优势 协程会用到  2. 举例 公共部分 1 2 3 4 5 6  def fib(num): n, a, b = 0, 0, 1 while n \u0026lt; num: yield b # 相当于挂起；可以看成一种不退出的 return a, b = b, a+b n += 1   例一 1 2 3  y1 = fib(10) for i in y1: print(i)   \u0026gt;\u0026gt;\u0026gt;\n1\r1\r2\r3\r5\r8\r13\r21\r34\r55\r例二 1 2 3 4 5 6 7 8 9  # \u0026lt; 3.8 y2 = fib(10) try: n = next(y2) while n: print(n) n = next(y2) except StopIteration: print(\u0026#34;over\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\n1\r1\r2\r3\r5\r8\r13\r21\r34\r55\rover\r例三 yield 起来的数据会随着遍厉一一清除 1 2 3 4 5 6 7 8 9  # \u0026gt;= 3.8 y3 = fib(10) try: while n := next(y3): print(n) except StopIteration: print(\u0026#34;over\u0026#34;) for i in y3: # 不会进入循环 print(i)   \u0026gt;\u0026gt;\u0026gt;\n1\r1\r2\r3\r5\r8\r13\r21\r34\r55\rover\r","description":"","id":310,"section":"python","tags":null,"title":"20. yield","uri":"https://yorkfish.github.io/review/python/basics/20-yield/"},{"content":"1. 用法  虚线有线段感，所以比实线多一个减号     箭头 释义     -\u0026gt;\u0026gt; 实线   --\u0026gt;\u0026gt; 虚线   -x 箭头带叉实线   --x 箭头带叉虚线      箭头会按设定的轨迹走\nsequenceDiagram\r石破天 -\u0026gt;\u0026gt; 张三: 你这葫芦中的酒，滋味很好吗？\r张三 --\u0026gt;\u0026gt; 石破天: 这不是酒，喝不得的！\r石破天 -\u0026gt;\u0026gt; 李四: 你葫芦中的总是酒吧？\r李四 --\u0026gt;\u0026gt; 石破天: 这是毒药，你有胆子便喝罢！\r张三 --x 李四: 原来如此!\r李四 --x 张三: 我们倒失眼了！\r李四 -x 石破天: 红葫芦里的毒酒滋味更好，你要不要试试？\r  可以“添加便签”\nNote left of 石破天: 这两人都爱说笑，\u0026lt;br\u0026gt;若说真是毒酒，\u0026lt;br\u0026gt;怎么他们自己又喝？\n  2. 说明  代码语言填 mermaid UML: Unified Model Language 中文名  统一建模语言 标准建模语言    3. 示例与效果   示例\n ```mermaid\rsequenceDiagram\r石破天 -\u0026gt;\u0026gt; 张三: 你这葫芦中的酒，滋味很好吗？\r张三 --\u0026gt;\u0026gt; 石破天: 这不是酒，喝不得的！\r石破天 -\u0026gt;\u0026gt; 李四: 你葫芦中的总是酒吧？\r李四 --\u0026gt;\u0026gt; 石破天: 这是毒药，你有胆子便喝罢！\r张三 --x 李四: 原来如此!\r李四 --x 张三: 我们倒失眼了！\r李四 -x 石破天: 红葫芦里的毒酒滋味更好，你要不要试试？\rNote left of 石破天: 这两人都爱说笑，\u0026lt;br\u0026gt;若说真是毒酒，\u0026lt;br\u0026gt;怎么他们自己又喝？\r```\r   效果\n  ps  有些平台上，行尾需要加分号  ","description":"","id":311,"section":"markdown","tags":null,"title":"21. UML","uri":"https://yorkfish.github.io/review/markdown/21-uml/"},{"content":"1. 字体相关    示例 效果     正常的字 正常的字   \u0026lt;tt\u0026gt;小一点的字体\u0026lt;/tt\u0026gt; 小一点的字体   \u0026lt;small\u0026gt;变小\u0026lt;/small\u0026gt; 变小   \u0026lt;big\u0026gt;变大\u0026lt;/big\u0026gt; 变大    2. 文字相关    示例 效果     \u0026lt;del\u0026gt;此处会被删除\u0026lt;/del\u0026gt; 此处会被删除   \u0026lt;ins\u0026gt;修改时使用\u0026lt;/ins\u0026gt; 修改时使用   \u0026lt;s\u0026gt;过时了\u0026lt;/s\u0026gt; 过时了   上\u0026lt;sup\u0026gt;标\u0026lt;/sup\u0026gt; 上标   下\u0026lt;sub\u0026gt;标\u0026lt;/sub\u0026gt; 下标   \u0026lt;mark\u0026gt;高亮\u0026lt;/mark\u0026gt; 高亮   \u0026lt;abbr title=\u0026quot;I am york\u0026quot;\u0026gt;鼠标悬停有提示\u0026lt;/abbr\u0026gt; 鼠标悬停有提示    其他示例与效果 1. 倒写 示例 \u0026lt;bdo dir=rtl\u0026gt;倒写\u0026lt;/bdo\u0026gt;\n效果 倒写\n2. 块引用与区段 示例 1 2 3 4 5 6 7  \u0026lt;blockquote\u0026gt; 块引用 \u0026lt;/blockquote\u0026gt; \u0026lt;section\u0026gt; 区段 \u0026lt;/section\u0026gt;   效果 \r块引用\r\r\r区段\r\r3. code 相关    示例 效果     \u0026lt;dfn\u0026gt;definition 定义\u0026lt;/dfn\u0026gt; definition 定义   \u0026lt;var\u0026gt;variable 变量\u0026lt;/var\u0026gt; variable 变量   \u0026lt;samp\u0026gt;例子代码\u0026lt;/samp\u0026gt; 例子代码    其他示例与效果 1. 缩进 示例 1 2 3 4 5 6  \u0026lt;code\u0026gt; \u0026lt;pre\u0026gt; for i in range(10): print(i) \u0026lt;/pre\u0026gt; \u0026lt;/code\u0026gt;   效果 \r\rfor i in range(10):\rprint(i)\r\r\r2. 行内框架 示例 1 2 3 4 5 6  \u0026lt;iframe src=\u0026#34;\u0026#34;\u0026gt; xxx \u0026lt;/iframe\u0026gt; \u0026lt;p href=\u0026#34;#here\u0026#34;\u0026gt; xxx \u0026lt;/p\u0026gt;   效果 xxx\r xxx\rxxx 上方的空白就是 iframe 的效果\r 3. 一些符号    符号 效果     \u0026amp;lt; \u0026lt;   \u0026amp;gt; \u0026gt;   \u0026amp;amp; \u0026amp;   \u0026amp;quot; \u0026quot;   \u0026amp;apos; '   \u0026amp;cent; ¢   L\u0026amp;uuml; Lü   L\u0026amp;Uuml; LÜ   \u0026amp;aelig; æ     大小写敏感 更多的字符实体：\u0026gt;\u0026gt;\u0026gt; 传送门   ","description":"其他常用标签","id":312,"section":"web","tags":null,"title":"21. Other Common Labels","uri":"https://yorkfish.github.io/review/web/html/21-other-common-labels/"},{"content":"绝对值：\\left| \\right|\r向下取整：\\lfloor x \\rfloor\r向上取整：\\lceil x \\rceil\r小于等于：\\leq\r大于等于：\\gep\r下标：v_i\r分数：\\frac{b}{a}\r\\begin{equation}\r\\begin{aligned}\r\\begin{case}\r\\end{case}\r\\end{aligned}\r\\end{equation}\r希腊字母    字母 实现 大写 实现     α \\alpha A \\Alpha   β \\beta B \\Beta   γ \\gamma Γ \\Gamma   δ \\delta Δ \\Delta   ϵ \\epsilon E \\Epsilon   ε \\varepsilon     ξ \\xi Ξ \\Xi   ζ \\zeta Z \\Zeta   ς \\varsigma     η \\eta H \\Eta   θ \\theta Θ \\Theta   ϑ \\vartheta     λ \\lambda Λ \\Lambda   μ \\mu M \\Mu   π \\pi Π \\Pi   ρ \\rho P \\Rho   σ \\sigma Σ \\Sigma   τ \\tau T \\Tau   ϕ \\phi Φ \\Phi   φ \\varphi     χ \\chi X \\Chi   ψ \\psi Ψ \\Psi   ω \\omega Ω \\Omega    运算符    符号 实现 名称     ± \\pm 加减   ∓ \\mp 减加   × \\times 乘   ÷ \\div 除   ⋅ \\cdot 点   ∗ \\ast 星号   ∩ \\cap 圆帽   ∪ \\cup 圆杯   ∑ \\sum 求和   ∏ \\prod 乘积   ∫ \\int 积分   ∮ \\oint 围道积分    关系符号    符号 实现 名称     \u0026lt; \u0026lt; 小于   \u0026gt; \u0026gt; 大于   ≤ \\leq 小于等于   ≥ \\geq 大于等于   ≪ \\ll 远小于   ≫ \\gg 远大于   ≠ \\neq 不等于   ≃ \\simeq 近似等于   ≈ \\approx 约等于   ≅ \\cong 全等于   ≡ \\equiv 恒等于   ⊂ \\subset 子集   ⊃ \\supset 超集   ⊆ \\subseteq 子集或等于   ⊇ \\supseteq 超集或等于   ∈ \\in 包含于   ∋ \\ni 包含   ∉ \\notin 不包含于   ≢ \\not\\equiv 不恒等于    箭头符号    符号 实现 名称     ← \\leftarrow 左箭头   ⇐ \\Leftarrow 左双线箭头   → \\rightarrow 右箭头   ⇒ \\Rightarrow 右双线箭头   ⇔ \\Leftrightarrow 左右双向双线箭头   ↽ \\leftharpoondown 下半钩左箭头   ⇁ \\rightharpoondown 下半钩右箭头   ↼ \\leftharpoonup 上半钩左箭头   ⇀ \\rightharpoonup 上半钩右箭头   ↑ \\uparrow 上箭头   ⇑ \\Uparrow 上双线箭头   ↓ \\downarrow 下箭头   ⇓ \\Downarrow 下双线箭头   ↕ \\updownarrow 上下双向箭头   ⇕ \\Updownarrow 上下双向双线箭头    括号符号    符号 实现 名称     { \\lbrace 左花括号   } \\rbrace 右花括号   [ \\lbrack 左方括号   ] \\rbrack 右方括号   ⟨ \\langle 左尖括号   ⟩ \\rangle 右尖括号   ⌈ \\lceil 左上半框括号   ⌉ \\rceil 右上半框括号   ⌊ \\lfloor 左下半框括号   ⌋ \\rfloor 右下半框括号   | \\vert 竖线    其他符号    符号 实现 名称     ∞ \\infty 无穷   ∃ \\exists 存在   ∀ \\forall 任取   ∠ \\angle 角   ∂ \\partial 偏导数   ∅ \\emptyset 空集   ′ \\prime 质数   : \\colon 冒号   R \\Re 实部   I \\Im 虚部   … \\ldots 下三连点   ⋯ \\cdots 中三连点   ⋮ \\vdots 竖三连点   ⋱ \\ddots 斜三连点   √ \\surd 不尽根号   . \\ldotp 句点   → \\to 结论   ← \\gets 条件   ℓ \\ell 手写体小写 l   ı \\imath 数学小写无点 i   ȷ \\jmath 数学小写无点 j    ","description":"","id":313,"section":"blog","tags":["LaTeX"],"title":"一些 LaTeX 的符号","uri":"https://yorkfish.github.io/review/blog/08-latex/"},{"content":"说明  官网地址：\u0026gt;\u0026gt;\u0026gt; 传送门 RIME 在不同操作系统下有不同的名字     操作系统 RIME 的名称     Linux 中州韵   MacOS 鼠须管   Windows 小狼毫    安装  我把软件装在 D:\\Rime 安装时可以自定义用户文件夹，我指定的是 D:\\Rime\\MyConfigData  添加小鹤双拼 方法一  仓库地址：https://github.com/rime/rime-double-pinyin 下载文件 \u0026gt; 解压 将文档 double_pinyin_flypy.schema.yaml 拷贝到 MyConfigData 右键右下角输入法图标 \u0026gt; 输入法设定 \u0026gt; 勾选 小鶴雙拼 \u0026gt; 中 等待“维护”即可  方法二  右键右下角输入法图标 \u0026gt; 输入法设定 点击弹窗左下角的“获取更多输入方案”（需要登录 GitHub） 在弹窗的 Enter package name, URL, user/repo or downloaded ZIP to install: 后输入相应信息，等待安装 勾选 小鶴雙拼 -\u0026gt; 中 等待“维护”  激活特殊符号 设置   在 MyConfigData 新建文档 double_pinyin_flypy.custom.yaml\n  写入如下语句，保存退出\npatch: \u0026quot;punctuator/import_preset\u0026quot;: symbols \u0026quot;recognizer/patterns/punct\u0026quot;: \u0026quot;^/([A-Z|a-z]*|[0-9]|10)$\u0026quot;   右键右下角输入法图标 \u0026gt; 重新部署\n  说明  想在别的输入法，如“明月拼音”上用，新建 luna_pinyin_simp.custom.yaml，再来一遍即可 若懒得新建，可以直接把 {安装根目录}/weasel-0.14.3/data/symbols.yaml 的内容拷贝到 {安装根目录}/MyConfigData/default.custom.yaml 下  使用  从正则表达式 ^/([A-Z|a-z]*|[0-9]|10)$ 上看  / + 字母（大小写） / + 数字（零到十）   常用的，如  /fh 符号 /sx 数学符号 /xl 希腊字母   具体可在 {安装根目录}/weasel-0.14.3/data/symbols.yaml 中搜索 symbols 查看  添加五笔   仓库地址：https://github.com/rime/rime-wubi\n  方法与“小鹤双拼”一样\n  纯五笔比较方便\n  若想使用“五笔-拼音”，还需要安装“袖珍简化字拼音”，仓库地址：https://github.com/rime/rime-pinyin-simp\n  安装完成后，重新部署一下\n  添加英文 相关文件  B 站一位 UP 的视频下有链接 个人使用频率不高  具体操作  把文件 easy_en_dict.yaml 与 easy_en_schema.yaml 拷贝到 MyConfigData 右键右下角输入法图标 \u0026gt; 输入法设定 \u0026gt; 勾选 Easy English \u0026gt; 中 等待“维护”  更改功能键   打开 {安装根目录}/MyConfigData/default.custom.yaml\n  添加如下语句\n\u0026quot;ascii_composer/switch_key\u0026quot;: Caps_Lock: noop Shift_L: commit_code Shift_R: commit_code   重新部署\n  解释    模式 释义     inline_ascii 中文状态下输入字母、数字、符号、空格等，回车上屏   commit_text 中文状态下，已输入的候选文字以中文形式上屏，然后切至英文   commit_code 中文状态下，已输入的候选文字以英文形式上屏，然后切至英文   noop 屏蔽该切换键    取消一键多值 说明  个人打中文时用不到那么多选项，所以想“一一对应” 可以修改默认配置文件，也可以更改对应的输入法的配置文件 若只更改对应输入法的配置文件，“重新部署”会重置所做的修改 我用“双拼”较多，就只更改“双拼的配置”  操作   打开 {安装根目录}/MyConfigData/build/double_pinyin_flypy.schema.yaml\n  找到 half_shape，即半角，删除不想要的多值（sublime 的 \u0026lt;C-S-del\u0026gt; 派上用场）\nhalf_shape: \u0026quot;!\u0026quot;: {commit: \u0026quot;！\u0026quot;} \u0026quot;\\\u0026quot;\u0026quot;: {pair: [\u0026quot;“\u0026quot;, \u0026quot;”\u0026quot;]} \u0026quot;#\u0026quot;: \u0026quot;#\u0026quot; \u0026quot;$\u0026quot;: \u0026quot;￥\u0026quot; \u0026quot;%\u0026quot;: \u0026quot;%\u0026quot; \u0026quot;\u0026amp;\u0026quot;: \u0026quot;\u0026amp;\u0026quot; \u0026quot;'\u0026quot;: {pair: [\u0026quot;‘\u0026quot;, \u0026quot;’\u0026quot;]} \u0026quot;(\u0026quot;: \u0026quot;（\u0026quot; \u0026quot;)\u0026quot;: \u0026quot;）\u0026quot; \u0026quot;*\u0026quot;: \u0026quot;*\u0026quot; \u0026quot;+\u0026quot;: \u0026quot;+\u0026quot; \u0026quot;,\u0026quot;: {commit: \u0026quot;，\u0026quot;} \u0026quot;-\u0026quot;: \u0026quot;-\u0026quot; .: {commit: \u0026quot;。\u0026quot;} \u0026quot;/\u0026quot;: \u0026quot;/\u0026quot; \u0026quot;:\u0026quot;: {commit: \u0026quot;：\u0026quot;} \u0026quot;;\u0026quot;: {commit: \u0026quot;；\u0026quot;} \u0026quot;\u0026lt;\u0026quot;: \u0026quot;《\u0026quot; \u0026quot;=\u0026quot;: \u0026quot;=\u0026quot; \u0026quot;\u0026gt;\u0026quot;: \u0026quot;》\u0026quot; \u0026quot;?\u0026quot;: {commit: \u0026quot;？\u0026quot;} \u0026quot;@\u0026quot;: \u0026quot;@\u0026quot; \u0026quot;[\u0026quot;: \u0026quot;[\u0026quot; \u0026quot;\\\\\u0026quot;: \u0026quot;、\u0026quot; \u0026quot;]\u0026quot;: \u0026quot;]\u0026quot; \u0026quot;^\u0026quot;: {commit: \u0026quot;……\u0026quot;} _: \u0026quot;——\u0026quot; \u0026quot;`\u0026quot;: \u0026quot;`\u0026quot; \u0026quot;{\u0026quot;: \u0026quot;{\u0026quot; \u0026quot;|\u0026quot;: \u0026quot;|\u0026quot; \u0026quot;}\u0026quot;: \u0026quot;}\u0026quot; \u0026quot;~\u0026quot;: \u0026quot;~\u0026quot;   重新部署\n  删除记忆词语  若有词语打错，输入法并不知道其有错别字，仍会将其记录下来 删除方法  再打一遍，使用上下键选择到对应的词语 使用快捷键 Shift/Ctrl + Del 即可删除记录   ","description":"","id":314,"section":"blog","tags":["typewriting"],"title":"小狼毫的安装与使用","uri":"https://yorkfish.github.io/review/blog/07-rime-for-win10/"},{"content":"说明  官网地址：\u0026gt;\u0026gt;\u0026gt; 传送门 无需安装，解压即用 官网有两个版本  cmder-mini cmder-full 含有 git for windows    右键菜单 添加到右键菜单  在终端输入 Cmder.exe /REGISTER ALL  取消右键菜单   新建文档 *.bat\n  输入如下语句，保存并关闭\n@echo off Reg delete \u0026quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\Background\\shell\\Cmder\u0026quot; /f pause   以管理员身份运行\n  简单设置   设置快捷键：Win + Alt + p\n  General\n Interface language \u0026gt; en: English    General - Fonts\n Size \u0026gt; 24 Monospae 取消对勾    Features - Text cursor\n 对 vim 有用 Active console Text Cursor \u0026gt; Block    Features - Transparency\n 我暂时放弃了透明度 Active window transparency 取消对勾 Use separete transparency value for inactive window 取消对勾    ps  cmder-vim 配置文件路径：{安装根目录}\\vendor\\git-for-windows\\etc\\vimrc git-vim 配置文件路径：{安装根目录}\\etc\\vimrc Pycharm-IdeaVim 配置文件路径：C:\\Users\\{username}\\.ideavimrc  快捷键    键位 功能     Ctrl + t 建立新页签   Ctrl + Tab 切换页签   Ctrl + w 关闭页签   Alt + F4 关闭所有页签   Ctrl + 1 快速切换到第 1 个页签   Ctrl + n 快速切换到第 n 个页签   Alt + Enter 全屏   Ctr + r 历史命令搜索    设置分屏快捷键  Keys \u0026amp; Macro \u0026gt; 右上角输入框输入 split: Duplicate  设置 Ctrl + o 为向下分屏 设置 Ctrl + e 为向右分屏   ","description":"","id":315,"section":"blog","tags":["terminal"],"title":"cmder","uri":"https://yorkfish.github.io/review/blog/06-cmder/"},{"content":"Powershell  以管理员权限打开打开 Powershell   输入 Install-Module posh-git -Scope CurrentUser\n  系统询问是否“安装并导入 NuGet 提供程序”，输入 Y\n  系统询问是否“要从 PSGallery 安装模块”，输入 Y\n  输入 Install-Module oh-my-posh -Scope CurrentUser\n  系统询问是否“要从 PSGallery 安装模块”，输入 Y\n  输入 notepad $PROFILE\n  系统提示没有相关文件，并询问是否创建，点击 是(Y)\n  写入如下语句，保存并关闭\nImport-Module posh-git Import-Module oh-my-posh Set-Theme Paradox   重启 Powershell 即可\n  Windows Terminal  打开 Windows Terminal 会发现，它的外观也改了 可以配置一下字体  Ctrl + , 搜索 guid 添加 \u0026quot;fontFace\u0026quot;: \u0026quot;Cascadia Code PL\u0026quot;, 保存并关闭   ","description":"","id":316,"section":"blog","tags":["terminal"],"title":"Powershell 安装 oh-my-posh","uri":"https://yorkfish.github.io/review/blog/05-powershell-oh-my-posh/"},{"content":"说明  Windows 应用商店搜索安装 收集了一些快捷键  分屏    快捷键 功能     Alt + Shift + + 横向分屏   Alt + Shift + - 竖向分屏   Ctrl + Shift + t 打开新标签页   Ctrl + Shift + w 取消分屏/关闭当前标签页    调整分屏大小    快捷键 功能     Alt + Shift + 方向键 调整当前分屏区大小    光标跳转    快捷键 功能     Alt + 方向键 分屏间移动光标    翻页    快捷键 功能     Ctrl + Shift + PgUp/PgDn 上/下翻页    字体大小    快捷键 功能     Ctrl + 鼠标滚轮 调整窗口显示大小   ","description":"","id":317,"section":"blog","tags":["terminal"],"title":"Windows Terminal","uri":"https://yorkfish.github.io/review/blog/04-windows-terminal/"},{"content":"以 C 为例  格式：time + 可执行文件名 结果：除了可执行文件的运行结果，还有 real, user, sys 三个时间可供查看  ","description":"","id":318,"section":"blog","tags":["linux command"],"title":"Linux 命令 time","uri":"https://yorkfish.github.io/review/blog/03-linux-command-time/"},{"content":"摘要  记事本 CMD 颜色 文件名含 \u0026amp;  1. 打开记事本 C:\\Users\\York\u0026gt;notepad\rC:\\Users\\York\u0026gt;notepad hello.py\r2. 更改 CMD 背景颜色  命令：C:\\Users\\York\u0026gt;color f0 重启失效  3. 文件中出现 \u0026amp;  在命令行运行的文件，若文件名中包含 \u0026amp;，需要加引号  D:\\test\u0026gt;nvim \u0026quot;t\u0026amp;t\u0026quot;.py\rD:\\test\u0026gt;nvim \u0026quot;t\u0026amp;t.py\u0026quot;\rD:\\test\u0026gt;python \u0026quot;t\u0026amp;t.py\u0026quot;\rtest\rD:\\test\u0026gt;\r","description":"","id":319,"section":"blog","tags":["dos command"],"title":"dos 命令","uri":"https://yorkfish.github.io/review/blog/02-dos-command/"},{"content":"1. 二进制转十进制 例一 0b101.11  整数部分：1 * 22 + 0 * 21 + 1 * 20 小数部分：1 * 2-1 + 1 * 2-2   0b101.11 = 4 + 1 + 0.5 + 0.25 = 5.75  2. 十进制转二进制 例二 0.125   0.125 * 2 = 0.25, 取整数部分 0\n  0.25 * 2 = 0.5, 取整数部分 0\n  0.5 * 2 = 1, 取整数部分 1（到 1 为止）\n  0.125 = 0b0.001\n  例三 0.6875   0.6875 * 2 = 1.375, 取整数部分 1（整数取走就剩 0.375 了）\n  0.375 * 2 = 0.75, 取整数部分 0\n  0.75 * 2 = 1.5, 取整数部分 1\n  0.5 * 2 = 1, 取整数部分 1\n  0.6875 = 0b0.1011\n ","description":"","id":320,"section":"blog","tags":["basics"],"title":"进制转换","uri":"https://yorkfish.github.io/review/blog/01-binary-decimal-conversion/"}]