[{"content":"1. 最简易的窗口 1 2 3 4  import tkinter as tk window = tk.Tk() window.mainloop()   ps  默认标题：tk 默认大小：200x200  2. 更多设置  自定义标题内容：window.title(\u0026quot;YorkFish\u0026quot;) 自定义窗口大小：window.geometry(\u0026quot;300x200\u0026quot;) 自定义窗口位置：window.geometry(\u0026quot;+200+100\u0026quot;) 同时设置大小与位置：window.geometry(\u0026quot;300x200+200+100\u0026quot;)  1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"窗口","id":0,"section":"python","tags":null,"title":"01. window","uri":"https://yorkfish.github.io/review/python/tkinter/01_window/"},{"content":"1. 说明  __call__ 可以让实例对象能够像函数一样加小括号进行调用  2. 举例 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; class Test(object): ... def __init__(self): ... pass ... def __call__(self, *args, **kwargs): ... print(\u0026#34;Hello, I am YorkFish.\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; t() Hello, I am YorkFish. \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":1,"section":"python","tags":null,"title":"01. __call__","uri":"https://yorkfish.github.io/review/python/class/01-__call__/"},{"content":"1. 说明  复数在数学上没有绝对值这个概念 abs() 对复数使用时，是求模 一个复数的模 = sqrt(实部2 + 虚部2)  2. 举例 1 2 3  \u0026gt;\u0026gt;\u0026gt; abs(3 + 4j) 5.0 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":2,"section":"python","tags":null,"title":"01. abs()","uri":"https://yorkfish.github.io/review/python/bif/01_abs/"},{"content":"1. 两组运算符  and, or \u0026amp;, |  2. 四种情况 情况一  当运算对象（本质）为 True, False 时，两组运算符没有差别  1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; 1\u0026lt;2 and 3\u0026lt;4 True \u0026gt;\u0026gt;\u0026gt; 1\u0026lt;2 \u0026amp; 3\u0026lt;4 True \u0026gt;\u0026gt;\u0026gt;   情况二  当运算对象为数值变量（不止 0 与 1）时，有区别 \u0026amp;, | 进行二进制的按位逻辑运算  1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; 1 and 2 2 \u0026gt;\u0026gt;\u0026gt; 1 \u0026amp; 2 # 0001 \u0026amp; 0010 0 \u0026gt;\u0026gt;\u0026gt; 1 | 2 # 0001 | 0010 3 \u0026gt;\u0026gt;\u0026gt;   情况三  and + or 可以做“三目运算”  1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; 123 \u0026gt; 0 and 1 or -1 1 \u0026gt;\u0026gt;\u0026gt; 123 \u0026lt; 0 and 1 or -1 -1 \u0026gt;\u0026gt;\u0026gt;   情况四  两组运算符混合使用时  and, or 按正常逻辑进行返回 \u0026amp;, | 先把 True, False 转为 1, 0，再进行逻辑“与或”运算    1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; -3\u0026lt;-2\u0026lt;-1\u0026lt;False and True True \u0026gt;\u0026gt;\u0026gt; True | 2 # 0001 | 0010 = 0011 3 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":3,"section":"python","tags":null,"title":"01. add, or, \u0026, |","uri":"https://yorkfish.github.io/review/python/basics/01_and-or/"},{"content":"例一 1 2 3 4 5 6 7  def add2(x, y): return x + y new_func = add2 print(new_func is add2) # True print(new_func(3, 4)) # 7   例二  就像列表名表示列表地址，函数名也表示函数地址  1 2 3 4 5 6 7 8 9  def add2(x, y): return x + y def test(x, y, func): return func(x, y) print(test(3, 4, add2)) # 7   例三  闭包 = 函数块 + 创建它时的环境 当内层函数调用外层函数作用域中的变量时，外层函数调用结束后，会把内层函数涉及到的变量“送”给内层函数，以保证其正常运行  1 2 3 4 5 6 7 8 9 10 11  def add2(x, y): return x + y def test(x, y): def sum2(): return x + y return sum2 print(test(3, 4)()) # 7   ","description":"","id":4,"section":"python","tags":null,"title":"01. function","uri":"https://yorkfish.github.io/review/python/decorator/01_function/"},{"content":"1. Python 环境变量  因为 python 支持多版本安装，所以现在安装时默认没有勾选“添加到环境变量” 若只装一个版本，直接勾就好 若装了多个版本，想在命令行启动哪个，就在装那个时勾上  对比 Anaconda  有 Documentation 有 IDLE（Anaconda 也有，但需要设置） 有 test suit，这个可以不勾 有 py launcher  装了就可以用 py 代替 python 启动 方便多版本使用    注意  install for all user 需要提权 若自动添加环境变量，会添加三个  python 的 python scripts 的 py launcher 的    技巧   在命令行使用 where 命令可以查看路径，如\n C:\\Users\\York\u0026gt;where python    pip --version 查看的是 pip 包的路径\n  查看位数\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; import platform \u0026gt;\u0026gt;\u0026gt; platform.architecture() (\u0026#39;64bit\u0026#39;, \u0026#39;WindowsPE\u0026#39;) \u0026gt;\u0026gt;\u0026gt;     说明  安装目录下  doc 文件夹里面是说明文档 Lib 文件夹里面是 Python 自带的库（标准库）、包、模块 Lib\\site-packages 里面是安装的第三方库 Scripts 里面是用 Python 实现的脚本的入口程序，如 pip Tools 里面有一些用 Python 写的脚本、Demo   安装目录的上级目录  因为 py launcher 要管理多个版本，所以不能在某一个 python 目录中，而是在上级目录 py --list 列出所有安装的 Python py -0 效果同 py --list py -0p 显示完整路径    2. Anaconda 手动添加环境变量  若安装时没勾上“添加到环境变量”，则进行如下操作 左下角搜索“环境变量”并打开 选择用户的 Path 打开 新建“环境变量” 一路确定  我添加的具体路径  我的 Anaconda 装在 D:\\anaconda3，所以 添加 D:\\anaconda3 添加 D:\\anaconda3\\Library\\bin 添加 D:\\anaconda3\\Library\\mingw-w64\\bin 添加 D:\\anaconda3\\Scripts  若命令行无法启动  将 %USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps 下移至最下方 谁在前就优先调用谁 把 Python 相关放在上面，就调用它们 虚拟环境也是这个原理  ","description":"","id":5,"section":"python","tags":null,"title":"01. install","uri":"https://yorkfish.github.io/review/python/operation/01_install/"},{"content":"numpy 的用处  数学计算 形状计算 各种排序 傅里叶变换 线性代数计算 统计计算\n……  ","description":"","id":6,"section":"python","tags":null,"title":"01. 概述","uri":"https://yorkfish.github.io/review/python/numpy/01_overview/"},{"content":"1. 与 \u0026amp;  若参加与运算的是负数，则以补码形式表示二进制，然后“按位与”  作用  清零 取出数中指定位 保留数中指定位  2. 或 |  对一个数据的某些位定值为 1  3. 异或 ^ 作用  使特定位翻转  说明  XOR 也是异或的意思 与 0 异或，保留原值  举例   交换两个值，不用临时变量，不担心溢出\n1 2 3  a = a ^ b; b = b ^ a; a = a ^ b;     4. 取反 作用  使某数最后一位为零，如 a = a \u0026amp; ~1;  说明  ~ 优先级比算术运算符、关系运算符、逻辑运算符（! 除外）、其他位运算符都高  5. 左移 作用  左移 n 位，即乘以 22  说明  有的 C 编译程序自动将“乘二”运算用左移实现  6. 右移  对无符号数，高位补 0 对有符号数，高位补的数与编译有关  移入 0 的称为“逻辑右移” (gcc-32bit) 移入 1 的称为“算术右移”    7. 不同长度的数据进行位运算  系统会将二者进行右端对齐 将短的正数左端补 0  例 短的负数左端不什么 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { short a = -1; // 1000 0000 0000 0001  int b = 0; // 0000 0000 0000 0000 0000 0000 0000 0000  int c = a|b; char d[32]; itoa(c, d, 2); // 将 c 的 2 进制写入 d  printf(\u0026#34;%s\\n\u0026#34;, d); // 1111 1111 1111 1111 1111 1111 1111 1111  return 0; }    负数是以补码的形式存储的，所以需要把转换 转换后的原码：0b1000 0000 0000 0000 0000 0000 0000 0001 由此可见，是把符号位移到新的最高位，然后补 0  ","description":"","id":7,"section":"c","tags":null,"title":"01 位运算简介","uri":"https://yorkfish.github.io/review/c/bit/01_overview/"},{"content":"1. 一般形式  #define 标识符 字符串 如 #define PI 3.1415926  2. 一些约定  宏名一般习惯用大写字母表示 宏定义是用宏名代替一个字符串，也就是作简单的置换，不作正确性检查 宏定义不是 C 的语句，不必在行末加分号，如果加了分号，会连分号一起进行置换 通常，#define 命令写在文件开头，函数之前，作为文件一部分，在此文件范围内有效  3. 注意事项   可以用 #undef 命令终止宏定义的作用域\n1 2 3 4 5 6 7 8 9 10 11  #define G 9.8  void main() { // ... } #undef  void f1() { // ... }     进行宏定义时可以引用已定义的宏名，可以层层置换\n  对程序中用双引号括起来的字符串内的字符，即使与宏名相同，也不进行置换\n  宏定义是专门用于预处理命令的一个专用名词，它与定义变量的含义不同，只作字符替换，不分配内存空间\n  ","description":"","id":8,"section":"c","tags":null,"title":"01. 不带参宏定义","uri":"https://yorkfish.github.io/review/c/preprocessor/01_with_no_arguments/"},{"content":"1. 简介  一个 C 程序由一个或多个程序模块组成 每个程序模块作为一个源程序文件 一个源程序文件由一个或多个函数以及其他有关内容（如命令行、数据定义等）组成 C 程序的执行，从 main 函数开始，在 main 函数中结束 所有函数都是平行的，即在定义函数时是分别进行的，是相互独立的  2. 两种角度  从用户的角度看，函数有两种  标准函数 用户自定义的函数   从函数的形式看，函数分两类  无参函数 有参函数    ","description":"","id":9,"section":"c","tags":null,"title":"01. 函数概述","uri":"https://yorkfish.github.io/review/c/function/01_overview/"},{"content":"1. 优势  正确而灵活地运用指针，可以  有效地表示复杂的数据结构 动态分配内存 方便地使用字符串 有效而方便地使用数组 调用函数时，获得一个以上的结果 直接处理内存单元地址 。。。    2. 名词解释  指针\n一个地址  能找到以它的值为地址的内存单元 一个变量的地址称为该变量的指针   指针变量  存放地址的变量 它的值是地址    ","description":"","id":10,"section":"c","tags":null,"title":"01. 指针概述","uri":"https://yorkfish.github.io/review/c/pointer/01_overview/"},{"content":"1. 分类  基本类型 构造类型 指针类型 空类型  2. 常用的基本类型    类型名 写法 缩写     短整型 short int short   整型 int /   长整型 long int long   长整型 long long int long long     一般  sizeof(short) \u0026lt; sizeof(long) sizeof(short) \u0026lt;= sizeof(int) 或 sizeof(int) \u0026lt;= sizeof(long)    ","description":"","id":11,"section":"c","tags":null,"title":"01. 数据类型","uri":"https://yorkfish.github.io/review/c/basics/01_data_type/"},{"content":"1. 简介  每个被使用的文件都在内存中开辟一个区，用来存放文件的有关信息 这些信息是保存在一个结构体变量中的 该结构体类型是由系统定义的，取名为 FILE  2. stdio.h 中的文件类型声明 1 2 3 4 5 6 7 8 9 10 11 12 13  #ifndef _FILE_DEFINED  struct _iobuf { char *_ptr; // 指向文件输入的下一个位置  int _cnt; // 当前缓冲区的相对位置  char *_base; // 文件的起始位置  int _flag; // 文件状态标志  int _file; // 用于文件的有效性验证  int _charbuf; // 检查缓冲区状况，若无缓冲区，则不读取  int _bufsiz; // 缓冲区的大小  char *_tmpfname; // 临时文件名  }; typedef struct _iobuf FILE; #define _FILE_DEFINED   ","description":"","id":12,"section":"c","tags":null,"title":"01. 文件概述","uri":"https://yorkfish.github.io/review/c/file/01_overview/"},{"content":"一般声明形式 struct 结构体名 {\r成员列表\r};\r举例 1 2 3 4 5 6 7 8  struct student { char name[20]; char addr[30]; char gender; int age; int num; float score; };   ps   不要忽略最后的分号\n  “结构体名”用作结构体类型的标志，又称“结构体标记” structure tag\n  “成员列表” member list 又称“域表” field list\n  每一个成员也称为结构体中的一个域\n  ","description":"","id":13,"section":"c","tags":null,"title":"01. 结构体概述","uri":"https://yorkfish.github.io/review/c/struct-union-enum/01_overview_of_struct/"},{"content":"1. 官方文档  Hugo_quick-start: \u0026gt; 传送门 zdoc_theme: \u0026gt; 传送门 zdoc_quickstart: \u0026gt; 传送门  2. 初始化  假设本地站点名为 hugoblog  方法一  D:\\\u0026gt;hugo new site hugoblog  方法二  新建文件夹 hugoblog D:\\hugoblog\u0026gt;hugo new site .  3. 添加主题 方法一  打开网页：https://github.com/zzossig/hugo-theme-zdoc Code -\u0026gt; Download Zip 解压并重命名为 zdoc 将 zdoc 复制到 D:\\hugoblog\\themes  方法二  D:\\hugoblog\u0026gt;git clone https://github.com/zzossig/hugo-theme-zdoc.git themes/zdoc  方法三  如果使用 git 对站点进行版本控制  D:\\hugoblog\u0026gt;git submodule add https://github.com/zzossig/hugo-theme-zdoc.git themes/zdoc   更新方式  D:\\hugoblog\u0026gt;git submodule update --remote --merge    4. 预览 exampleSite  D:\\hugoblog\u0026gt;cd themes\\zdoc\\exampleSite D:\\hugoblog\\themes\\zdoc\\exampleSite\u0026gt;hugo server --themesDir ../..  ps  D:\\hugoblog\\themes\\zdoc\\exampleSite\\content\\en\\blog 中 rich-content 因为网络原因可能报错 删除文中用双花括号包裹的语句，即可成功预览 D:\\hugoblog\\themes\\zdoc\\exampleSite\\content\\ko\\blog 中也同样处理  ","description":"preview exampleSite","id":14,"section":"hugo","tags":null,"title":"Quick start","uri":"https://yorkfish.github.io/review/hugo/hugo_01/"},{"content":"官方文档：\u0026gt;\u0026gt;\u0026gt; 传送门\n1. 类型表    Type Code C Type Python Type Minimum size (bytes)     b signed char int 1   B unsigned char int 1   u Py_UNICODE Unicode character;\ndeprecated since Python 3.3 2   h signed short int 2   H unsigned short int 2   i signed int int 2   I unsigned int int 2   l signed long int 4   L unsigned long int 4   q signed long long int 8   Q unsigned long long int 8   f float float 4   d double float 8    2. 举例 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; from array import array \u0026gt;\u0026gt;\u0026gt; arr = array(\u0026#39;q\u0026#39;, (100, 200, 300)) \u0026gt;\u0026gt;\u0026gt; arr array(\u0026#39;q\u0026#39;, [100, 200, 300]) \u0026gt;\u0026gt;\u0026gt; arr[0] = 150 \u0026gt;\u0026gt;\u0026gt; arr array(\u0026#39;q\u0026#39;, [150, 200, 300]) \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":15,"section":"python","tags":null,"title":"01. array","uri":"https://yorkfish.github.io/review/python/module/01_array/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. 添加一个 label 1 2 3  l = tk.Label(window, text=\u0026#34;This is Label!\u0026#34;, bg=\u0026#34;green\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), width=20, height=2) l.pack()   ps  一般地，tkinter 的 width, height 的单位是“字符”  3. 字符串可以使用变量 1 2 3 4 5  string = tk.StringVar() string.set(\u0026#34;This is Label!\u0026#34;) l = tk.Label(window, textvariable=string, bg=\u0026#34;green\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 216), width=20, height=2) l.pack()   1 2 3 4 5 6 7 8 9 10 11 12 13  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) string = tk.StringVar() string.set(\u0026#34;This is Label!\u0026#34;) l = tk.Label(window, textvariable=string, bg=\u0026#34;green\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), width=20, height=2) l.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"标签控件","id":16,"section":"python","tags":null,"title":"02. Label","uri":"https://yorkfish.github.io/review/python/tkinter/02_label/"},{"content":"1. 简介  __dict__ 属性可以让用户查看类中包含的属性 __dict__ 可以用类名调用，也可以用类的实例对象调用     调用者 输出     类名 该类中所有类属性组成的字典   类的实例对象 该类中所有实例属性组成的字典    2. 举例 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; class Hero(object): ... def __init__(self, name, slogan): ... self.name = name ... self.slogan = slogan ... \u0026gt;\u0026gt;\u0026gt; Hero.__dict__ mappingproxy({\u0026#39;__module__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__init__\u0026#39;: \u0026lt;function Hero.__init__ at 0x000002325ADBE550\u0026gt;, \u0026#39;__dict__\u0026#39;: \u0026lt;attribute \u0026#39;__dict__\u0026#39; of \u0026#39;Hero\u0026#39; objects\u0026gt;, \u0026#39;__weakref__\u0026#39;: \u0026lt;attribute \u0026#39;__weakref__\u0026#39; of \u0026#39;Hero\u0026#39; objects\u0026gt;, \u0026#39;__doc__\u0026#39;: None}) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; lijing = Hero(\u0026#34;lijing\u0026#34;, \u0026#34;My hands, you will!\u0026#34;) \u0026gt;\u0026gt;\u0026gt; lijing.__dict__ {\u0026#39;name\u0026#39;: \u0026#39;lijing\u0026#39;, \u0026#39;slogan\u0026#39;: \u0026#39;My hands, you will!\u0026#39;} \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":17,"section":"python","tags":null,"title":"02. __dict__","uri":"https://yorkfish.github.io/review/python/class/02-__dict__/"},{"content":"1. 说明  any(), all() 都可以批量判断可迭代对象里的参数是否等价于 True 简单地说  any() : 有人 True，那就 True all() : 大家 True，才是 True    2. 举例 any   可以这样理解 any()\n1 2 3 4 5  def any(iterable): for element in iterable: if element: return True return False     0, '', False, None, [], (), {}, set() 均视作 False\n1 2 3  \u0026gt;\u0026gt;\u0026gt; any([0, \u0026#39;\u0026#39;, False, None, [], (), {}, set()]) False \u0026gt;\u0026gt;\u0026gt;     all   可以这样理解 all()\n1 2 3 4 5  def all(iterable): for element in iterable: if not element: return False return True     ","description":"","id":18,"section":"python","tags":null,"title":"02. any() \u0026 all()","uri":"https://yorkfish.github.io/review/python/bif/02_any_all/"},{"content":"1. 说明  若函数形如 test(arg, *args, **kwargs)，则  arg: 接收第一个参数 args: 若有，凑成元组 kwargs: 若有，凑成字典    2. 举例 1 2 3 4 5  def test(arg, *args, **kwargs): print(f\u0026#34;{arg=}, {args=}, {kwargs=}\u0026#34;) test(1, 2, student=\u0026#34;Tom\u0026#34;, teacher=\u0026#34;Jerry\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\narg=1, args=(2,), kwargs={'student': 'Tom', 'teacher': 'Jerry'}\r","description":"","id":19,"section":"python","tags":null,"title":"02. arg, args, kwargs","uri":"https://yorkfish.github.io/review/python/basics/02_arg_args_kwargs/"},{"content":"举例思路  不加装饰器 加装饰器  无参函数 带参函数  参数个数确定 参数个数不确定   装饰器带参 多个装饰器    例一 不加装饰器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def out(func): def inn(): start = perf_counter() func() stop = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; function\u0026#39;s run time:\u0026#34;, stop - start) return inn def append_str(): lst = [] for i in range(10000): lst.append(\u0026#34;YorkFish\u0026#34;) return None func = out(append_str) func()   例二 修改例一  装饰器就是在不改变函数原有功能且不改变原有代码逻辑下，增加函数的功能  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  from time import perf_counter def out(func): def inn(): start = perf_counter() func() stop = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; function\u0026#39;s run time:\u0026#34;, stop - start) return inn # 有顺序，要写在 out() 下面 @out def append_str(): lst = [] for i in range(10000): lst.append(\u0026#34;YorkFish\u0026#34;) return None append_str()   例三 不加 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from time import perf_counter def test(): lst = [] for _ in range(10000): lst.append(\u0026#34;YorkFish\u0026#34;) return None def cal_time(func): start = perf_counter() func() stop = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; function\u0026#39;s run time:\u0026#34;, stop - start) return None cal_time(test)   例四 加-无参函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  from time import perf_counter def cal_time(func): def inn(): start = perf_counter() func() stop = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; function\u0026#39;s run time:\u0026#34;, stop - start) return inn @cal_time def test(): lst = [] for _ in range(10000): lst.append(\u0026#34;YorkFish\u0026#34;) return None test()   例五 加-带参函数-参数个数确定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from time import perf_counter_ns def cal_time(func): def inn(x, y): start = perf_counter_ns() func(x, y) stop = perf_counter_ns() print(f\u0026#34;run time: {stop - start}ns\u0026#34;) return inn @cal_time def add2(x, y): print(x + y) return None add2(3, 4)   例六 加-带参函数-参数个数不确定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  from time import perf_counter_ns def cal_time(func): def inn(*args): start = perf_counter_ns() func(*args) stop = perf_counter_ns() print(f\u0026#34;run time: {stop - start}ns\u0026#34;) return inn @cal_time def add(*args): print(sum(args)) add(1, 2, 3, 4, 5)   例七 加-装饰器带参 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  from time import perf_counter_ns def out(num): print(\u0026#34;\u0026gt;\u0026gt; num =\u0026#34;, num) def cal_time(func): print(\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt; func =\u0026#34;, func) def inn(*args): print(\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; args =\u0026#34;, args) start = perf_counter_ns() func(*args) stop = perf_counter_ns() print(f\u0026#34;run time: {stop - start}ns\u0026#34;) return inn return cal_time @out(0) def add(*args): print(sum(args)) return None add(1, 2, 3, 4, 5)   例八 加多个装饰器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def deco1(func): print(\u0026#34;\u0026gt;\u0026gt; run decorator1\u0026#34;) def inn(): print(\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt; decorator1\u0026#39;s in\u0026#34;) func() return inn def deco2(func): print(\u0026#34;\u0026gt;\u0026gt; run decorator2\u0026#34;) def inn(): print(\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt; decorator2\u0026#39;s in\u0026#34;) func() return inn @deco2 # 西装 @deco1 # 衬衫 def test(): print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; run test\u0026#34;) return None test()   \u0026gt;\u0026gt;\u0026gt;\n\u0026gt;\u0026gt; run decorator1\r\u0026gt;\u0026gt; run decorator2\r\u0026gt;\u0026gt;\u0026gt;\u0026gt; decorator2's in\r\u0026gt;\u0026gt;\u0026gt;\u0026gt; decorator1's in\r\u0026gt;\u0026gt;\u0026gt; run test\r","description":"","id":20,"section":"python","tags":null,"title":"02. decorator-function","uri":"https://yorkfish.github.io/review/python/decorator/02_decorator_for_func/"},{"content":"1. 说明  n dimension array 简单地说，就是多维数组  2. 操作 导入 1  import numpy as np   创建 整数 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3, 4]) \u0026gt;\u0026gt;\u0026gt; a array([1, 2, 3, 4]) \u0026gt;\u0026gt;\u0026gt; print(a) [1 2 3 4] \u0026gt;\u0026gt;\u0026gt;   复数 1 2 3  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3, 4], dtype=complex) \u0026gt;\u0026gt;\u0026gt; print(a) [1.+0.j 2.+0.j 3.+0.j 4.+0.j]   二维 方式一 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3, 4], dtype=complex).reshape((2, 2)) \u0026gt;\u0026gt;\u0026gt; print(a) [[1.+0.j 2.+0.j] [3.+0.j 4.+0.j]] \u0026gt;\u0026gt;\u0026gt;   方式二 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; b = np.array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; print(b) [[1 2 3] [4 5 6]] \u0026gt;\u0026gt;\u0026gt;   “0 矩阵” 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = np.zeros((2, 2)) \u0026gt;\u0026gt;\u0026gt; print(a) [[0. 0.] [0. 0.]] \u0026gt;\u0026gt;\u0026gt;   “1 矩阵” 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = np.ones((2, 2)) \u0026gt;\u0026gt;\u0026gt; print(a) [[1. 1.] [1. 1.]] \u0026gt;\u0026gt;\u0026gt;   空矩阵 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = np.empty((2, 3)) \u0026gt;\u0026gt;\u0026gt; print(a) [[0. 0. 0.] [0. 0. 0.]] \u0026gt;\u0026gt;\u0026gt;   单位矩阵 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.eye(3) \u0026gt;\u0026gt;\u0026gt; print(a) [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] \u0026gt;\u0026gt;\u0026gt;   arange  用法与 range 相似  整数 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = np.arange(0, 10, 2) \u0026gt;\u0026gt;\u0026gt; print(a) [0 2 4 6 8] \u0026gt;\u0026gt;\u0026gt;   浮点数  由于有限的浮点精度，获得的元素个数可能与预期有些出入  1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.arange(0, 3, 0.2) \u0026gt;\u0026gt;\u0026gt; print(a) [0. 0.2 0.4 0.6 0.8 1. 1.2 1.4 1.6 1.8 2. 2.2 2.4 2.6 2.8] \u0026gt;\u0026gt;\u0026gt; type(a[0]) \u0026lt;class \u0026#39;numpy.float64\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;   均分 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = np.linspace(0, 3, 10) \u0026gt;\u0026gt;\u0026gt; print(a) [0. 0.33333333 0.66666667 1. 1.33333333 1.66666667 2. 2.33333333 2.66666667 3. ] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":21,"section":"python","tags":null,"title":"02. ndarray build","uri":"https://yorkfish.github.io/review/python/numpy/02_ndarray_build/"},{"content":"1. 查看配置文件地址 C:\\Users\\York\u0026gt;pip config list -v\rFor variant 'global', will try loading 'C:\\ProgramData\\pip\\pip.ini'\rFor variant 'user', will try loading 'C:\\Users\\York\\pip\\pip.ini'\rFor variant 'user', will try loading 'C:\\Users\\York\\AppData\\Roaming\\pip\\pip.ini'\rFor variant 'site', will try loading 'c:\\users\\york\\appdata\\local\\programs\\python\\python38\\pip.ini'\r answer: C:\\Users\\York\\AppData\\Roaming\\pip\\pip.ini  2. 使用命令写入文件 C:\\Users\\York\u0026gt;pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/\rWriting to C:\\Users\\York\\AppData\\Roaming\\pip\\pip.ini\r3. 使用命令查看内容  C:\\Users\\York\u0026gt;pip config edit --editor notepad  此时，记事本会打开 pip.ini    4. 更改镜像源   阿里镜像站：\u0026gt;\u0026gt;\u0026gt; 传送门 \n  选择 pypi\n  复制提供的命令，覆盖 pip.ini 的内容\n[global]\rindex-url = https://mirrors.aliyun.com/pypi/simple/\r[install]\rtrusted-host=mirrors.aliyun.com\r  ","description":"","id":22,"section":"python","tags":null,"title":"02. pip","uri":"https://yorkfish.github.io/review/python/operation/02_pip/"},{"content":"例一 随机数 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.random() # [0, 1.0) 0.010390541410120413 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; random.uniform(1, 10) # [1.0, 10.0) 2.2700210248026065 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; random.randrange(1, 10) # [1, 10) 3 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; random.randint(1, 10) # [1, 10] 8 \u0026gt;\u0026gt;\u0026gt;   ps   randint 其实是调用 randrange\n1 2  def randint(self, a, b): return self.randrange(a, b+1)     例二 抽取 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; menus = [\u0026#34;煲仔饭\u0026#34;, \u0026#34;黄焖鸡米饭\u0026#34;, \u0026#34;牛肉盖浇饭\u0026#34;, \u0026#34;排骨饭\u0026#34;, \u0026#34;芝士焗饭\u0026#34;] \u0026gt;\u0026gt;\u0026gt; random.choice(menus) \u0026#39;黄焖鸡米饭\u0026#39; \u0026gt;\u0026gt;\u0026gt; random.choices(menus, [1, 2, 3, 4, 5]) # choices; 加权 [\u0026#39;排骨饭\u0026#39;] \u0026gt;\u0026gt;\u0026gt; random.choices(menus, [1, 2, 3, 4, 5], k=2) # 别漏 \u0026#34;k=\u0026#34; [\u0026#39;排骨饭\u0026#39;, \u0026#39;排骨饭\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   ps  random.choices(population,weights=None,*,cum_weights=None,k=1) weights=[1, 2, 3, 4, 5], P(煲仔饭) = 1/(1+2+3+4+5) = 1/15  例三 抽取 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; menus = [\u0026#34;煲仔饭\u0026#34;, \u0026#34;黄焖鸡米饭\u0026#34;, \u0026#34;牛肉盖浇饭\u0026#34;, \u0026#34;排骨饭\u0026#34;, \u0026#34;芝士焗饭\u0026#34;] \u0026gt;\u0026gt;\u0026gt; random.sample(menus, k=2) # k \u0026lt;= len(menus) [\u0026#39;芝士焗饭\u0026#39;, \u0026#39;牛肉盖浇饭\u0026#39;] \u0026gt;\u0026gt;\u0026gt; random.sample(menus, 2) # 可省 \u0026#34;k=\u0026#34; [\u0026#39;排骨饭\u0026#39;, \u0026#39;牛肉盖浇饭\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   例四 打乱 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; random.shuffle(a) \u0026gt;\u0026gt;\u0026gt; a [3, 1, 4, 2, 5] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":23,"section":"python","tags":null,"title":"02. random","uri":"https://yorkfish.github.io/review/python/module/02_random/"},{"content":"1. 打开文件 fopen 一般形式 FILE * fp;\rfp = fopen(\u0026quot;filename\u0026quot;, \u0026quot;usemode\u0026quot;);\r打开模式    文件使用方式 含义     \u0026quot;r\u0026quot; 读，打开   \u0026quot;w\u0026quot; 写，打开   \u0026quot;a\u0026quot; 追加，打开   \u0026quot;rb\u0026quot; 读，二进制打开   \u0026quot;wb\u0026quot; 写，二进制打开   \u0026quot;ab\u0026quot; 追加，二进制打开   \u0026quot;r+\u0026quot; 读写，打开   \u0026quot;w+\u0026quot; 读写，新建   \u0026quot;a+\u0026quot; 读写，打开   \u0026quot;rb+\u0026quot; 读写，二进制打开   \u0026quot;wb+\u0026quot; 读写，二进制新建   \u0026quot;ab+\u0026quot; 读写，二进制打开    说明   输入文件：从文件读数据\n  输出文件：向文件写数据\n  如果不能实现“打开”的任务，fopen 函数将会带回一个出错信息，并返回空指针值 NULL\n  出错原因可能是\n 用 \u0026quot;r\u0026quot; 方式打开一个并不存在的文件 磁盘出故障 磁盘已满，无法建立新文件 。。。    有的版本只能用 \u0026quot;r\u0026quot;, \u0026quot;w\u0026quot;, \u0026quot;a\u0026quot;\n  有的版本用 \u0026quot;rw\u0026quot;, \u0026quot;wr\u0026quot;, \u0026quot;ar\u0026quot; 代替 \u0026quot;r+\u0026quot;, \u0026quot;w+\u0026quot;, \u0026quot;a+\u0026quot;\n  在向计算机输入文本文件时，回车换行会转换为一个换行符\n  在输出时，把换行符转换成为回车和换行两个字符\n  用二进制文件时，不进行这种转换\n  在程序开始运行时，系统自动打开三个标准文件\n 标准输入 stdin 标准输出 stdout 标准出错输出 stderr    2. 关闭文件 fclose 一般形式 fclose(fp);\n说明  先把缓冲区中的数据输出到磁盘文件，然后才释放文件指针变量  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; int main() { char* filename = \u0026#34;test.txt\u0026#34;; FILE* fp = fopen(filename, \u0026#34;r\u0026#34;); if (fp == NULL) { printf(\u0026#34;cannot open %s!\\n\u0026#34;, filename); printf(\u0026#34;let me help you to build it...\\n\u0026#34;); fp = fopen(filename, \u0026#34;w\u0026#34;); } fclose(fp); return 0; }   ","description":"","id":24,"section":"c","tags":null,"title":"02. fopen() \u0026 fclose()","uri":"https://yorkfish.github.io/review/c/file/02_fopen_and_fclose/"},{"content":"例一 取某几位数  求整数 a 右端的 4~7 位  原码：xxxx ... xxxx xxxx\r位数：xxxx ... 7654 3210\r1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { short a = 666; // 0b0000 0010 1001 1010  short b = (a\u0026gt;\u0026gt;4) \u0026amp; ~(~0 \u0026lt;\u0026lt; 4); char c[4]; itoa(b, c, 2); printf(\u0026#34;%s\\n\u0026#34;, c); // 1001  return 0; }   例二 循环移位  将 a 进行右循环移位 4 位  移位前：xxxx ... xxxx x???\r移位后：???x ... xxxx xxxx\r1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { unsigned short a = 666; // 0b0000 0010 1001 1010  unsigned short b = a\u0026lt;\u0026lt;(16-4) | a\u0026gt;\u0026gt;4; char c[16]; itoa(b, c, 2); printf(\u0026#34;%s\\n\u0026#34;, c); // 1010 0000 0010 1001  return 0; }   例三 改变字节中一个或几个二进制位  将整数 a 右端的 4~7 位改为 1101  1 2 3  data = (data \u0026amp; ~(15\u0026lt;\u0026lt;4)) | (n\u0026amp;15)\u0026lt;\u0026lt;4 -------- ------ 1111 ... 0000 1111 0 \u0026lt;= n\u0026#39; \u0026lt;= 15   1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { short a = 666; // 0b0000 0010 1001 1010  short b = 0b1101; short c = (a \u0026amp; ~(15\u0026lt;\u0026lt;4)) | (b\u0026amp;15)\u0026lt;\u0026lt;4; char d[16]; itoa(c, d, 2); printf(\u0026#34;%s\\n\u0026#34;, d); // 0000 0010 1101 1010  return 0; }   ","description":"","id":25,"section":"c","tags":null,"title":"02. 举例","uri":"https://yorkfish.github.io/review/c/bit/02_examples/"},{"content":"1. 默认类型  如果在定义函数时不指定函数类型，系统会隐含指定函数类型为 int 不推荐这样做  2. 空函数   形式\n1 2  void dummy() { }     调用此函数时，什么工作也不做，没有任何实际作用\n  等以后扩充函数功能时补上\n  ","description":"","id":26,"section":"c","tags":null,"title":"02. 函数定义","uri":"https://yorkfish.github.io/review/c/function/02_general_form/"},{"content":"1. 一般形式  #define 宏名(参数表) 字符串 如  定义：#define S(a,b) a*b 使用：area = S(3, 2); // 矩形边长    2. 两个注意点 坑一 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; #define S(a,b) a*b  int main() { int area = S(5, 5+10); // 5 X 15  printf(\u0026#34;%d\\n\u0026#34;, area); // 35  return 0; }     解释\n area = S(5, 5+10); \u0026gt; area = 5*5+10; \u0026gt; area = 35;    改正\n #define S(a,b) (a)*(b)    坑二 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; #define S (a,b) a*b // S 后多了个空格  int main() { int area = S(5, 5+10); // 报错  printf(\u0026#34;%d\\n\u0026#34;, area); return 0; }    解释  宏名与带参数的括号之间不应加空格 第一个空格以后的字符都放会作为代替字符串 int area = S(5, 5+10); \u0026gt; int area = (a,b) a*b(5, 5+10); \u0026gt; 报错    3. 说明  函数调用时，先求出实参表达式的值，再带入形参 函数调用是在程序运行时处理的，为形参分配临时的内存单元 宏展开是在编译前进行的，展开时并不分配内存空间，不进行值的传递，也没有返回值的概念 对函数中的实参和形参都要定义类型，二者要求一致，如不一致，应进行类型转换 宏不存在类型问题，宏名无类型，它的参数也无类型，只是一个符号代表 展开时代入指定的字符串即可 宏定义时，字符串可以是任何类型的数据  字符：#define CHAR1 CHINA 数值：#define a 3.6 。。。    4. 取舍  通过宏展开可以得到若干个结果 使用宏次数多时，宏展开后源程序变长，因为每展开一次都使得程序增长 函数调用不会使源程序变长 宏替换不占用运行时间，只占用编译时间 函数调用占运行时间（分配单元、保留现场、值传递、返回） 一般用宏来代表简短的表达式比较合适 有些问题，用宏和函数都可以  5. 补充  可以写出各种输入输出的格式，如  单精度浮点型、双精度浮点型 长整型 十六进制整数、八进制整数 字符型 。。。   把它们单独编成一个文件，相当一个“格式库” 用 #include 命令“包括”到自己所编的程序中  ","description":"","id":27,"section":"c","tags":null,"title":"02. 带参宏定义","uri":"https://yorkfish.github.io/review/c/preprocessor/02_with_parameters/"},{"content":"1. 定义 1 2 3  int i; int * pointer_1; pointer_1 = \u0026amp;i;    将变量 i 的地址存放到指针变量 pointer_1 中，pointer_1 “指向”了变量 i 指针变量中只能存放地址（指针）  2. 两个运算符  \u0026amp;: 取地址运算符 *: 指针运算符，取指针所指向的对象的内容  ps   \u0026amp;, *, ++ 优先级相同，一般按“自右而左”方向结合\n  参照\n1 2  int num = 10; int* p = \u0026amp;num;     下方左右写法等价\n     左 右     \u0026amp;*p \u0026amp;num   *\u0026amp;num num   (*p)++ num++   *p++ *(p++)    3. 反例 例一 1 2 3 4 5 6  void swap(int* p1, int* p2) { int* temp; *temp = *p1; // 这句有问题，因为 temp 没有指向某片地址  *p1 = *p2; *p2 = *temp; }   例二 1 2 3 4 5 6  void swap(int a, int b) { int t; t = a; a = b; b = t; }    这是“单向传递”的“值传递”方式 形参值的改变不能使实参的值随之改变  例三 1 2 3 4 5 6  void swap(int* p1, int* p2) { int *p; p = p1; p1 = p2; p2 = p; }    swap 中，指针的指向对调了，但不改变实参的地址 这里不要多想，直接通过地址改值就行  ","description":"","id":28,"section":"c","tags":null,"title":"02. 指针的定义与使用","uri":"https://yorkfish.github.io/review/c/pointer/02_definition_and_use_of_pointer/"},{"content":" ANSI C 标准没有规定标识符的长度（字符个数） C 标准建议至少应能识别 31 个字符 若两个标识符很长，但不同之处在头部的可识别范围内，则编译器可辨别  ","description":"","id":29,"section":"c","tags":null,"title":"02. 标识符长度","uri":"https://yorkfish.github.io/review/c/basics/02_length_of_identifier/"},{"content":"1. 更换配置文件  删除博客根目录的 config.toml 复制 D:\\hugoblog\\themes\\zdoc\\exampleSite 的 4 个文件夹到博客根目录  ps  不复制，按照主题的说明文档依次新建也行  2. 部分结构   新的配置文件路径 D:hugoblog\\config\\_default\n  文件结构\nroot\r├── config\r│ ├── _default\r│ │ ├── config.toml\r│ │ ├── languages.toml\r│ │ ├── menus.en.toml\r│ │ ├── menus.ko.toml\r│ │ ├── params.toml\r  3. 配置 3.1 menus   删去 _default 中的 menus.en.toml, menus.ko.toml\n  新建 menus.zh.toml，并写入如下语句\n[[main]]\ridentifier = \u0026quot;hugo\u0026quot;\rname = \u0026quot;Hugo\u0026quot;\rurl = \u0026quot;hugo\u0026quot;\rweight = 1\r  3.2 cofnig  打开 cofnig.toml，依次搜索到下方四句  baseURL = \u0026quot;http://example.org\u0026quot; defaultContentLanguage = \u0026quot;en\u0026quot; hasCJKLanguage = false copyright = \u0026quot;\u0026amp;copy;{year}, All Rights Reserved\u0026quot;   修改至如下  baseURL = \u0026quot;https://yorkfish.github.io/review\u0026quot; defaultContentLanguage = \u0026quot;zh\u0026quot; hasCJKLanguage = true copyright = \u0026quot;\u0026amp;copy;2020, All Rights Reserved\u0026quot;   解释  review 是远程仓库名 zh 需要后续设置，详见下方 4. 添加语言环境 CJK 依次表示“中文”、“日文”、“韩文” 若 copyright “跨年”，可以这样：2020-{year}    3.3 languages   打开 languages.toml，并添加如下语句\n[zh]\rtitle = \u0026quot;York's blog\u0026quot;\rlanguageName = \u0026quot;中文\u0026quot;\rweight = 3\rcontentdir = \u0026quot;content\u0026quot;\r  3.4 params  打开 params.toml，依次搜索到下方三句  logoText = \u0026quot;ZDoc\u0026quot; enableLangChange = true github = \u0026quot;https://github.com/zzossig/hugo-theme-zdoc\u0026quot;   修改至如下  logoText = \u0026quot;YorkFish\u0026quot; enableLangChange = false github = \u0026quot;https://github.com/YorkFish/git_study\u0026quot;   解释  logoText 对应左上角的标题 enableLangChange 对应语言切换按钮 github 对应右上角的 GitHub 按钮    4. 添加语言环境 方法一   切换路径至 D:\\hugoblog\\themes\\zdoc\\i18n\n  新建 zh.toml，并写入如下语句\n[toc-label]\rother = \u0026quot;文章目录\u0026quot;\r[tooltip-written]\rother = \u0026quot;Written At\u0026quot;\r[tooltip-modified]\rother = \u0026quot;Modified At\u0026quot;\r[tooltip-reading-time]\rother = \u0026quot;Reading Time\u0026quot;\r[summary-dateformat]\rother = \u0026quot;2006/01/02\u0026quot;\r[reading-time]\rother = \u0026quot;min read\u0026quot;\r[single-writtenBy]\rother = \u0026quot;WRITTEN BY\u0026quot;\r[edit-this-page]\rother = \u0026quot;EDIT THIS PAGE\u0026quot;\r  方法二  在博客根目录新建文件夹 i18n 新建 zh.toml，并写入方法一的语句  ","description":"config","id":30,"section":"hugo","tags":null,"title":"Configuration","uri":"https://yorkfish.github.io/review/hugo/hugo_02/"},{"content":"1. 先声明，再定义 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; }; int main() { struct student st1; return 0; }   2. 声明的同时定义 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; } st1; int main() { return 0; }   3. 直接定义 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; struct { char name[20]; char gender; int num; } st1; int main() { return 0; }   ps   类型与变量是不同的概念\n  结构体中的成员，即域，可以单独使用\n  成员也可以是一个结构体变量\n1 2 3 4 5 6 7 8 9 10 11 12  struct date { int year; int month; int day; }; struct student { char name[20]; char gender; int num; struct date birthday; };     成员名可以与程序中的变量名相同，二者不代表同一对象\n  ","description":"","id":31,"section":"c","tags":null,"title":"02. 定义方法","uri":"https://yorkfish.github.io/review/c/struct-union-enum/02_define/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8 9 10 11  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) string = tk.StringVar() string.set(\u0026#34;This is Label!\u0026#34;) l = tk.Label(window, textvariable=string, bg=\u0026#34;green\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), width=20, height=2) l.pack() window.mainloop()   2. 添加一个 button 1 2 3  b = tk.Button(window, text=\u0026#34;hit me\u0026#34;, bg=\u0026#34;white\u0026#34;, font=(\u0026#34;Arial\u0026#34;, 12), width=10, height=2, command=hit_me) b.pack()   3. hit_me 方法  需要写在调用它的语句的上方  1 2 3 4 5 6 7 8 9 10 11  on_hit = False def hit_me(): global on_hit if not on_hit: on_hit = True string.set(\u0026#34;you hit me\u0026#34;) else: on_hit = False string.set(\u0026#34;你过来呀！\u0026#34;)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) string = tk.StringVar() string.set(\u0026#34;This is Label!\u0026#34;) l = tk.Label(window, textvariable=string, bg=\u0026#34;green\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), width=20, height=2) l.pack() on_hit = False def hit_me(): global on_hit if not on_hit: on_hit = True string.set(\u0026#34;you hit me\u0026#34;) else: on_hit = False string.set(\u0026#34;你过来呀！\u0026#34;) b = tk.Button(window, text=\u0026#34;hit me\u0026#34;, bg=\u0026#34;white\u0026#34;, font=(\u0026#34;Arial\u0026#34;, 12), width=10, height=2, command=hit_me) b.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"按钮","id":32,"section":"python","tags":null,"title":"03. Button","uri":"https://yorkfish.github.io/review/python/tkinter/03_button/"},{"content":"1. 说明  __new__() 先于 __init() 被调用 先执行 __new__()，生成一个实例对象 再执行 __init__()，对生成的对象进行初始化  2. 举例  一般很少用到 __new__() 当继承一个不可变的类型变量时，需要重写  1 2 3 4 5 6 7 8 9 10 11  class CapStr(str): def __new__(cls, string): print(\u0026#34;using __new__\u0026#34;) string = string.upper() return str.__new__(cls, string) def __init__(self, string): print(\u0026#34;using __init__\u0026#34;) a_str = CapStr(\u0026#34;I am YorkFish.\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\nusing __new__\rusing __init__\r","description":"","id":33,"section":"python","tags":null,"title":"03. __new__","uri":"https://yorkfish.github.io/review/python/class/03-__new__/"},{"content":"1. 说明  a \u0026lt; b \u0026lt; c \u0026lt; ... \u0026lt; n-1 \u0026lt; n 会被转换为 a \u0026lt; b and b \u0026lt; c and ... and n-1 \u0026lt; n 若 a \u0026lt; b 为 False，则后面内容会被短路 a \u0026lt; b \u0026gt; c 也是合法的  2. 举例 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; -3 \u0026lt; -2 \u0026lt; -1 True \u0026gt;\u0026gt;\u0026gt; 1 \u0026lt; 5 \u0026gt; 2 True \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":34,"section":"python","tags":null,"title":"03. compare","uri":"https://yorkfish.github.io/review/python/basics/03_compare/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12  def deco(clss): clss.x = 1 clss.y = 2 return clss @deco class Person(object): pass print(Person.__dict__)   \u0026gt;\u0026gt;\u0026gt;\n{'__module__': '__main__', '__dict__': \u0026lt;attribute '__dict__' of 'Person' objects\u0026gt;, '__weakref__': \u0026lt;attribute '__weakref__' of 'Person' objects\u0026gt;, '__doc__': None, 'x': 1, 'y': 2}\r","description":"","id":35,"section":"python","tags":null,"title":"03. decorator-class","uri":"https://yorkfish.github.io/review/python/decorator/03_decorator_for_class/"},{"content":"1. 说明  del 不会去操作内存，它只是删除了变量的引用 当某片内存空间没有引用的时候，该片空间会自动释放  2. 举例 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = a \u0026gt;\u0026gt;\u0026gt; id(a) # 每次分配的地址不一定相同 2130114338560 \u0026gt;\u0026gt;\u0026gt; id(b) 2130114338560 \u0026gt;\u0026gt;\u0026gt; del a \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":36,"section":"python","tags":null,"title":"03. del()","uri":"https://yorkfish.github.io/review/python/bif/03_del/"},{"content":"1. 创建 1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; a = np.arange(12).reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt;   2. 查看性质   数组的轴（维度）\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.ndim 2 \u0026gt;\u0026gt;\u0026gt;     数组的形状\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.shape (3, 4) \u0026gt;\u0026gt;\u0026gt;     数组的元素个数\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.size 12 \u0026gt;\u0026gt;\u0026gt;     数组中元素的类型\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.dtype dtype(\u0026#39;int32\u0026#39;) \u0026gt;\u0026gt;\u0026gt;     数组中每个元素所占字节数\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.itemsize 4 \u0026gt;\u0026gt;\u0026gt;     存储数组内元素内存缓冲区地址（不常用）\n1 2 3  \u0026gt;\u0026gt;\u0026gt; a.data \u0026lt;memory at 0x000001A54B307790\u0026gt; \u0026gt;\u0026gt;\u0026gt;     3. 较大的数组 默认  对较大的数组，默认以省略的形式打印  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = np.arange(10000).reshape((100, 100)) \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 ... 97 98 99] [ 100 101 102 ... 197 198 199] [ 200 201 202 ... 297 298 299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]] \u0026gt;\u0026gt;\u0026gt;   自定义 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; np.set_printoptions(threshold=10000) \u0026gt;\u0026gt;\u0026gt; a = np.arange(10000).reshape((100, 100)) \u0026gt;\u0026gt;\u0026gt; print(a) # threshold \u0026gt;= 数字个数，所有数字都会打印 # 1W 个数字挺多的，这里就不打印了   ","description":"","id":37,"section":"python","tags":null,"title":"03. ndarray attribute","uri":"https://yorkfish.github.io/review/python/numpy/03_ndarray_attribute/"},{"content":"1. 简介  Python3 要使用 reduce 需要从 functools 导入 reduce: 规约，可以使各元素按顺序进行计算，每次计算结果会参与到下次计算中  2. 举例 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; from functools import reduce \u0026gt;\u0026gt;\u0026gt; def mul(a, b): ... return a * b ... \u0026gt;\u0026gt;\u0026gt; lst = [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; reduce(mul, lst) # f(f(f(1, 2), 3), 4) 24 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":38,"section":"python","tags":null,"title":"03. reduce","uri":"https://yorkfish.github.io/review/python/module/03_reduce/"},{"content":"1. fgetc 简介  从指定的文件读入一个字符，该文件必须是以读或写方式打开的  一般形式 char ch = fgetc(fp); // fp 为文件型指针变量\n说明   如果在执行 fgetc 函数读字符时遇到文件结束符，函数返回一个结束标志 EOF，即 -1\n  EOF 不是可输出字符，因此无法打印\n  其实，EOF 就是 ASCII（扩展）表的第 255 位\n char i = -1; // 补码：0b1111 1111 =\u0026gt; 255    ANSI C 之后允许用缓冲文件系统处理二进制文件，而读入的某个字节中的二进制数据的值可能为 -1\n  ANSI C 提供了一个 feof 函数来判断文件是否真的结束\n feof(fp) == 1 =\u0026gt; 真 feof(fp) == 0 =\u0026gt; 假    例一  从一个磁盘文件顺序读入字符，并打印  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); char c = fgetc(fp); while (c != EOF) { putchar(c); c = fgetc(fp); } fclose(fp); return 0; }   例二  顺序读入一个二进制文件中的数据，并打印  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); char c; while (!feof(fp)) { c = fgetc(fp); putchar(c); } fclose(fp); return 0; }    这种方法也适用于文本文件 Windows 下，行末的回车、换行，打印时的效果是“两次回车”  2. fputc 简介  把一个字符写到磁盘文件上去  一般调用形式 fputc(ch, fp);\n说明   fputc 函数带一个返回值\n 若输出成功，返回值就是输出的字符 若输出失败，返回一个 EOF，即 -1    putchar 其实是从 fputc 派生出来的\n #define putchar(ch) fputc(ch, stdout) 作用：将 ch 的值输出到终端    例三 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;a\u0026#34;); fputc(\u0026#39;y\u0026#39;, fp); fclose(fp); return 0; }   3. 等价写法  fputc 和 putc 等价 fgetc 和 getc 等价 可以少写一个字母~  ","description":"","id":39,"section":"c","tags":null,"title":"03. fgetc() \u0026 fputc()","uri":"https://yorkfish.github.io/review/c/file/03_fgetc_and_fputc/"},{"content":"1. 作用  声明新的类型名，代替已有的类型名  2. 简介  用 typedef 可以声明各种类型名，但不能用来定义变量 #define 是在预编译时处理的，它只能作简单的字符串替换 typedef 是在编译时处理的，实际上，它不是作简单的替换 使用 typedef 有利于程序的通用与移植  如，将 typedef int INTEGER; 改为 typedef long INTEGER;    3. 举例 例一 1 2  typedef int COUNT; COUNT i, j;   例二 1 2 3 4 5 6 7 8 9  typedef struct { int year; int month; int day; } DATE, *pDate; DATE birthday; DATE* p1; pDate p2;   例三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;stdio.h\u0026gt; typedef int NUMS[10]; // 声明 NUMS 为整型数组类型  int main() { NUMS nums; // 说白了，就是让 nums 替换 \u0026#34;int NUMS[10];\u0026#34; 中的 NUMS  for (int i = 0; i \u0026lt; 10; i++) { nums[i] = i; } for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d\\n\u0026#34;, nums[i]); } return 0; }    定义的方法（不是推导，是操作步骤）  先按定义数组变量形式书写 int nums[100]; 将变量名 nums 换成自己指定的类型名 int NUMS[100]; 在前面加上 typedef 得到 typedef int NUM[100]; 用来定义变量 NUMS nums;    例四 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; typedef char * STRING; // 声明 STRING 为字符指针类型  int main() { STRING pStr1 = \u0026#34;york\u0026#34;; STRING pStr2 = \u0026#34;fish\u0026#34;; STRING s[] = {pStr1, pStr2}; printf(\u0026#34;%s\\n\u0026#34;, s[0]); printf(\u0026#34;%s\\n\u0026#34;, s[1]); return 0; }   例五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;stdio.h\u0026gt; typedef int (*POINTER)(); // 声明 POINTER 为指向函数的指针类型，该函数返回整型值  int test() { return 1; } int main() { POINTER p; p = test; printf(\u0026#34;%d\\n\u0026#34;, p()); return 0; }   ","description":"","id":40,"section":"c","tags":null,"title":"03. typedef","uri":"https://yorkfish.github.io/review/c/struct-union-enum/03_typedef/"},{"content":"1. 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int main() { int arr1[4] = {1, 2, 3, 4}; int arr2[] = {1, 2, 3, 4}; int* p1 = arr1; int* p2 = \u0026amp;arr1[0]; int arr3[5] = {0}; // 0, 0, 0, 0, 0  int arr4[5] = {1, 2, 3}; // 1, 2, 3, 0, 0  // c99, c11, c18  int arr5[10] = {[1]=2, 4, [5]=6}; // 0, 2, 4, 0, 0, 6, 0, 0, 0, 0  return 0; }   2. 使用 例一 索引 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { int arr[] = {1, 2, 3, 4}; int* p = arr; printf(\u0026#34;%d\\n\u0026#34;, arr[0]); // 1  printf(\u0026#34;%d\\n\u0026#34;, *(arr+1)); // 2  printf(\u0026#34;%d\\n\u0026#34;, p[2]); // 3  printf(\u0026#34;%d\\n\u0026#34;, *(p+3)); // 4  return 0; }    Tip: *(arr+i) 等价于 arr[i]  例二 传参 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt; void f1(int arr[], int arrSize) { for (int i = 0; i \u0026lt; arrSize; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } printf(\u0026#34;\\n\u0026#34;); } void f2(int* arr, int arrSize) { for (int i = 0; i \u0026lt; arrSize; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int arr[] = {1, 2, 3, 4}; int arrSize = 4; f1(arr, arrSize); f2(arr, arrSize); return 0; }    Tip: f(int arr[], int n) 等价于 f(int* arr, int n) C 编译都是将形参数组名作为指针变量来处理的  ","description":"","id":41,"section":"c","tags":null,"title":"03. 一维数组与指针","uri":"https://yorkfish.github.io/review/c/pointer/03_arrays_and_pointers-1/"},{"content":"1. 简介  C 语言允许在结构体中以位为单位，来指定其成员所占内存长度 这种以位为单位的成员称为“位段”或“位域” bit field 利用位段能够利用较少的位数存储数据 位段成员的类型必须指定为 unsigned 或 int  2. 举例 例一 1 2 3 4 5 6 7 8 9  struct packed_data { unsigned a: 4; unsigned b: 12; unsigned c: 8; unsigned d: 8; int i; } data; // a b c d i // (4 )(12 )(8 )(8 )(32...)    a, b, c, d 分别占 4 位，12 位，8 位，8 位 i 为整型，占 4 个字节  例二  可以使各个位段不占满一个字节  1 2 3 4 5 6 7 8  struct packed_data { unsigned a: 4; unsigned b: 12; unsigned c: 8; int i; } data; // a b c i // (4 )(12 )(8 )(xxxxxxxx)(32...)    在存储单元中，位段的分配方向因机器而异 在微机使用的 C 系统中，一般是“由右到左”进行分配的  例三  位段中的数据引用的方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;stdio.h\u0026gt; struct packed_data { unsigned a: 4; unsigned b: 12; unsigned c: 8; int i; } data; int main() { data.a = 16; data.b = 1; data.c = 2; data.i = 3; printf(\u0026#34;%d\\n\u0026#34;, data.a); // 0，有 warning  return 0; }    注意位段允许的最大值范围 a 占 4 位，最大值为 15，给多了，只截取低位  3. 新字节放位段   若某一位段要从另一个字节开始存放，可以用以下形式定义\n1 2 3 4 5 6  struct data { unsigned a: 1; //  unsigned b: 2; // 头两句是一个存储单元  unsigned : 0; unsigned c: 3; // 这是另一个存储单元 };     unsigned :0; 的作用：使下一个位段从下一个存储单元开始存放\n  上述“存储单元”可能是一个字节，也可能是两个字节，视不同的编译器而异\n  一个位段必须存储在同一单元中，不能跨两个单元\n  如果第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段\n  4. 无名位段 1 2 3 4 5 6  struct data { unsigned a: 1; unsigned : 2; // 这两位空间不用，此为“无名位段”  unsigned b: 3; unsigned c: 4; };    位段的长度不能大于存储单元的长度，也不能定义位段数组 位段可以用整型格式符输出，例如  printf(\u0026quot;%d, %d, %d\\n\u0026quot;, data.a, data.b, data.c); 也可以用 %u, %o, %x 等格式符输出   位段可以在数值表达式中引用，它会被系统自动地转换成整型数，例如  int num = data.a + 5/data.b;    ","description":"","id":42,"section":"c","tags":null,"title":"03. 位段","uri":"https://yorkfish.github.io/review/c/bit/03_bit_field/"},{"content":"1. 形参  形参，在未出现函数调用时，它们并不占内存中的存储单元 只有在发生函数调用时，形参才被分配内存单元 在调用结束后，形参所占的内存空间也被释放  2. 实参  实参可以是常量、变量或表达式 实参与形参的类型应相同或复制兼容 实参向形参的数据传递是“值传递”，即单向传递 调用结束后，形参单元被释放  3. 返回值 写法  以下方两种写法等价  return z; return (z);   z 可以是一个表达式  ps  函数类型决定返回值类型 若函数值的类型和 return 语句中表达式的值不一致，则以函数类型为准  ","description":"","id":43,"section":"c","tags":null,"title":"03. 函数的参数与返回值","uri":"https://yorkfish.github.io/review/c/function/03_params_and_ret_values/"},{"content":"1. 前提  .h + .c  2. 编译  在编译时并不是对两个文件分别进行编译，然后再将它们的目标程序连接的 而是在经过编译预处理后将头文件 .h 包含到主文件中，得到一个新的源程序 然后对这个文件进行编译，得到一个目标文件 .obj 被包含的文件成为新的源文件的一部分，而单独生成目标文件  3. 约定  这种常用在文件头部的被包含的文件称为“标题文件”或“头文件”常以 .h 为后缀 用 .c 甚至不用都行，但 .h 作后缀更能表示此文件的性质  4. 优势  如果要修改程序中的一些参数，可以不修改每个程序，只需把这些参数放在一个头文件中 注意：被包含的文件修改后，凡包含此文件的所有文件都要全部重新编译  5. 说明   一个 #include 命令只能指定一个被包含文件，如果要包含 n 个，就用 n 个命令\n  如果“文件1”包含“文件2”，“文件2”要用到“文件3”，则可在“文件1”中用两个 #include\n 注意，先包含“文件3”，再包含“文件2” 不过这种情况有特殊性    \u0026lt;.h\u0026gt; -\u0026gt; 系统到存放 C 库函数头文件的目录中寻找要包含的文件，此为标准方式\n  \u0026quot;.h\u0026quot; -\u0026gt; 系统先到用户当前目录中寻找要包含的文件，若找不到，再按标准方式查找\n  使用对应方式包含可以节省时间\n  预编译后，将成为一个文件，如果 .h 中有全局变量，它在 .c 中也有效，不必用 extern 声明\n  ","description":"","id":44,"section":"c","tags":null,"title":"03. 导入","uri":"https://yorkfish.github.io/review/c/preprocessor/03_include/"},{"content":"1. 补码  数值是以补码形式存储的 正数：原码 = 反码 = 补码 负数  反码：原码除符号位，按位取反 补码：原码除符号位，按位取反再加 1    2. unsigned int  一个整数常量后面加一个字母 u 或 U，则认为是 unsigned int  例：-12345u 的存储 1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\\n\u0026#34;, -12345u); // -12345 (-1 X 12345)  printf(\u0026#34;%u\\n\u0026#34;, -12345u); // 4294954951  return 0; }     -12345 原码：0b1000 0000 0000 0000 0011 0000 0011 1001\n  -12345 反码：0b1111 1111 1111 1111 1100 1111 1100 0110\n  -12345 补码：0b1111 1111 1111 1111 1100 1111 1100 0111\n  0b11111111111111111100111111000111 = 4294954951\n  计算机先将 -12345 转换成其补码 4294954951，再按无符号数存储\n  3. long int  一个整数常量后面加一个字母 l 或 L，则认为是 long int  用法 1 2 3 4 5 6 7  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%ld\\n\u0026#34;, 1L); // %ld 是 long int 的格式字符  return 0; }   ps  使用 gcc 编译时，如果使用了 -Wall 参数，%lld 会有 warning Windows 下消除 warning 的两种方法  用 %I64d 代替 %lld 引入头文件 #include \u0026lt;inttypes.h\u0026gt;，并使用 %\u0026quot; PRId64 \u0026quot; 代替 %lld    4. 指数  形如 123e3 或 123E3，e/E 之前必须有数，之后必为整数 若 e/E 之前为小数，则小数点左边应该有且只有一位非零数字，如  5689.65 \u0026gt; 5.68965e+003    5. 浮点数 单精度  一般，一个单精度浮点数型变量只能保证 7 位有效数字  1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { float n1 = 111111.1; float n2 = 111111.1; float n3 = n1 + n2; printf(\u0026#34;%f\\n\u0026#34;, n3); // 222222.203125  return 0; }   双精度  一般，一个双精度浮点数型变量只能保证 16 位有效数字  1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { double n1 = 1111111111111.1113; double n2 = 1111111111111.1113; double n3 = n1 + n2; printf(\u0026#34;%f\\n\u0026#34;, n3); // 2222222222222.222700  return 0; }   ps  应当避免一个很大的数和一个很小的数直接相加或相减  1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { float num = 1234567.0e5f + 20.0f; printf(\u0026#34;%f\\n\u0026#34;, num); // 123456700416.000000  return 0; }   ","description":"","id":45,"section":"c","tags":null,"title":"03. 数值的表示","uri":"https://yorkfish.github.io/review/c/basics/03_representation_of_value/"},{"content":"Step1   删除 D:hugoblog\\content\u0026gt; 下的文件夹 ko, en\n  新建 _index.md，并写入如下语句\n---\rtitle: ZDoc\rdescription: Hugo ZDoc theme landing page\rdate: 2020-08-28T00:00:00+08:00\rdraft: false\rlanding:\rheight: 500\rimage: favicon/android-icon-192x192.png\rtitle:\r- YorkFish's Blog\rtext:\r- Knowledge review\rtitleColor:\rtextColor:\rspaceBetweenTitleText: 25\rbuttons:\r- link: hugo/hugo_01\rtext: GET STARTED\rcolor: primary\r---\r  Step2 single page   在 content 文件夹内新建文件夹 test\n  在 test 内新建文档 SinglePage.md，并写入如下内容\n---\rtitle: \u0026quot;Content Formats\u0026quot;\rdescription: \u0026quot;test post\u0026quot;\rdate: 2020-08-23T00:30:00+08:00\rdraft: false\rweight: 1\r---\r*Markdown here*\r  collapsible page   在 test 内新建文件夹 CollapsiblePage\n  在 CollapsiblePage 内新建文档 _index.md，并写入如下内容\n---\rtitle: \u0026quot;Collapsible Page\u0026quot;\rdescription: \u0026quot;test post index\u0026quot;\rdate: 2020-08-23T00:30:00+08:00\rdraft: false\rweight: 2\rcollapsible: true\r---\r  在 CollapsiblePage 内新建几个文档，如\n GettingStarted.md Installation.md BasicUsage.md    在各文档内写入类似如下的语句\n---\rtitle: \u0026quot;Frontmatter\u0026quot;\rdescription: \u0026quot;test post\u0026quot;\rdate: 2020-08-23T00:30:00+08:00\rdraft: false\r---\r*Markdown here*\r  在 D:\\hugoblog\\config\\_default\\menus.zh.toml 中添加如下语句\n[[main]]\ridentifier = \u0026quot;test\u0026quot;\rname = \u0026quot;Test\u0026quot;\rurl = \u0026quot;test\u0026quot;\rweight = 2\r  补充  也可以使用命令添加文档，如 D:\\hugoblog\u0026gt;hugo new about/index.zh.md  这条命令会在 D:\\hugoblog\\content 下新建文件夹 about 并在 about 内新建文档 index.zh.md    ","description":"add docs","id":46,"section":"hugo","tags":null,"title":"Make doc","uri":"https://yorkfish.github.io/review/hugo/hugo_03/"},{"content":"1. 说明  除了用 PyCharm 创建虚拟环境，还可以用命令 venv 是自带的 virtualenv 需要自行安装  2. venv  使用命令：D:\\test\u0026gt;python -m venv env 启用命令：D:\\test\u0026gt;env\\Scripts\\activate 关闭命令：D:\\test\u0026gt;env\\Scripts\\deactivate.bat  ps  -m: run library module as a script 加了 -m 就不用管模块的位置了，可以直接用  3. virtualenv   官方博客：\u0026gt;\u0026gt;\u0026gt; 传送门\n  安装命令：C:\\Users\\York\u0026gt;pip install virtualenv\n  使用命令：D:\\test\u0026gt;virtualenv venv\n  启用命令：D:\\test\u0026gt;env\\Scripts\\activate\n  关闭命令：D:\\test\u0026gt;env\\Scripts\\deactivate.bat\n  ps   选择一个特定的 Python 版本创建虚拟环境：D:\\test\u0026gt;virtualenv -p path/to/python venv\n  默认情况下，虚拟环境会依赖系统环境中的 sit package\n  即，系统中已经安装好的第三方 package 也会被安装在虚拟环境中\n  如果不想依赖这些 package，可以加上 --no-site-packages 参数\n  ","description":"","id":47,"section":"python","tags":null,"title":"03. virtual environment","uri":"https://yorkfish.github.io/review/python/operation/03_virtual_env/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. 添加一个 Text 1 2  t = tk.Text(window, height=2) t.pack()   3. insert 文字  insert 到光标后：t.insert(\u0026quot;insert\u0026quot;, string) insert 到文本末：t.insert(\u0026quot;end\u0026quot;, string) insert 到指定处：t.insert(2.1, string)  ps  x.y 的形式有一个注意点  x 表示行，索引从 1 开始 y 表示列，索引从 0 开始    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) t = tk.Text(window, height=2, font=(\u0026#34;Consolas\u0026#34;, 20)) t.insert(\u0026#34;insert\u0026#34;, \u0026#34;012\\n012\u0026#34;) t.pack() def insert_point(): t.insert(\u0026#34;insert\u0026#34;, \u0026#34;York\u0026#34;) def insert_end(): t.insert(\u0026#34;end\u0026#34;, \u0026#34;Fish\u0026#34;) def insert_anypoint(): t.insert(2.1, \u0026#39;-\u0026#39;) b1 = tk.Button(window, text=\u0026#34;insert point\u0026#34;, width=15, command=insert_point) b1.pack() b2 = tk.Button(window, text=\u0026#34;insert end\u0026#34;, width=15, command=insert_end) b2.pack() b3 = tk.Button(window, text=\u0026#34;insert anypoint\u0026#34;, width=15, command=insert_anypoint) b3.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n ps  启动后，光标默认在文末，即第二行末尾 点到其他位置以体验 insert point    ","description":"文本框","id":48,"section":"python","tags":null,"title":"04. Text","uri":"https://yorkfish.github.io/review/python/tkinter/04_text/"},{"content":"1. 简介  callable() 用于检查一个对象是否可调用 对于函数、方法、lambda 函数式、类，以及实现了 __call__ 方法的类实例, 它都返回 True 对于整数、字符串、列表、元组、字典等，都返回 False  ps  若返回 True，object 仍可能调用失败 若返回 False，object 必然调用失败  2. 举例 例一 函数 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; def say(): ... print(\u0026#34;Hi, I am YorkFish!\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; callable(say) True \u0026gt;\u0026gt;\u0026gt;   例二 空类与其实例 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; class Test(object): ... pass ... \u0026gt;\u0026gt;\u0026gt; callable(Test) True \u0026gt;\u0026gt;\u0026gt; t = Test() # 没有实现 __call__, 返回 False \u0026gt;\u0026gt;\u0026gt; callable(t) False \u0026gt;\u0026gt;\u0026gt;   例三 实现 __call__ 后 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; class Test(object): ... def __init__(self): ... pass ... def __call__(self, *args, **kwargs): ... print(\u0026#34;Hello, I am YorkFish.\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; callable(Test) True \u0026gt;\u0026gt;\u0026gt; t = Test() # 实现了 __call__, 返回 True \u0026gt;\u0026gt;\u0026gt; callable(t) True \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":49,"section":"python","tags":null,"title":"04. callable","uri":"https://yorkfish.github.io/review/python/class/04_callable/"},{"content":"例一  不同类型的数值，只要大小相等，Python 就认为它们相等  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 1.0 \u0026gt;\u0026gt;\u0026gt; a == b True \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = [1, 2] \u0026gt;\u0026gt;\u0026gt; b = [1.0, 2.0] \u0026gt;\u0026gt;\u0026gt; a == b True \u0026gt;\u0026gt;\u0026gt;   例二  dict 通过检查键值和哈希来确定两个键是否相同 若有相等的键  键取最前面的 值取最后面的    1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; d1 = {1:\u0026#39;a\u0026#39;, 1.0:\u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d1 {1: \u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d2 = {1.0:\u0026#39;a\u0026#39;, 1:\u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d2 {1.0: \u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt;   例三 常量赋值产生副本，其他产生别名\r 副本  字符串、整型、浮点、布尔“产生”副本  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = b = 3 \u0026gt;\u0026gt;\u0026gt; c = 3 \u0026gt;\u0026gt;\u0026gt; a is b is c True \u0026gt;\u0026gt;\u0026gt; a = 4 \u0026gt;\u0026gt;\u0026gt; b 3 \u0026gt;\u0026gt;\u0026gt; c 3 \u0026gt;\u0026gt;\u0026gt;   别名  list, dict 以及自定义的 class “产生”别名  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = b = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; c = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; a is b True \u0026gt;\u0026gt;\u0026gt; a is c False \u0026gt;\u0026gt;\u0026gt; a[0] = 11 \u0026gt;\u0026gt;\u0026gt; b [11, 2, 3] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":50,"section":"python","tags":null,"title":"04. equal","uri":"https://yorkfish.github.io/review/python/basics/04_equal/"},{"content":"1. 简介  eval for evaluate 原型：eval(expression, globals=None, locals=None)  2. 举例 例一 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; s = \u0026#34;[[1, 2], [3, 4], [5, 6]]\u0026#34; \u0026gt;\u0026gt;\u0026gt; s \u0026#39;[[1, 2], [3, 4], [5, 6]]\u0026#39; \u0026gt;\u0026gt;\u0026gt; eval(s) [[1, 2], [3, 4], [5, 6]] \u0026gt;\u0026gt;\u0026gt;   例二 先局部\n再全局\n最后内置\r 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; a = 10 \u0026gt;\u0026gt;\u0026gt; eval(\u0026#34;a+1\u0026#34;, {\u0026#39;a\u0026#39;: 20}) 21 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b = 10 \u0026gt;\u0026gt;\u0026gt; eval(\u0026#34;b+1\u0026#34;, {\u0026#39;b\u0026#39;: 20}, {\u0026#39;b\u0026#39;: 30}) 31 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":51,"section":"python","tags":null,"title":"04. eval()","uri":"https://yorkfish.github.io/review/python/bif/04_eval/"},{"content":"1. 说明  当对 ndarray 使用各种算术运算符时  numpy 会将其应用于数组的每一个元素 计算完成后返回一个与原来形状相同的 ndarray    2. 操作 导入 1  import numpy as np   四则运算 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; a = np.arange(10) \u0026gt;\u0026gt;\u0026gt; print(a) [0 1 2 3 4 5 6 7 8 9] \u0026gt;\u0026gt;\u0026gt; print(a + 10) [10 11 12 13 14 15 16 17 18 19] \u0026gt;\u0026gt;\u0026gt; print(a * 2) [ 0 2 4 6 8 10 12 14 16 18] \u0026gt;\u0026gt;\u0026gt;   幂运算 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12).reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(a ** 2) [[ 0 1 4 9] [ 16 25 36 49] [ 64 81 100 121]] \u0026gt;\u0026gt;\u0026gt;   三角函数 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12).reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; print(np.sin(a)) # 这里的 sin 接收的是弧度 [[ 0. 0.84147098 0.90929743 0.14112001] [-0.7568025 -0.95892427 -0.2794155 0.6569866 ] [ 0.98935825 0.41211849 -0.54402111 -0.99999021]] \u0026gt;\u0026gt;\u0026gt;   逻辑运算 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12).reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; print(a \u0026lt; 6) [[ True True True True] [ True True False False] [False False False False]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":52,"section":"python","tags":null,"title":"04. ndarray calculate","uri":"https://yorkfish.github.io/review/python/numpy/04_ndarray_calculate/"},{"content":"1. 设置   “以管理员身份运行”打开 PowerShell\n  输入 set-executionpolicy remotesigned\n执行策略可以防止您执行不信任的脚本。\r更改执行策略可能会使您面临 about_Execution_Policies 帮助主题中所述的安全风险。\r是否要更改执行策略? [Y] 是(Y) [N] 否(N) [S] 挂起(S) [?] 帮助 (默认值为“Y”):\r  输入 Y 确认\n  重启生效\n  2. 使用   现在，Anaconda 默认有 PowerShell Prompt 和 CMD Prompt\n  硬要手动激活、关闭，可以这样\n 打开 PowerShell 或 CMD 输入 conda activate base 激活（base 可以改成自己的虚拟环境） 输入 conda deactivate base 关闭    若想每次打开 PowerShell 或 CMD 都是激活状态，输入下方两条命令\n conda init powershell conda config --set auto_activate_base true    若想恢复，使用命令：conda config --set auto_activate_base false\n  ","description":"","id":53,"section":"python","tags":null,"title":"04. powershell virtual-env","uri":"https://yorkfish.github.io/review/python/operation/04_powershell/"},{"content":"1. 说明  因为 Python 的变量是动态的，所以不能真正像 C, Java 那样对函数的参数类型进行严格定义 Python 3.6 以后有了类型提示 列表、字典等，需要导入 typing 模块  2. 举例 例一 1 2 3 4 5 6 7  def test(name: str, age: int) -\u0026gt; bool: res = True print(f\u0026#34;{name=}\u0026#34;) print(f\u0026#34;{age=}\u0026#34;) if age \u0026lt; 18: res = False return res   例二 1 2 3 4 5  from typing import Dict, List a: List[int] = [] b: Dict[str, int] = {}   ","description":"","id":54,"section":"python","tags":null,"title":"04. typing","uri":"https://yorkfish.github.io/review/python/module/04_typing/"},{"content":"1. 简介  fread 和 fwrite 函数可以用来读写一个字符 因为常常需要一次读取一组数据，ANSI C 标准提出设置这两个函数，用来读写一个数据块  2. 一般形式 1 2  fread(buffer, size, count, fp); fwrite(buffer, size, count, fp);   3. 说明   buffer: 一个指针\n 对 fread 来说，它是读入数据的存放（起始）地址 对 fwrite 来说，它是要输出数据的（起始）地址    size: 要读写的字节数\n  count: 要读写多少次 size 字节的数据像\n  fp: 文件型指针\n  如果文件以二进制形式打开，用 fread 和 fwrite 函数就可以读写任何类型的信息\n  4. 举例 例一 写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); float nums[5] = {11.0, 12.0, 13.0, 14.0, 15.0}; int fsize = sizeof(float); for (int i = 0; i \u0026lt; 5; i++) { if (fwrite(\u0026amp;nums[i], fsize, 1, fp) != 1) { printf(\u0026#34;file write error!\\n\u0026#34;); exit(0); } } fclose(fp); return 0; }   例二 读出 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); float nums[5]; int fsize = sizeof(float); for (int i = 0; i \u0026lt; 5; i++) { fread(\u0026amp;nums[i], fsize, 1, fp); printf(\u0026#34;%f\\n\u0026#34;, nums[i]); } fclose(fp); return 0; }   ps  上面的例子不用二进制 (wb, rb) 也能成功，但  一来，不推荐 二来，程序还是会以二进制运行    ","description":"","id":55,"section":"c","tags":null,"title":"04. fread() \u0026 fwrite()","uri":"https://yorkfish.github.io/review/c/file/04_fread_and_fwrite/"},{"content":"1. 多个实参的求值顺序  有的编译器自右向左 有的编译器自左向右 应当避免这种容易混淆的用法  2. 编译器的检查  只检查参数个数和参数类型，而不检查参数名 对形参数组大小不做检查，只是将实参数组的首元素的地址传给形参数组 不检查（数组）第一维的大小  ","description":"","id":56,"section":"c","tags":null,"title":"04. 函数的调用","uri":"https://yorkfish.github.io/review/c/function/04_function_call/"},{"content":"1. 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14  int arr1[3][4] = { {10, 11, 12, 13}, {14, 15, 16, 17}, {18, 19, 20, 21}}; int arr2[][4] = { {10, 11, 12, 13}, {14, 15, 16, 17}, {18, 19, 20, 21}}; int arr3[][4] = { {10}, {14, 15}, {18, 19, 20}};    Tip: 指针尽量用 p[i] 的形式，这样就省了下文的唠叨  2. 不同写法    表示形式 含义     arr 二维数组名，首行首地址   *arr, *(arr+0), arr[0], \u0026amp;*(arr[0] + 0), \u0026amp;arr[0][0] 首行首列地址   arr+1, \u0026amp;*(arr+1), \u0026amp;arr[1] 1 行首地址   *(arr+1), arr[1], \u0026amp;*(arr[1] + 0), \u0026amp;arr[1][0] 1 行首列地址   *(arr+1)+2, arr[1]+2, \u0026amp;*(arr[1]+2), \u0026amp;arr[1][2] 1 行 2 列元素 arr[1][2] 的地址   *(*(arr+1)+2), *(arr[1]+2), arr[1][2] 1 行 2 列元素 arr[1][2] 的值     Tip  *(arr+i) 等价于 arr[i] \u0026amp; 与 * 可以消掉    *(arr+1) 与 arr+1  *(arr+1) 就是 arr[1]，在二维数组中，它是一维数组名，是地址，指向 arr[1][0] arr+1 是二维数组 arr 中的 1 行首地址，也指向 arr[1][0]  指向行与指向列  二维数组名（如 arr）是指向行的 在指向行的指针之前加一个 *（如 *arr, *(arr+1)），就成了指向列的指针 在指向列的指针值前加一个 \u0026amp;（如 \u0026amp;*arr, \u0026amp;*(arr+1)），就成了指向行的指针  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int main() { int arr[][4] = { {10, 11, 12, 13}, {14, 15, 16, 17}, {18, 19, 20, 21}}; printf(\u0026#34;%p\\n\u0026#34;, arr); // 0061FEA0，每次编译分配的地址不一定相同  printf(\u0026#34;%p\\n\u0026#34;, *arr); // 0061FEA0  printf(\u0026#34;%p\\n\u0026#34;, arr[0]); // 0061FEA0, *arr \u0026gt; *(arr+0) \u0026gt; arr[0]  printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr[0]); // 0061FEA0, arr \u0026gt; \u0026amp;*(arr+0) \u0026gt; \u0026amp;arr[0]  printf(\u0026#34;%p\\n\u0026#34;, *(arr+0)+0); // 0061FEA0, arr[0]+0  printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr[0][0]); // 0061FEA0, \u0026amp;*(arr[0]+0) \u0026gt; \u0026amp;arr[0][0]  return 0; }    值一样，但概念不尽相同 不要把 \u0026amp;arr[i] 简单地理解为 arr[i] 单元的物理地址 对二维数组而言，并不存在 arr[i] 这样一个实际的变量 它只是一种地址的计算方法，能得到第 i 行的首地址  4. 说明  当 arr[i][j] 的 j 为 0 时，\u0026amp;arr[i] 和 arr[i] 值相等，即它们占同一地址 它们所指向的对象是不同的，即指针的基本类型是不同的 二维数组中，arr+i, arr[i], *(arr+i), \u0026amp;arr[i], \u0026amp;arr[i][0] 的值相等 *(*(arr+1)) 可以改写成 **(arr+1)  公式  arr[i][j] 在数组中相对位置的计算公式：i*m + j，m 为二维数组 arrnxm 的列数  arr[2][3] 可以用 *(arr + 2*m+3) 求得 arr[i][j] 的地址为 \u0026amp;arr[0][0] + sizeof(int)*(i*m+j)   由此可见，二维数组在计算机中是“一维连续”存储的  ","description":"","id":57,"section":"c","tags":null,"title":"04. 多维数组与指针","uri":"https://yorkfish.github.io/review/c/pointer/04_arrays_and_pointers-2/"},{"content":"1. 换行与回车  \\n 换行 \\r 回车  ps  以前的打字机，打满一行字后，先把纸往上卷（换行），再把纸往右拉（回车）  2. 八进制    八进制 十进制 ASCII     \\101 65 'A'    3. 字符与字符串  'a' 是字符常量，\u0026quot;a\u0026quot; 是字符串常量  字符   如果在字符变量中存放一个 128~255 间的值\n  由于在字节中最高位为 1，所以用 %d 格式符输出时，会得到负值\n1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { char c = 128; printf(\u0026#34;%d\\n\u0026#34;, c); // -128  return 0; }     字符串   C 规定以字符 '\\0' 作为字符串结束标志\n  ASCII 码为 0 的字符是 '\\0'，表示“空操作字符”\n  写字符串不必多加 '\\0'\n  字符串 \u0026quot;a\u0026quot; 实际上包含 2 个字符：'a' 和 '\\0'\n1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;a\u0026#34;; printf(\u0026#34;%d\\n\u0026#34;, strlen(str)); // 1  printf(\u0026#34;%d\\n\u0026#34;, sizeof(str)); // 2  return 0; }     ","description":"","id":58,"section":"c","tags":null,"title":"04. 字符型数据","uri":"https://yorkfish.github.io/review/c/basics/04_character_data/"},{"content":"1. 优点  采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间  2. 三种形式 形式一 1 2 3  #ifdef 标识符  // 程序段1 #endif   形式二 1 2 3 4 5  #ifdef 标识符  // 程序段1 #else  // 程序段2 #endif   形式三 1 2 3 4 5  #if 表达式  // 程序段1 #else  // 程序段2 #endif   ","description":"","id":59,"section":"c","tags":null,"title":"04. 条件编译","uri":"https://yorkfish.github.io/review/c/preprocessor/04_conditional_compilation/"},{"content":"1. 引用的方式 一般形式  结构体变量名.成员名 如：student1.num = 10010; . 是成员（分量）运算符，它在所有的运算符中优先级最高的  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef struct data { int num; } Data; typedef struct student { char name[20]; char gender; Data st_num; } Student; int main() { Student st1; strcpy(st1.name, \u0026#34;york\u0026#34;); st1.gender = \u0026#39;M\u0026#39;; st1.st_num.num = 1; printf(\u0026#34;%s\\n\u0026#34;, st1.name); printf(\u0026#34;%c\\n\u0026#34;, st1.gender); printf(\u0026#34;%d\\n\u0026#34;, st1.st_num.num); return 0; }   2. 指针的方式 一般形式  (*结构体变指针).成员名 或 结构体指针-\u0026gt;成员名 如：(*pStu).num = 10010; 或 pStu-\u0026gt;num = 10010; -\u0026gt; 是指向运算符  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef struct student { char name[20]; char gender; int num; } Student; void printInfo(Student* stu) { printf(\u0026#34;%s\\n\u0026#34;, (*stu).name); printf(\u0026#34;%c\\n\u0026#34;, stu-\u0026gt;gender); printf(\u0026#34;%d\\n\u0026#34;, stu-\u0026gt;num); } int main() { Student st1; strcpy(st1.name, \u0026#34;york\u0026#34;); st1.gender = \u0026#39;M\u0026#39;; scanf(\u0026#34;%d\u0026#34;, \u0026amp;st1.num); printInfo(\u0026amp;st1); return 0; }   ","description":"","id":60,"section":"c","tags":null,"title":"04. 结构体变量的使用","uri":"https://yorkfish.github.io/review/c/struct-union-enum/04_usage/"},{"content":"1. bulid  D:\\hugoblog\u0026gt;hugo --buildDrafts 上方命令会在博客根目录生成一个名为 public 的文件夹，里面是 hugo 生成的网页文件  ps  Hugo 与 MkDocs 不同  生成静态网页后，需要开启服务才有效果 在本地双击 index.html 能打开，但没有特效 上传到远程仓库，做好相应设置，就能正常显示了   zdoc 主题支持两种模式，我暂且称其为 docs 与 blogs  docs 模式更利于作知识的整理归纳 blogs 模式更适合写文章    2. 进入 public 文件夹  york$ git init york$ git add . york$ git commit -m \u0026quot;hugo-zdoc blog first commit\u0026quot; york$ git remote add origin git@github.com:YorkFish/review.git york$ git push -u origin master  3. 登录 github  https://github.com/YorkFish/review/settings GitHub Pages Branch -\u0026gt; /root -\u0026gt; Save  ","description":"github pages","id":61,"section":"hugo","tags":null,"title":"Deploy to the cloud","uri":"https://yorkfish.github.io/review/hugo/hugo_04/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. 添加三个 entry 1 2 3 4 5 6  e1 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 20), show=None) # 显示 e2 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 20), show=\u0026#39;*\u0026#39;) # 隐藏 e3 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 20), show=\u0026#39;1\u0026#39;) # 恶搞 e1.pack() e2.pack() e3.pack()   3. 获取 entry 的内容 1  string = e1.get()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) e1 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 16), show=None) e2 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 16), show=\u0026#39;*\u0026#39;) e3 = tk.Entry(window, font=(\u0026#34;Consolas\u0026#34;, 16), show=\u0026#39;1\u0026#39;) e1.pack() e2.pack() e3.pack() t = tk.Text(window, font=(\u0026#34;Arial\u0026#34;, 20), height=2) t.pack() def insert_point(): string = e1.get() t.insert(\u0026#34;insert\u0026#34;, string) b = tk.Button(window, text=\u0026#34;insert point\u0026#34;, width=14, height=2, command=insert_point) b.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n ps: 三个 entry 输入的都是 123  ","description":"文本输入框","id":62,"section":"python","tags":null,"title":"05. Entry","uri":"https://yorkfish.github.io/review/python/tkinter/05_entry/"},{"content":"1. 说明  函数名：filter 顾名思意：筛选程序、过滤器  2. 举例 例一 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = list(range(10)) \u0026gt;\u0026gt;\u0026gt; [e for e in a if e % 2 == 0] [0, 2, 4, 6, 8] \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = list(range(10)) \u0026gt;\u0026gt;\u0026gt; b = filter(lambda x: x % 2 == 0, a) \u0026gt;\u0026gt;\u0026gt; list(b) [0, 2, 4, 6, 8] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":63,"section":"python","tags":null,"title":"05. filter()","uri":"https://yorkfish.github.io/review/python/bif/05_filter/"},{"content":"1. 说明  与 for 对应的 else 只有完整地走完 for 后才生效  2. 举例 1 2 3 4 5 6 7 8 9 10 11 12  def find_num(lst, num): for i in lst: if i == num: print(\u0026#34;found\u0026#34;, num) break else: print(\u0026#34;not found\u0026#34;, num) lst = [1, 2, 3, 4, 5] find_num(lst, 3) find_num(lst, 6)   \u0026gt;\u0026gt;\u0026gt;\nfound 3\rnot found 6\r","description":"","id":64,"section":"python","tags":null,"title":"05. for-else","uri":"https://yorkfish.github.io/review/python/basics/05_for_else/"},{"content":" 通过 python -h 可以查看帮助信息  例一 python file   在 D:\\test 下新建文件 hellp.py\n  写入 print(\u0026quot;hello world\u0026quot;)\n  在命令行运行\nD:\\test\u0026gt;python hellp.py\rhello world\rD:\\test\u0026gt;\r  例二 python -m D:\\test\u0026gt;python -m hellp\rhello world\rD:\\test\u0026gt;\r例三 python -c C:\\Users\\York\u0026gt;python -c \u0026quot;print('hello world')\u0026quot;\rhello world\rC:\\Users\\York\u0026gt;\r例四 通过“标准输出”传递 C:\\Users\\York\u0026gt;echo print(\u0026quot;hello world\u0026quot;) | python\rhello world\rC:\\Users\\York\u0026gt;\r","description":"","id":65,"section":"python","tags":null,"title":"05. hello world","uri":"https://yorkfish.github.io/review/python/operation/05_hello_world/"},{"content":"1. 说明  numpy 有矩阵类 但还是尽量使用 ndarray 为好 不要混用！  2. 操作 导入 1  import numpy as np   创建 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12).reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; b = np.arange(12).reshape((4, 3)) \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] \u0026gt;\u0026gt;\u0026gt;   错误的用法 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; print(a * b) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: operands could not be broadcast together with shapes (3,4) (4,3) \u0026gt;\u0026gt;\u0026gt;   正确的用法 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; print(a.dot(b)) [[ 42 48 54] [114 136 158] [186 224 262]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(a @ b) [[ 42 48 54] [114 136 158] [186 224 262]] \u0026gt;\u0026gt;\u0026gt;   matrix  仅限 2d  1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; c = np.matrix(a) \u0026gt;\u0026gt;\u0026gt; d = np.matrix(b) \u0026gt;\u0026gt;\u0026gt; type(c) \u0026lt;class \u0026#39;numpy.matrix\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(c * d) [[ 42 48 54] [114 136 158] [186 224 262]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":66,"section":"python","tags":null,"title":"05. matrix multiplication","uri":"https://yorkfish.github.io/review/python/numpy/05_ndarray_matrix/"},{"content":"1. 说明  之前做 Python Challenge，对用到的“库”做过总结 另一个博客：\u0026gt;\u0026gt;\u0026gt;传送门  2. 预览  base64 binascii bz2 collections datetime diffflib email gzip hashlib os pickle Pillow re requests struct this urlib wave xmlrpc zipfile zlib  ","description":"","id":67,"section":"python","tags":null,"title":"05. others","uri":"https://yorkfish.github.io/review/python/module/05_others/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; class Hero(object): ... game_name = \u0026#34;LOL\u0026#34; # 类变量 ... \u0026gt;\u0026gt;\u0026gt; lijing = Hero() \u0026gt;\u0026gt;\u0026gt; lijing.game_name \u0026#39;LOL\u0026#39; \u0026gt;\u0026gt;\u0026gt; lijing.game_name = \u0026#34;DNF\u0026#34; \u0026gt;\u0026gt;\u0026gt; lijing.game_name \u0026#39;DNF\u0026#39; \u0026gt;\u0026gt;\u0026gt; del lijing.game_name \u0026gt;\u0026gt;\u0026gt; lijing.game_name \u0026#39;LOL\u0026#39; \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":68,"section":"python","tags":null,"title":"05. 类变量","uri":"https://yorkfish.github.io/review/python/class/05_class_var/"},{"content":"1. 简介  与 scanf() 和 printf() 作用相仿 都是格式化读写函数  2. 一般调用方式 fscanf(文件指针, 格式字符串, 输出表列);\rfprintf(文件指针, 格式字符串, 输出表列);\r3. 举例 例一 写 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); fprintf(fp, \u0026#34;%d, %.2f\u0026#34;, 100, 100.5); fclose(fp); return 0; }   例二 读 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); int i; float f; fscanf(fp, \u0026#34;%d, %f\u0026#34;, \u0026amp;i, \u0026amp;f); printf(\u0026#34;%d, %f\\n\u0026#34;, i, f); fclose(fp); return 0; }   4. 说明  在输入时要将 ASCII 码转换为二进制形式 在输出时又要将二进制形式转换成字符 花费时间较多 在内存与磁盘频繁交换数据的情况下，最好使用 fread 和 fwrite  ","description":"","id":69,"section":"c","tags":null,"title":"05. fscanf() \u0026 fprintf()","uri":"https://yorkfish.github.io/review/c/file/05_fscanf_and_fprintf/"},{"content":"例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #include \u0026lt;stdio.h\u0026gt; void traverseArray(int (*arr)[5], int arrSize, int arrColSize){ for (int i = 0; i \u0026lt; arrSize; i++) { for (int j = 0; j \u0026lt; arrColSize; j++) { printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main() { int nums[][5] = { {11, 12, 13, 14, 15}, {16, 17, 18, 19, 20}, {21, 22, 23, 24, 25} }; int arrSize = 3; int arrColSize = 5; traverseArray(nums, arrSize, arrColSize); return 0; }   ps1   int (*arr)[5] 表示 arr 是一个指针变量，它指向包含 5 个整型元素的一维数组\n  *p;: 数的指针可以接一维数组 =\u0026gt; (*p)[5]: 一维数组的指针可以接二维数组\n  缺点：列数是固定的\n  注意：括号必不可少，不能写成 *arr[5]，因为 *arr[5] 相当于 *(arr[5])，是指针数组\n  ps2  *(p+2) 是 p[2]，是数组 2 行的起始地址，也是 p[2][0] 的地址 p+2 是数组 2 行的起始地址 *(p+2) 与 p+2 的值相同，但 *(p+2)+3 不能写成 (p+2)+3，因为 (p+2)+3 等价于 p+5  例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;stdio.h\u0026gt; void traverseArray(int** arr, int arrSize, int* arrColSize){ for (int i = 0; i \u0026lt; arrSize; i++) { for (int j = 0; j \u0026lt; arrColSize[i]; j++) { printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main() { int nums[][5] = { {11, 12, 13, 14, 15}, {16, 17, 18, 19, 20}, {21, 22, 23, 24, 25} }; int* arr[] = {nums[0], nums[1], nums[2]}; int arrSize = 3; int arrColSize[] = {5, 5, 5}; traverseArray(arr, arrSize, arrColSize); return 0; }   ","description":"","id":70,"section":"c","tags":null,"title":"05. 二维数组传参","uri":"https://yorkfish.github.io/review/c/pointer/05_array_param_transfer/"},{"content":"1. 常见的情况  ! \u0026gt; 算术 \u0026gt; 关系 \u0026gt; 逻辑 \u0026gt; 赋值 \u0026gt; 逗号  算术：*, /, %, +, - 关系：\u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=, !=, == 逻辑：\u0026amp;\u0026amp;, || 赋值：= 及其扩展（如 +=） 逗号：,    2. 保险的做法  加括号  ","description":"","id":71,"section":"c","tags":null,"title":"05. 优先级","uri":"https://yorkfish.github.io/review/c/basics/05_priority/"},{"content":"1. 全局变量  全局变量“管”的是它定义之下的语句 不在必要时，不要使用全局变量 全局变量使用过多，会降低程序的清晰性  2. 局部变量  在同一个源文件中，若外部变量与局部变量同名，在局部变量的作用范围内，外部变量被“屏蔽”  3. 划分要求  在程序设计中在划分模块时要求  模块的“内聚性”强 与其他模块的“耦合性”弱   即，模块功能单一，与其他模块之间的影响小  ","description":"","id":72,"section":"c","tags":null,"title":"05. 全局变量与局部变量","uri":"https://yorkfish.github.io/review/c/function/05_global_var_and_local_var/"},{"content":"1. 定义 例一 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char name[20]; char gender; int num; } Student; int main() { Student stu[3]; return 0; }   例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; } stu1[3]; struct { char name[20]; char gender; int num; } stu2[3]; int main() { return 0; }   2. 初始化 例三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char name[20]; char gender; int num; } Student; int main() { Student stu[] = { {\u0026#34;york\u0026#34;, \u0026#39;M\u0026#39;, 1}, {\u0026#34;fish\u0026#34;, \u0026#39;M\u0026#39;, 2}, {\u0026#34;jessy\u0026#34;, \u0026#39;F\u0026#39;, 3} }; return 0; }   例四 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt; struct student { char name[20]; char gender; int num; } stu[3] = { {\u0026#34;york\u0026#34;, \u0026#39;M\u0026#39;, 1}, {\u0026#34;fish\u0026#34;, \u0026#39;M\u0026#39;, 2}, {\u0026#34;jessy\u0026#34;, \u0026#39;F\u0026#39;, 3} }; int main() { printf(\u0026#34;%s\\n\u0026#34;, stu[2].name); return 0; }   3. 指向结构体数组元素的指针 例五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char gender; char name[20]; int num; } Student; int main() { Student stu[3] = { {\u0026#39;M\u0026#39;, \u0026#34;york\u0026#34;, 1}, {\u0026#39;M\u0026#39;, \u0026#34;fish\u0026#34;, 2}, {\u0026#39;F\u0026#39;, \u0026#34;jessy\u0026#34;, 3} }; Student* pStu = (Student*)stu[0].name; printf(\u0026#34;%s\\n\u0026#34;, pStu+1); // fish  return 0; }    不要这样用  例六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;stdio.h\u0026gt; typedef struct student { char gender; char name[20]; int num; } Student; int main() { Student stu[3] = { {\u0026#39;M\u0026#39;, \u0026#34;york\u0026#34;, 1}, {\u0026#39;M\u0026#39;, \u0026#34;fish\u0026#34;, 2}, {\u0026#39;F\u0026#39;, \u0026#34;jessy\u0026#34;, 3} }; Student* pStu = (Student*)stu[0].num; printf(\u0026#34;%d\\n\u0026#34;, pStu); // 1  printf(\u0026#34;%d\\n\u0026#34;, pStu+1); // 29, 1 + sizeof(Student)  printf(\u0026#34;%d\\n\u0026#34;, pStu+2); // 57, 1 + sizeof(Student)*2  return 0; }    不要这样用  ","description":"","id":73,"section":"c","tags":null,"title":"05. 结构体数组","uri":"https://yorkfish.github.io/review/c/struct-union-enum/05_struct_array/"},{"content":"1. alert {{\u0026lt; alert theme=\u0026quot;warning\u0026quot; \u0026gt;}} # warning, success, info, danger\r**this** is a text\r{{\u0026lt; /alert \u0026gt;}}\rthis is \u0026ldquo;warning\u0026rdquo; this is \u0026ldquo;success\u0026rdquo; this is \u0026ldquo;info\u0026rdquo; this is \u0026ldquo;danger\u0026rdquo; 2. expand {{\u0026lt; expand \u0026quot;Expand me\u0026quot; \u0026gt;}}\rSome Markdown Contents\r{{\u0026lt; /expand \u0026gt;}}\r\r\rExpand me\r\rSome Markdown Contents\r\r 3. notice {{\u0026lt; notice success \u0026quot;This is title\u0026quot; \u0026gt;}} # success, info, warning, error\rsuccess\r{{\u0026lt; /notice \u0026gt;}}\rsuccess\r info\r warning\r error\r ","description":"主题自带的短代码","id":74,"section":"hugo","tags":null,"title":"Shortcodes","uri":"https://yorkfish.github.io/review/hugo/shortcodes/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8 9 10  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x400\u0026#34;) str1 = tk.StringVar() l = tk.Label(window, textvariable=str1, bg=\u0026#34;yellow\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 20), width=10, height=2) l.pack() window.mainloop()   2. 添加一个 listbox 1 2 3 4  string = tk.StringVar() string.set((11, 22, 33, 44)) lb = tk.Listbox(window, listvariable=string) lb.pack()   3. insert 内容 1 2  lb.insert(\u0026#34;end\u0026#34;, 100) # 在末尾 insert lb.insert(0, \u0026#34;first\u0026#34;) # 索引从 0 开始   4. delete 内容 1  lb.delete(2) # 索引从 0 开始   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x400\u0026#34;) str1 = tk.StringVar() l = tk.Label(window, textvariable=str1, bg=\u0026#34;yellow\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 20), width=10, height=2) l.pack() def print_selection(): value = lb.get(lb.curselection()) # 取出当前选择的值 str1.set(value) b = tk.Button(window, text=\u0026#34;insert print selection\u0026#34;, bg=\u0026#34;white\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 12), command=print_selection) b.pack() str2 = tk.StringVar() str2.set((11, 22, 33, 44)) lb = tk.Listbox(window, listvariable=str2, font=(\u0026#34;Consolas\u0026#34;, 16)) for item in [1, 2, 3, 4]: lb.insert(\u0026#34;end\u0026#34;, item) lb.insert(0, \u0026#34;first\u0026#34;) lb.insert(2, \u0026#34;second\u0026#34;) lb.delete(2) lb.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"列表部件","id":75,"section":"python","tags":null,"title":"06. Listbox","uri":"https://yorkfish.github.io/review/python/tkinter/06_listbox/"},{"content":"1. 说明  有人喜欢 '%s %s' % ('one', 'two') 的形式 有人喜欢 '{} {}'.format(1, 2) 的形式 于是 Python 保留了两种形式 3.6 之后，增加了 f-string 3.8 之后，f-string 增加了 f'{expr=}'  2. 简介  要详细了解，还得去看官方文档 format 在格式详见例四  2. 举例 例一 % 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;a_tuple: (%d, %d)\u0026#34; % (1, 2)) a_tuple: (1, 2) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;a_list: %s\u0026#34; % [1, 2]) a_list: [1, 2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;a_dict: %s\u0026#34; % {\u0026#39;a\u0026#39;:1, \u0026#39;b\u0026#39;:2}) a_dict: {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt;   例二 format 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; t = (1, 2) \u0026gt;\u0026gt;\u0026gt; \u0026#34;a_tuple = {}\u0026#34;.format(t) \u0026#39;a_tuple = (1, 2)\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026#34;t[0] = {}, t[1] = {}\u0026#34;.format(*t) \u0026#39;t[0] = 1, t[1] = 2\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;:2} \u0026gt;\u0026gt;\u0026gt; \u0026#34;d[\u0026#39;a\u0026#39;] = {a}, dict_e[\u0026#39;b\u0026#39;] = {b}\u0026#34;.format(**d) \u0026#34;d[\u0026#39;a\u0026#39;] = 1, dict_e[\u0026#39;b\u0026#39;] = 2\u0026#34; \u0026gt;\u0026gt;\u0026gt;   例三 f-string 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; name = \u0026#34;YorkFish\u0026#34; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;name: {name}\u0026#34; \u0026#39;name: YorkFish\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{name=}\u0026#34; \u0026#34;name=\u0026#39;YorkFish\u0026#39;\u0026#34; \u0026gt;\u0026gt;\u0026gt;   例四 更多格式  格式：{[index][: [[fill] align] [sign] [width] [.precision] [type]]}     align 含义     \u0026lt; 左对齐   \u0026gt; 右对齐   = 右对齐\n只对数字类型有效，若有符号或设置了符号，显示在最左侧   ^ 居中\n需和 width 参数一起使用       sign 含义     + 正数前加正号   空格 正数前加空格   # 二进制数、八进制数和十六进制数，会以相应的形式显示\n需和 type 参数一起使用       type 含义     s 字符串   d 十进制整数   c 十进制整数对应的 Unicode 字符   b 二进制   o 八进制   x/X 十六进制   f/F 浮点数，默认保留小数点后 6 位   e/E 科学计数法   g/G 在 f 和 e 中选择合适的   % 显示百分比，默认显示小数点后 6 位    1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; num = 1234567890 \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:,}\u0026#34; \u0026#39;1,234,567,890\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:=\u0026gt;+20.6e}\u0026#34; \u0026#39;=======+1.234568e+09\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":76,"section":"python","tags":null,"title":"06. format","uri":"https://yorkfish.github.io/review/python/basics/06_format/"},{"content":"1. 先说结论  字符串是不可变对象，每次使用 + 拼接，都会生成新对象 join() 没有中间字符串生成，效率较高   计算结果所需的内存 一次性申请内存空间 把每个字符串复制过去   2. 举例论证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from time import perf_counter count = 100000 s = \u0026#39;\u0026#39; start1 = perf_counter() for i in range(count): s += \u0026#39;a\u0026#39; stop1 = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#39;+=\u0026#39; run time is: %.6fs\u0026#34; % (stop1 - start1)) lst = [\u0026#39;a\u0026#39;] * count start2 = perf_counter() \u0026#39;\u0026#39;.join(lst) stop2 = perf_counter() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#39;join\u0026#39; run time is: %.6fs\u0026#34; % (stop2 - start2))   ","description":"","id":77,"section":"python","tags":null,"title":"06. join()","uri":"https://yorkfish.github.io/review/python/bif/06_join/"},{"content":"1. 说明  REPL: read-evaluates-print loop evaluates 对应的是 exec，不是 eval  2. Banner 横幅  命令行敲完 python 后出现的信息  Python 3.8.3 (default, Jul 2 2020, 17:30:36) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\rType \u0026quot;help\u0026quot;, \u0026quot;copyright\u0026quot;, \u0026quot;credits\u0026quot; or \u0026quot;license\u0026quot; for more information.\r有意思的小例子 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; import code \u0026gt;\u0026gt;\u0026gt; code.interact(banner=\u0026#34;welcome\u0026#34;, exitmsg=\u0026#34;bye~\u0026#34;) welcome \u0026gt;\u0026gt;\u0026gt; # 按 Ctrl-z bye~ \u0026gt;\u0026gt;\u0026gt;   3. ps  ps: Prompt String  1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; import sys \u0026gt;\u0026gt;\u0026gt; sys.ps1 \u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026#39; \u0026gt;\u0026gt;\u0026gt; sys.ps2 \u0026#39;... \u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; sys.ps1 = \u0026#34;==\u0026gt; \u0026#34; # 重启失效；若不想失效，可仿照下文，写入 startup.py ==\u0026gt; sys.ps2 = \u0026#34;--- \u0026#34; ==\u0026gt; if 1 \u0026lt; 2: --- print(\u0026#34;Y\u0026#34;) --- Y ==\u0026gt;   有意思的小实验   新建一个 python 文件 D:\\Code\\Python\\startup.py\n  写入如下语句\n1 2 3 4  from time import strftime, localtime now = strftime(\u0026#34;%Y-%m-%d%H:%M:%S\u0026#34;, localtime()) print(\u0026#34;Hello YorkFish! \u0026#34;, now)     添加环境变量\n 为用户新增环境变量 变量名：PYTHNSTARTUP 变量值：D:\\Code\\Python\\startup.py    重启命令行\n  4. str \u0026amp; repr 例一 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; \u0026#34;yorkfish\u0026#34; \u0026#39;yorkfish\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;yorkfish\u0026#34;) yorkfish \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; class Test: ... def __repr__(self): ... return \u0026#39;repr\u0026#39; ... def __str__(self): ... return \u0026#39;str\u0026#39; ... \u0026gt;\u0026gt;\u0026gt; t = Test() \u0026gt;\u0026gt;\u0026gt; t repr \u0026gt;\u0026gt;\u0026gt; print(t) str \u0026gt;\u0026gt;\u0026gt;   5. 退出   exit() 或 quit()\n  exit() 可以传参\n exit(1) 表示异常退出 exit(0) 表示正常退出     Windows 快捷键：Ctrl + z\n  Linux 快捷键：Ctrl + d\n  ","description":"","id":78,"section":"python","tags":null,"title":"06. REPL","uri":"https://yorkfish.github.io/review/python/operation/06_repl/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; class Hero(object): ... game_name = \u0026#34;LOL\u0026#34; # 类变量 ... def __init__(self, name): ... self.name = name # 实例变量，由每个对象自行赋值，对象之间不影响 ... \u0026gt;\u0026gt;\u0026gt; lijing = Hero(\u0026#34;Lingjing\u0026#34;) \u0026gt;\u0026gt;\u0026gt; lijing.name \u0026#39;Lingjing\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; garen = Hero(\u0026#34;Garen\u0026#34;) \u0026gt;\u0026gt;\u0026gt; garen.name \u0026#39;Garen\u0026#39; \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":79,"section":"python","tags":null,"title":"06. 实例变量","uri":"https://yorkfish.github.io/review/python/class/06_instance_var/"},{"content":"1. 简介  大多数 C 编译系统都提供 getw 和 putw 用来对磁盘文件读写一个字（整数）  2. 举例 例一 使用自带的函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); putw(10, fp); fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); int i = getw(fp); printf(\u0026#34;%d\\n\u0026#34;, i); fclose(fp); return 0; }   例二 使用自定义的函数  putw 和 getw 不是 ANSI C 标准定义的函数，可以自己定义  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;stdio.h\u0026gt; int putw(int i, FILE* fp) { char* s = (char*)\u0026amp;i; putc(s[0], fp); // 指向 i 的第一个字节  putc(s[1], fp); putc(s[2], fp); putc(s[3], fp); return i; } int getw(FILE* fp) { int i; char* s = (char*)\u0026amp;i; // 使 s 指向 i 的起始地址  s[0] = getc(fp); s[1] = getc(fp); s[2] = getc(fp); s[3] = getc(fp); return i; } int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); putw(10, fp); fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); int i = getw(fp); printf(\u0026#34;%d\\n\u0026#34;, i); fclose(fp); return 0; }    int 的字节数与 char 对上就行  例三  定义一个向磁盘文件写一个实数（用二进制的方式）的函数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #include \u0026lt;stdio.h\u0026gt; void putfloat(float num, FILE* fp) { char* s = (char*)\u0026amp;num; int fsize = sizeof(float); for (int i = 0; i \u0026lt; fsize; i++) { putc(s[i], fp); // fputc  } } int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); putfloat(10.0, fp); fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); float f; fread(\u0026amp;f, sizeof(float), 1, fp); printf(\u0026#34;%f\\n\u0026#34;, f); fclose(fp); return 0; }   ","description":"","id":80,"section":"c","tags":null,"title":"06. getw() \u0026 putw()","uri":"https://yorkfish.github.io/review/c/file/06_getw_and_putw/"},{"content":"1. 两种角度  从变量的作用域（空间）角度来分  全局变量 局部变量   从变量值存在的时间（生存期）角度来分  静态存储方式 动态存储方式    2. 结构  用户区\r-----------\r| 程序区 |\r-----------\r| 静态存储区 |\r-----------\r| 动态存储区 |\r-----------\r3. 说明  自动变量：未加 static 声明的局部变量 每一个变量和函数都有两个属性  数据类型 数据的存储类别    ","description":"","id":81,"section":"c","tags":null,"title":"06. 变量的存储类别","uri":"https://yorkfish.github.io/review/c/function/06_storage_category_of_var/"},{"content":"1. 除法  如果除数或被除数中有一个为负值，则舍入的方向是不固定的 如 -5/3  有的系统：-1 （取整后向零靠拢） 有的系统：-2   C 一般是“取整后向零靠拢” Python 一般是另一种  例一 C 程序 1 2 3 4 5 6 7  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;-5 / 3 = %d ...... %d\\n\u0026#34;, -5/3, -5%-3); return 0; }    运行结果：-5 / 3 = -1 ...... -2  例二 Python 程序 1  print(\u0026#34;-5 / 3 = %d...... %d\u0026#34; % (-5//3, -5%3))    运行结果：-5 / 3 = -2 ...... 1  2. 加减乘除  如果参加四则运算的数中有 float 或 double 类型，则结果是 double 型 因为所有的 float 都按 double 进行运算  ","description":"","id":82,"section":"c","tags":null,"title":"06. 四则运算","uri":"https://yorkfish.github.io/review/c/basics/06_arithmetic/"},{"content":"1. 字符数组和字符指针变量  字符数组：只能单个更改 字符指针：只能整体更改  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { char str1[] = \u0026#34;york\u0026#34;; str1[0] = \u0026#39;Y\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, str1); char* str2 = \u0026#34;fish\u0026#34;; str2 = \u0026#34;Fish\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, str2); return 0; }   2. 指向函数的指针 一般定义形式  数据类型 (*指针变量名)(函数参数表列); 如：int (*p)(int, int);  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int max2(int a, int b) { return a\u0026lt;b? b: a; } int main() { int (*p)(int, int); p = max2; int a = 1, b = 2; int c = (*p)(a, b); printf(\u0026#34;%d\\n\u0026#34;, c); return 0; }   ps  () 优先级高于 * 函数名代表该函数的入口地址 函数指针可以用来存放函数的入口地址，它不固定指向某一函数 函数的调用可以通过函数名，也可以通过函数指针 给函数指针变量赋值时，只需给出函数名而不必给出参数 对于指向函数的指针变量，像 p+n, p++, p-- 等运算是无意义的  3. 用函数指针作函数参数 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;stdio.h\u0026gt; int max2(int a, int b) { return a\u0026lt;b? b: a; } int min2(int a, int b) { return a\u0026lt;b? a: b; } int process(int x, int y, int (*fun)(int, int)) { int res = (*fun)(x, y); return res; } int main() { int a = 1, b = 2; printf(\u0026#34;max(a, b) = %d\\n\u0026#34;, process(a, b, max2)); printf(\u0026#34;min(a, b) = %d\\n\u0026#34;, process(a, b, min2)); return 0; }   ps  这种方法是符合结构化程序设计方法原则的，是程序设计中常用的  4. 返回指针值的函数 一般定义形式  类型名* 函数名(参数表列); 如：int* test(int*, int);  ","description":"","id":83,"section":"c","tags":null,"title":"06. 字符串与指针","uri":"https://yorkfish.github.io/review/c/pointer/06_strings_and_pointers/"},{"content":"并不是简单地累加成员变量占用的大小 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include \u0026lt;stdio.h\u0026gt; struct test1 { char gender; }; struct test2 { char gender; int num; }; struct test3 { char gender; double score; }; struct test4 { char gender; int num; double score; }; struct test5 { char gender; char name[20]; }; int main() { printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test1)); // 1  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test2)); // 8  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test3)); // 16  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test4)); // 16  printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct test5)); // 21  return 0; }   ","description":"","id":84,"section":"c","tags":null,"title":"06. 结构体类型的大小","uri":"https://yorkfish.github.io/review/c/struct-union-enum/06_sizeof_struct/"},{"content":"1. 简介   链表可以根据需要开辟内存单元\n  链表有一个“头指针”变量\n 它存放一个地址 该地址指向一个元素    链表中每一个元素称为“结点”\n  每个结点都应包括两个部分\n 用户需要用的实际数据 下一个结点的地址    head 指向第一个元素\n  最后一个元素不再指向其他元素，它称为“表尾”，它的地址部分放一个 NULL\n  NULL 表示“空地址”，链表到此结束\n  一个指针类型的成员可以指向其他类型的结构体数据，也可以指向自己所在的结构体类型数据\n  只定义结构体，不分配存储空间，只有定义了结构体变量才分配内存单元\n  静态链表\n 所有结点都是在程序中定义的 不是临时开辟的 不能用完后释放    2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;stdio.h\u0026gt; typedef struct node { int val; struct node* next; } Node, *pNode; void traverse(pNode head) { if (head == NULL) return; while (head) { printf(\u0026#34;%d \u0026#34;, head-\u0026gt;val); head = head-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } int main() { Node n1, n2, n3; n1.val = 1; n2.val = 2; n3.val = 3; n1.next = \u0026amp;n2; n2.next = \u0026amp;n3; n3.next = NULL; traverse(\u0026amp;n1); return 0; }   ","description":"","id":85,"section":"c","tags":null,"title":"06. 链表","uri":"https://yorkfish.github.io/review/c/struct-union-enum/06_linked_list/"},{"content":"1. 导入 1  import numpy as np   2. 操作 切片 一维 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12) \u0026gt;\u0026gt;\u0026gt; print(a) [ 0 1 2 3 4 5 6 7 8 9 10 11] \u0026gt;\u0026gt;\u0026gt; print(a[1]) 1 \u0026gt;\u0026gt;\u0026gt; print(a[2:8]) [2 3 4 5 6 7] \u0026gt;\u0026gt;\u0026gt; print(a[2:8:2]) [2 4 6] \u0026gt;\u0026gt;\u0026gt; print(a[::-1]) [11 10 9 8 7 6 5 4 3 2 1 0] \u0026gt;\u0026gt;\u0026gt;   二维 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; b = np.arange(12).reshape((4, 3)) \u0026gt;\u0026gt;\u0026gt; print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(b[0]) [0 1 2] \u0026gt;\u0026gt;\u0026gt; print(b[1][2]) 5 \u0026gt;\u0026gt;\u0026gt; print(b[1:3, :0:-1]) [[5 4] [8 7]] \u0026gt;\u0026gt;\u0026gt;   迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; for i in b.flat: ... print(i) ... 0 1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":86,"section":"python","tags":null,"title":"06. index-slice-iterator","uri":"https://yorkfish.github.io/review/python/numpy/06_ndarray_slice/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, width=20, height=2) l.pack() window.mainloop()   2. 添加一个 radiobutton 1 2 3 4 5 6 7 8 9 10  string = tk.StringVar() def print_selection(): l.config(text=\u0026#34;you have selected \u0026#34; + string.get()) r = tk.Radiobutton(window, text=\u0026#34;Option A\u0026#34;, variable=string, value=\u0026#39;A\u0026#39;, font=(\u0026#34;Consolas\u0026#34;, 16), command=print_selection) r.pack()   ps  variable=string, value='A' 若鼠标选中了某个选项  把 value 的值 A 存入变量 string 中 赋值给 variable    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, width=20, height=2) l.pack() string = tk.StringVar() def print_selection(): l.config(text=\u0026#34;you have selected \u0026#34; + string.get()) r1 = tk.Radiobutton(window, text=\u0026#34;Option A\u0026#34;, variable=string, value=\u0026#39;A\u0026#39;, command=print_selection) r2 = tk.Radiobutton(window, text=\u0026#34;Option B\u0026#34;, variable=string, value=\u0026#39;B\u0026#39;, command=print_selection) r3 = tk.Radiobutton(window, text=\u0026#34;Option C\u0026#34;, variable=string, value=\u0026#39;C\u0026#39;, command=print_selection) r1.pack() r2.pack() r3.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"选择按钮-单选","id":87,"section":"python","tags":null,"title":"07. Radiobutton","uri":"https://yorkfish.github.io/review/python/tkinter/07_radiobutton/"},{"content":"1. 问题   命令行敲 python，出现如下错误\n...\rUnicodeDecodeError: 'gbk' codec can't decode byte 0x8f in position 500: illegal multibyte sequence\r...\r  2. 解决 方法一  来到目录：C:\\Users\\{username} 比如我的：C:\\Users\\York 打开 .python_history 删去含中文的记录 缺点：以后命令行用 Python 时写了中文，重启仍有问题  方法二  Anaconda 版本 来到 D:\\anaconda3\\Lib\\site-packages\\pyreadline\\lineeditor 找到 history.py 根据异常的提示行数，找到 for line in open(filename, 'r'): 加上 encoding，如 for line in open(filename, 'r', encoding=\u0026quot;utf-8\u0026quot;):  ","description":"","id":88,"section":"python","tags":null,"title":"07. encode","uri":"https://yorkfish.github.io/review/python/operation/07_gbk/"},{"content":"1. 说明  与另的语言不同，Python 的函数可以很多参数 参数多了，可读性会降低 Python 3.8 之后的两个符号  /: 此符号之前的参数必须是位置参数 *: 此符号之后的参数必须是关键字参数   组合顺序：必选参数、默认参数、可变参数、命名关键字参数和关键字参数  2. 举例 例一 1 2 3 4 5 6 7 8 9 10 11 12 13  def test(a, b=2, *, c): \u0026#34;\u0026#34;\u0026#34; a: 位置参数 b: 默认参数/缺省参数 c: 命名关键字参数/强制关键字参数 \u0026#34;\u0026#34;\u0026#34; print(a, b, c) test(1, c=3) test(a=1, c=3) test(1, 22, c=3) test(a=1, b=22, c=3)   例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def test(a, b, /, c, d, *, e, f): \u0026#34;\u0026#34;\u0026#34; a, b: 强制位置参数 c, d: 都作位置参数或关键字参数，或 c 作位置参数、d 作关键字参数 e, f: 强制关键字参数 \u0026#34;\u0026#34;\u0026#34; print(a, b) print(c, d) print(e, f) test(1, 2, 3, 4, e=5, f=6) test(1, 2, 3, d=4, e=5, f=6) test(1, 2, c=3, d=4, e=5, f=6)   例三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def test(a, b, c, /, d, *args, e, f, **kwargs): \u0026#34;\u0026#34;\u0026#34; a, b, c: 强制位置参数 d: 当位置参数或关键字参数用 *args: 可变参数/多值参数，存入元组参数（后面跟强制关键字参数） e, f: 强制关键字参数 **kwargs: 多值参数，存入字典参数 \u0026#34;\u0026#34;\u0026#34; print(a, b, c, d) print(args) print(e, f) print(kwargs) test(1, 2, 3, 4, 55, 66, e=7, f=8, x=97, y=98, z=99)   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 4\r(55, 66)\r7 8\r{'x': 97, 'y': 98, 'z': 99}\r3. 两个坑 坑一 1 2 3 4 5 6 7 8 9 10  def test(*args, **kwargs): print(args) print(kwargs) nums = (1, 2, 3) d = {\u0026#39;a\u0026#39;: 97, \u0026#39;b\u0026#39;: 98, \u0026#39;c\u0026#39;: 99} test(nums, d) print(\u0026#34;=\u0026#34; * 30) test(*nums, **d)   \u0026gt;\u0026gt;\u0026gt;\n((1, 2, 3), {'a': 97, 'b': 98, 'c': 99})\r{}\r==============================\r(1, 2, 3)\r{'a': 97, 'b': 98, 'c': 99}\r坑二 错误的写法 1 2 3  def test(lst=[]): lst.append(\u0026#34;python\u0026#34;) return lst   操作一  这样没什么问题  1 2  print(test([\u0026#34;yorkfish\u0026#34;])) print(test([\u0026#34;jesscia\u0026#34;]))   \u0026gt;\u0026gt;\u0026gt;\n['yorkfish', 'python']\r['jesscia', 'python']\r操作二  这样有问题  1 2  print(test()) print(test())   \u0026gt;\u0026gt;\u0026gt;\n['python']\r['python', 'python']\r第一次调用 test，创建了 lst 却没有销毁\n第二次调用 test，函数认为接收了 ['python']，默认参数就失效了\r 正确的做法 1 2 3 4 5 6 7 8 9  def test(lst=None): if lst is None: lst = [] lst.append(\u0026#34;python\u0026#34;) return lst print(test()) print(test())   \u0026gt;\u0026gt;\u0026gt;\n['python']\r['python']\r函数的默认参数必须指向不可变对象\r ","description":"","id":89,"section":"python","tags":null,"title":"07. function arguments","uri":"https://yorkfish.github.io/review/python/basics/07_function_arguments/"},{"content":"1. 说明  函数名：map 顾名思意：映射  2. 举例 例一 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; b = [_ for _ in a] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; def mul2(num): ... return num * 2 ... \u0026gt;\u0026gt;\u0026gt; map(mul2, a) \u0026lt;map object at 0x000001DC17797430\u0026gt; \u0026gt;\u0026gt;\u0026gt; list(map(mul2, a)) [2, 4, 6, 8, 10] \u0026gt;\u0026gt;\u0026gt;   例三 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; list(map(lambda x: x*x, a)) [1, 4, 9, 16, 25] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":90,"section":"python","tags":null,"title":"07. map()","uri":"https://yorkfish.github.io/review/python/bif/07_map/"},{"content":"1. 导入 1  import numpy as np   2. 操作 创建 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; a = np.arange(12) \u0026gt;\u0026gt;\u0026gt; b = a.reshape((3, 4)) \u0026gt;\u0026gt;\u0026gt; print(a) [ 0 1 2 3 4 5 6 7 8 9 10 11] \u0026gt;\u0026gt;\u0026gt; print(b) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; id(a) 1809452646272 \u0026gt;\u0026gt;\u0026gt; id(b) 1809452699696 \u0026gt;\u0026gt;\u0026gt;   “变形” 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; id(a) 1809452646272 \u0026gt;\u0026gt;\u0026gt; a.resize((3, 4)) \u0026gt;\u0026gt;\u0026gt; id(a) 1809452646272 \u0026gt;\u0026gt;\u0026gt;   转置 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(a.T) [[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] \u0026gt;\u0026gt;\u0026gt;   展开 ravel()  返回的是原数组的一个视图(view)，会对原数组产生影响  1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(a.ravel()) [ 0 1 2 3 4 5 6 7 8 9 10 11] \u0026gt;\u0026gt;\u0026gt;   flatten()  返回的是一个新数组  1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] \u0026gt;\u0026gt;\u0026gt; print(a.flatten()) [ 0 1 2 3 4 5 6 7 8 9 10 11] \u0026gt;\u0026gt;\u0026gt;   flat 1 2 3  \u0026gt;\u0026gt;\u0026gt; [_ for _ in a.flat] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":91,"section":"python","tags":null,"title":"07. ndarray operation","uri":"https://yorkfish.github.io/review/python/numpy/07_ndarray_operation/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; class Hero(object): ... game_name = \u0026#34;LOL\u0026#34; # 类变量 ... def __init__(self, name): ... self.name = name # 实例变量 ... def flash(self): ... count = 0 # 局部变量 ... print(f\u0026#34;{self.name} used flash\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; lijing = Hero(\u0026#34;Lijing\u0026#34;) \u0026gt;\u0026gt;\u0026gt; lijing.flash() Lijing used flash \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":92,"section":"python","tags":null,"title":"07. 局部变量","uri":"https://yorkfish.github.io/review/python/class/07_local_var/"},{"content":"1. 关键字  auto  2. 说明  “自动变量”是函数中的局部变量 关键字可以省略，若省略，则隐含确定为“自动存储类别” 属于动态存储方式，数据存储在动态存储区中 如果不专门声明为 static 存储类别，都是动态地分配存储空间 调用该函数时，系统会给这些变量分配存储空间 调用结束时会自动释放这些存储空间  3. 举例  函数中的形参 函数中定义的变量 复合语句中定义的变量  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;stdio.h\u0026gt; // 执行完 test 函数，自动释放 num, start, stop 所占的存储单元 int test(int num) { auto int start; auto int stop = 3; for (start = 0; start \u0026lt; stop; start++) { num++; } return num; } int main() { int res = test(0); printf(\u0026#34;%d\\n\u0026#34;, res); // 3  return 0; }   ","description":"","id":93,"section":"c","tags":null,"title":"07. auto","uri":"https://yorkfish.github.io/review/c/function/07_auto/"},{"content":"1. 简介  fgets: 从指定文件读取一个字符串 fputs: 向指定文件写进一个字符串  2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;); fputs(\u0026#34;China\u0026#34;, fp); // 把字符串 \u0026#34;China\u0026#34; 输出到 fp 指向的文件  fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;); char str[6]; // str[5] 放 \u0026#39;\\0\u0026#39;  fgets(str, 6, fp); printf(\u0026#34;%s\\n\u0026#34;, str); fclose(fp); return 0; }   3. 说明   fputs 函数中的第一个参数可以是\n 字符串常量 字符数组 字符型指针    fgets 操作后的字符串，其末尾的 '\\0' 不输出\n 若输出成功，函数值为 0 若输出失败，函数值为 EOF    与 gets 和 puts 类似1\n gets: 输入字符串 puts: 输出字符串    fgets 和 fputs 可以指定文件\n   basic 12. gets() \u0026amp; puts() \u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":94,"section":"c","tags":null,"title":"07. fgets() \u0026 fputs()","uri":"https://yorkfish.github.io/review/c/file/07_fgets_and_fputs/"},{"content":"1. 一般定义形式 union 共用体 {\r成员表列\r} 变量表列;\r2. 说明  使几种不同的变量共占同一段内存的结构，称为“共用体” 共用体与结构体的定义形式相似，但它们的含义是不同的 结构体变量所占内存长度是各成员占的内存长度之和，每个成员分别占有其自己的内存单元 共用体变量所占内存长度等于最长的成员的长度 不能引用共用体变量，只能引用共用体变量的成员  3. 举例 例一 1 2 3 4 5 6 7  union data { int i; char ch; float f; }; union data a, b, c;   例二 1 2 3 4 5  union data { int i; char ch; float f; } a, b, c;   例三 1 2 3 4 5  union { int i; char ch; float f; } a, b, c;   ","description":"","id":95,"section":"c","tags":null,"title":"07. 共用体概述","uri":"https://yorkfish.github.io/review/c/struct-union-enum/07_overview_of_union/"},{"content":"1. 指针数组的概念 一般定义形式  类型名 * 数组名[数组长度]; 如：int * p[4];  ps  [] 比 * 优先级高 字符串比较应当用 strcmp 函数  2. 指向指针的指针 举例 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt; int main() { char* name[] = {\u0026#34;york\u0026#34;, \u0026#34;fish\u0026#34;}; char** p = name + 1; printf(\u0026#34;%p\\n\u0026#34;, name[1]); // 00404049，每次编译分配的地址不一定相同  printf(\u0026#34;%08x\\n\u0026#34;, (int)*p); // 00404049  printf(\u0026#34;%s\\n\u0026#34;, *p); // fish  return 0; }   ps  char** p; * 运算符的结合默认是从右到左，因此 **p 相当于 *(*p) 指针数组的元素只能存放地址  3. 指针数组作主函数的形参  实际上，主函数是可以有参数的，如：int main(int argc, char* argv[]) 命令行输入的形式：命令名 参数1 参数2 ... 参数n  举例 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { for (int i = 1; i \u0026lt; argc; i++) { printf(\u0026#34;%s\\n\u0026#34;, argv[i]); } return 0; }     编译命令：gcc main.c -o main\n  Input: main york fish\n  Output\nyork\rfish\r  ps  argc 是自动统计的 argv 把执行程序名也算在内  ","description":"","id":96,"section":"c","tags":null,"title":"07. 指针数组和指针的指针","uri":"https://yorkfish.github.io/review/c/pointer/07_pointer_array_and_pointer_to_pointer/"},{"content":"不推荐下文例子中的写法 1. 右结合性  即“自右向左”结合  例一  如 -i++ \u0026gt; -(i++)  1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { int i = 10; printf(\u0026#34;%d\\n\u0026#34;, -i++); // -10  printf(\u0026#34;%d\\n\u0026#34;, i); // 11  return 0; }    “负号”与 ++ 同级，默认右结合  例二 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; void func(int a, int b) { printf(\u0026#34;%d, %d\\n\u0026#34;, a, b); } int main() { int i = 10; func(i, i++); // 11, 10  return 0; }    函数的参数，从右向左“生成”  2. 左结合性  即“自左向右”结合  例三  如 i+++j \u0026gt; (i++) + j  1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { int i = 10; int j = 20; printf(\u0026#34;%d\\n\u0026#34;, i+++j); // 30  printf(\u0026#34;%d\\n\u0026#34;, i); // 11  printf(\u0026#34;%d\\n\u0026#34;, j); // 20  return 0; }    组成运算符时，尽可能多地左结合 标识符、关键字也遵循这个原则  ","description":"","id":97,"section":"c","tags":null,"title":"07. 结合方向","uri":"https://yorkfish.github.io/review/c/basics/07_combination_direction/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, width=30, height=2) l.pack() window.mainloop()   2. 添加一个 scale 1 2 3 4 5 6 7 8 9  def print_selection(v): l.config(text=\u0026#34;you have selected \u0026#34; + v) s = tk.Scale(window, label=\u0026#34;try me\u0026#34;, orient=\u0026#39;horizontal\u0026#39;, from_=0, to=10, length=400, showvalue=0, tickinterval=2, resolution=0.01, command=print_selection) s.pack()   ps    参数 释义     label 设置标签值   orient 设置拖拽条（滚动条）方向   from_ 起始值   to 最终值   length 拖拽条的长度   showvalue 设置是否拖拽条上方显示数值\n0: 不显示，1: 显示   tickinterval 间隔   resolution 精度     一般地，tkinter 的 length 的单位是像素  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, width=30, height=2) l.pack() def print_selection(v): l.config(text=\u0026#34;you have selected \u0026#34; + v) s = tk.Scale(window, label=\u0026#34;try me\u0026#34;, orient=\u0026#39;horizontal\u0026#39;, from_=0, to=10, length=200, showvalue=0, tickinterval=2, resolution=0.01, command=print_selection) s.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"尺度","id":98,"section":"python","tags":null,"title":"08. Scale","uri":"https://yorkfish.github.io/review/python/tkinter/08_scale/"},{"content":"1. 简介  列表、集合、字典可以用生成式快速生成  2. 举例 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; [i for i in range(10)] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; {s for s in range(10)} {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; {d: d%2==0 for d in range(5)} {0: True, 1: False, 2: True, 3: False, 4: True} \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":99,"section":"python","tags":null,"title":"08. generator","uri":"https://yorkfish.github.io/review/python/basics/08_generator/"},{"content":"1. 提出问题  只安装了 Anaconda，想使用 IDLE  2. 解决方法  我的 Anaconda 装在 D:\\anaconda3  方式一  双击 D:\\anaconda3\\Lib\\idlelib\\idle.bat  方式二  双击 D:\\anaconda3\\Scripts\\idle.exe 双击后会先出现一个命令窗，再出来 IDLE  方式三  在桌面，右键 \u0026gt; 新建 \u0026gt; 快捷方式 在弹窗口中输入 D:\\anaconda3\\pythonw.exe \u0026quot;D:\\anaconda3\\Lib\\idlelib\\idle.pyw\u0026quot;，点击确定 在新弹窗中输入 IDLE，点击确定  ","description":"","id":100,"section":"python","tags":null,"title":"08. IDLE","uri":"https://yorkfish.github.io/review/python/operation/08_idle/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11  import numpy as np import matplotlib.pyplot as plt def square(x): return -x**2 + 1 a = np.linspace(-5, 5, 200) # [-5, 5] 之内取 200 个点 plt.plot(a, square(a)) plt.show()     得到图片\n  ","description":"","id":101,"section":"python","tags":null,"title":"08. matplotlib pyplot","uri":"https://yorkfish.github.io/review/python/numpy/08_matplotlib_pyplot/"},{"content":"1. 说明  sort() 是 list 的方法 sorted() 是 Python 的内置函数，不隶属于某种数据类型 sorted() 可以对所有的可迭代对象进行排序  2. 举例 例一 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; lst = [\u0026#34;Tony Black\u0026#34;, \u0026#34;Amy Green\u0026#34;, \u0026#34;Johnny Lee\u0026#34;] \u0026gt;\u0026gt;\u0026gt; lst.sort() \u0026gt;\u0026gt;\u0026gt; lst [\u0026#39;Amy Green\u0026#39;, \u0026#39;Johnny Lee\u0026#39;, \u0026#39;Tony Black\u0026#39;] \u0026gt;\u0026gt;\u0026gt; lst.sort(reverse=True) \u0026gt;\u0026gt;\u0026gt; lst [\u0026#39;Tony Black\u0026#39;, \u0026#39;Johnny Lee\u0026#39;, \u0026#39;Amy Green\u0026#39;] \u0026gt;\u0026gt;\u0026gt; lst.sort(key=lambda x: x[2]) \u0026gt;\u0026gt;\u0026gt; lst [\u0026#39;Johnny Lee\u0026#39;, \u0026#39;Tony Black\u0026#39;, \u0026#39;Amy Green\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; d = {\u0026#34;Tony\u0026#34;: 22, \u0026#34;Amy\u0026#34;: 19, \u0026#34;Johnny\u0026#34;: 25} \u0026gt;\u0026gt;\u0026gt; sorted(d.values()) [19, 22, 25] \u0026gt;\u0026gt;\u0026gt; sorted(d.items(), key=lambda x: x[0]) # 按字典的键排序 [(\u0026#39;Amy\u0026#39;, 19), (\u0026#39;Johnny\u0026#39;, 25), (\u0026#39;Tony\u0026#39;, 22)] \u0026gt;\u0026gt;\u0026gt; sorted(d.items(), key=lambda x: x[1], reverse=True) # 按字典的值排序 [(\u0026#39;Johnny\u0026#39;, 25), (\u0026#39;Tony\u0026#39;, 22), (\u0026#39;Amy\u0026#39;, 19)] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":102,"section":"python","tags":null,"title":"08. sorted()","uri":"https://yorkfish.github.io/review/python/bif/08_sorted/"},{"content":"举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Hero(object): # 类变量 game_name = \u0026#34;LOL\u0026#34; def __init__(self, name): # 实例变量 self.name = name # 实例方法 def flash(self): # 局部变量 count = 0 print(f\u0026#34;{self.name} used flash!\u0026#34;) # 类方法 @classmethod def heal(cls): print(cls.game_name) @classmethod def heals(cls, hero): print(hero.name) lijing = Hero(\u0026#34;Lijing\u0026#34;) # Hero.flash() # TypeError: flash() missing 1 required positional argument: \u0026#39;self\u0026#39; # Hero 无法传入一个实例对象的指针来对应形参 self Hero.heal() # 类使用类方法 lijing.heal() # 实例使用类方法 lijing.heals(lijing) # 实例使用类方法访问实例变量   \u0026gt;\u0026gt;\u0026gt;\nLOL\rLOL\rLijing\r","description":"","id":103,"section":"python","tags":null,"title":"08. 类方法与实例方法","uri":"https://yorkfish.github.io/review/python/class/08_class_method_and_instance_method/"},{"content":"1. rewind 简介  使位置指针重新返回文件的开头 此函数没有返回值  作用  文件的位置指针重新定位于开头 feof 的值恢复为 0（假）  2. fseek 简介  对流式文件可以进行顺序读写，也可以进行随机读写 此函数可以实现改变文件的位置指针 一般用于二进制文件，因为文本文件要发生字符转换，计算位置时往往会发生混乱 可以借助此函数实现随机读写  一般形式  fseek(文件类型指针, 位移量, 起始点);     起始点 名字 代表数字     文件开始 SEEK_SET 0   当前位置 SEEK_CUR 1   文件末尾 SEEK_END 2     位移量：以“起始点”为基点，向前移动的字节数  ANSI C 和大多数 C 版本要求位移量是 long 型数据 如此，当文件的长度大于 64kb 时，不致于出问题    举例 fseek(fp, 100L, 0); // 将位置指针移到离文件头 100 个字节处\rfseek(fp, 50L, 1); // 将位置指针移到离当前位置 50 个字节处\rfseek(fp, -10L, 2); // 将位置指针从文件末尾处向后退 10 个字节\r3. ftell 简介  得到流式文件中的当前位置，用相对于文件开头的位移量来表示 如果 ftell 返回的是 -1L，表示出错  4. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); float nums[5] = {11.0, 12.0, 13.0, 14.0, 15.0}; int fsize = sizeof(float); for (int i = 0; i \u0026lt; 5; i++) { fwrite(\u0026amp;nums[i], fsize, 1, fp); } fclose(fp); fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;rb\u0026#34;); float temp; long addr = ftell(fp); printf(\u0026#34;addr: %ld\\n\u0026#34;, addr); // addr: 0  fread(\u0026amp;temp, fsize, 1, fp); printf(\u0026#34;num: %f\\n\u0026#34;, temp); // num: 11.000000  fseek(fp, 12L, 1); addr = ftell(fp); printf(\u0026#34;addr: %ld\\n\u0026#34;, addr); // addr: 16  fread(\u0026amp;temp, fsize, 1, fp); printf(\u0026#34;num: %f\\n\u0026#34;, temp); // num: 15.000000  rewind(fp); addr = ftell(fp); printf(\u0026#34;addr: %ld\\n\u0026#34;, addr); // addr: 0  fread(\u0026amp;temp, fsize, 1, fp); printf(\u0026#34;num: %f\\n\u0026#34;, temp); // num: 11.000000  fclose(fp); return 0; }   ","description":"","id":104,"section":"c","tags":null,"title":"08. rewind, fseek, ftell","uri":"https://yorkfish.github.io/review/c/file/08_rewind-fseek-ftell/"},{"content":"1. 关键字  static  2. 说明  若希望函数中的局部变量在函数调用结束后继续存在，即其占用的存储单元不释放，需要用到静态局部变量 若之前调用过静态局部变量，则使用时默认为上次结束时的值 若非必要，不要多用静态变量  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; void test() { static int num = 1; printf(\u0026#34;%d\\n\u0026#34;, num); num++; } int main() { test(); // 1  test(); // 2  return 0; }   ","description":"","id":105,"section":"c","tags":null,"title":"08. static","uri":"https://yorkfish.github.io/review/c/function/08_static/"},{"content":"1. 说明  每一瞬时，只有一个成员起作用 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后，原有的成员就失效 共用体变量的地址和它的各成员的地址都是同一地址  不可行的操作  不能对共用体变量名赋值 不能企图引用变量名来得到一个值 不能在定义共用体变量时对它初始化 不能把共用体变量作为函数参数 不能使函数返回共用体变量  可行的操作  可以使用指向共用体变量的指针（与结构体变量这种用法相仿） 共用体类型可以出现在结构体类型定义中 结构体类型可以出现在共用体类型定义中 可以定义共用体数组 数组可以作为共用体的成员  2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;stdio.h\u0026gt; typedef union data { int i; char c; } Data, *pData; int main() { Data test; pData pTest = \u0026amp;test; printf(\u0026#34;%d\\n\u0026#34;, sizeof(test)); // 4  test.i = 10; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;test.i); // 0061FEC8，每次编译分配的地址不一定相同  printf(\u0026#34;%d\\n\u0026#34;, test.i); // 10  test.c = \u0026#39;y\u0026#39;; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;test.c); // 0061FEC8  printf(\u0026#34;%c\\n\u0026#34;, test.c); // y  printf(\u0026#34;%c\\n\u0026#34;, pTest-\u0026gt;c); // y  return 0; }   ","description":"","id":106,"section":"c","tags":null,"title":"08. 共用体的特点与使用","uri":"https://yorkfish.github.io/review/c/struct-union-enum/08_characteristics_of_union/"},{"content":"1. malloc 函数原型 void * malloc(unsigned int size);\n作用  在内存的动态存储区中分配一个长度为 size 的连续空间 此函数的值（即返回值），是一个分配域的起始地址，类型为 void 如果此函数未能成功执行（如内存空间不足），则返回空指针 NULL  2. calloc 函数原型 void * calloc(unsigned n, unsigned size);\n作用   在内存的动态存储中分配 n 个长度为 size 的连续空间\n  函数返回一个指向分配域起始位置的指针\n  如果分配不成功，返回 NULL\n  calloc 函数可以为一维数组开辟动态存储空间，n 为数组元素个数，每个元素长度为 size\n  3. realloc 函数原型 void *realloc(void *p, unsigned size)\n作用  重新分配由 p 指向的动态存储区 函数返回一个指向分配域起始位置的指针 如果分配不成功，返回 NULL  4. free 函数原型 void free(void * p);\n作用  释放由 p 指向的动态存储区 使这部分内存区能被其他内存使用 p 是最近一次调用 calloc 或 malloc 函数时返回的值 free 函数无返回值  5. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int** initNums(int numsSize, int* numsColSize) { int** nums = malloc(numsSize * sizeof(int*)); for (int i = 0; i \u0026lt; numsSize; i++) { nums[i] = calloc(numsColSize[i], sizeof(int)); } return nums; } void printNums(int** nums, int numsSize, int* numsColSize) { for (int i = 0; i \u0026lt; numsSize; i++) { for (int j = 0; j \u0026lt; numsColSize[i]; j++) { printf(\u0026#34;%d \u0026#34;, nums[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } void resizeNums(int** nums, int row, int resize) { realloc(nums[row], resize); } void freeNums(int** nums, int numsSize) { for (int i = 0; i \u0026lt; numsSize; i++) { free(nums[i]); } free(nums); } int main() { int numsSize = 3; int numsColSize[] = {5, 5, 5}; int** nums = initNums(numsSize, numsColSize); printNums(nums, numsSize, numsColSize); printf(\u0026#34;=========\\n\u0026#34;); numsColSize[1]++; resizeNums(nums, numsSize, numsColSize[1]); printNums(nums, numsSize, numsColSize); freeNums(nums, 3); return 0; }   ","description":"","id":107,"section":"c","tags":null,"title":"08. 动态分配内存与释放","uri":"https://yorkfish.github.io/review/c/pointer/08_malloc_calloc_realloc_free/"},{"content":"常用格式    符号 释义     %o 八进制整型数   %d 十进制整型数，%i 也行   %Ld 十进制长整型数   %u 无符号整型数   %Lu 无符号长整型数   %x 十六进制整型数   %mc 字符占 m 个宽度，右对齐   %-mc 字符占 m 个宽度，左对齐   %f 以小数形式输出单、双精度数，隐含输出 6 位小数   %e 一般，输出占 13 列   %g 根据数值的大小，自动选 f 格式或 e 格式\n选择输出占宽度较小的一种，且不输出无意义的零    ","description":"","id":108,"section":"c","tags":null,"title":"08. 输出格式","uri":"https://yorkfish.github.io/review/c/basics/08_format/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8 9  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 18), width=20) l.pack() window.mainloop()   2. 添加两个 checkbutton 1 2 3 4 5 6 7 8 9 10  var1 = tk.BooleanVar() var2 = tk.BooleanVar() c1 = tk.Checkbutton(window, text=\u0026#34;C \u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), # 对齐~ variable=var1, onvalue=True, offvalue=False, command=print_selection) c2 = tk.Checkbutton(window, text=\u0026#34;Python\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), variable=var2, onvalue=True, offvalue=False, command=print_selection) c1.pack() c2.pack()   ps  onvalue, offvalue 和 tkinter.Radiobutton 中的 value 相似 以 c1 为例  选中 checkbutton 后  onvalue 的值会存入 var1 var1 将其赋值给参数 variable   没有选中 checkbutton 时  offvalue 的值会存入 var1 var1 将其赋值给参数 variable      3. print_selection 方法  需要写在调用它的语句的上方  1 2 3 4 5 6 7 8 9  def print_selection(): if var1.get() and var2.get(): l.config(text=\u0026#34;I love both\u0026#34;) elif var1.get(): l.config(text=\u0026#34;I love only C\u0026#34;) elif var2.get(): l.config(text=\u0026#34;I love only Python\u0026#34;) else: l.config(text=\u0026#34;I do not love either\u0026#34;)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;empty\u0026#34;, bg=\u0026#34;yellow\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 18), width=20) l.pack() def print_selection(): if var1.get() and var2.get(): l.config(text=\u0026#34;I love both\u0026#34;) elif var1.get(): l.config(text=\u0026#34;I love only C\u0026#34;) elif var2.get(): l.config(text=\u0026#34;I love only Python\u0026#34;) else: l.config(text=\u0026#34;I do not love either\u0026#34;) var1 = tk.BooleanVar() var2 = tk.BooleanVar() c1 = tk.Checkbutton(window, text=\u0026#34;C \u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), variable=var1, onvalue=True, offvalue=False, command=print_selection) c2 = tk.Checkbutton(window, text=\u0026#34;Python\u0026#34;, font=(\u0026#34;Consolas\u0026#34;, 16), variable=var2, onvalue=True, offvalue=False, command=print_selection) c1.pack() c2.pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"勾选项","id":109,"section":"python","tags":null,"title":"09. Checkbutton","uri":"https://yorkfish.github.io/review/python/tkinter/09_checkbutton/"},{"content":"1. 简介  help() 可以查看开发者对于“模块、函数、类”所编写的详细描述文档  2. 说明 例一 1 2 3 4 5 6 7 8  \u0026#34;\u0026#34;\u0026#34; This module is for explain \u0026#34;help()\u0026#34;. help 函数可以查看开发者对于“模块、函数、类”所编写的详细描述文档 \u0026#34;\u0026#34;\u0026#34; import __main__ help(__main__)   \u0026gt;\u0026gt;\u0026gt;\nHelp on module __main__:\rNAME\r__main__\rDESCRIPTION\rThis module is for explain \u0026quot;help()\u0026quot;.\rhelp 函数可以查看开发者对于“模块、函数、类”所编写的详细描述文档\rDATA\r__annotations__ = {}\rFILE\rd:\\Test\\help.py\r例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026gt;\u0026gt;\u0026gt; import __main__ \u0026gt;\u0026gt;\u0026gt; help(__main__) Help on module __main__: NAME __main__ DATA __annotations__ = {} FILE (built-in) \u0026gt;\u0026gt;\u0026gt;   例三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def flash(): \u0026#34;\u0026#34;\u0026#34; This is a flash function. :return str. \u0026#34;\u0026#34;\u0026#34; pass class Hero(object): \u0026#34;\u0026#34;\u0026#34; This is a hero class. \u0026#34;\u0026#34;\u0026#34; def __init__(): pass if __name__ == \u0026#34;__main__\u0026#34;: help(flash) help(Hero)   \u0026gt;\u0026gt;\u0026gt;\nHelp on function flash in module __main__:\rflash()\rThis is a flash function.\r:return str.\rHelp on class Hero in module __main__:\rclass Hero(builtins.object)\r| This is a hero class.\r| | Methods defined here:\r| | __init__()\r| Initialize self. See help(type(self)) for accurate signature.\r| | ----------------------------------------------------------------------\r| Data descriptors defined here:\r| | __dict__\r| dictionary for instance variables (if defined)\r| | __weakref__\r| list of weak references to the object (if defined)\r","description":"","id":110,"section":"python","tags":null,"title":"09. help","uri":"https://yorkfish.github.io/review/python/basics/09_help/"},{"content":"1. 导入 1  import numpy as py   2. 一维 创建 1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; a = np.arange(4) \u0026gt;\u0026gt;\u0026gt; b = np.arange(4, 8) \u0026gt;\u0026gt;\u0026gt; print(a) [0 1 2 3] \u0026gt;\u0026gt;\u0026gt; print(b) [4 5 6 7] \u0026gt;\u0026gt;\u0026gt;   hstack 1 2 3  \u0026gt;\u0026gt;\u0026gt; print(np.hstack((a, b))) [0 1 2 3 4 5 6 7] \u0026gt;\u0026gt;\u0026gt;   vstack 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; print(np.vstack((a, b))) [[0 1 2 3] [4 5 6 7]] \u0026gt;\u0026gt;\u0026gt;   3. 二维  横向堆叠，行数需相同 纵向堆叠，列数需相同  创建 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; c = np.arange(4).reshape((2, 2)) \u0026gt;\u0026gt;\u0026gt; d = np.arange(4, 8).reshape((2, 2)) \u0026gt;\u0026gt;\u0026gt; print(c) [[0 1] [2 3]] \u0026gt;\u0026gt;\u0026gt; print(d) [[4 5] [6 7]] \u0026gt;\u0026gt;\u0026gt;   hstack 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; print(np.hstack((c, d))) [[0 1 4 5] [2 3 6 7]] \u0026gt;\u0026gt;\u0026gt;   vstack 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; print(np.vstack((c, d))) [[0 1] [2 3] [4 5] [6 7]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":111,"section":"python","tags":null,"title":"09. hstack \u0026 vstack","uri":"https://yorkfish.github.io/review/python/numpy/09_hstack_and_vstack/"},{"content":"1. 说明  一般地，除字符串外，能使用 + 操作的，都可以使用 sum()  2. 举例 例一 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; sum(a) 10 \u0026gt;\u0026gt;\u0026gt; sum(a, 5) 15 \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = [[1, 2, 3]] * 3 \u0026gt;\u0026gt;\u0026gt; sum(a, []) [1, 2, 3, 1, 2, 3, 1, 2, 3] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":112,"section":"python","tags":null,"title":"09. sum()","uri":"https://yorkfish.github.io/review/python/bif/09_sum/"},{"content":"1. 简介  “实例方法”只能由“实例对象”调用 “类”和“实例对象”都能调用“类方法”和“静态方法” “实例方法”、“类方法”和“静态方法”均能调用“类变量”和“实例变量”  2. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  class Hero(object): # 类变量 game_name = \u0026#34;LOL\u0026#34; def __init__(self, name): # 实例变量 self.name = name # 实例方法 def flash(self): # 局部变量 count = 0 print(f\u0026#34;{self.name} used flash!\u0026#34;) # 类方法 @classmethod def heal(cls): print(cls.game_name) # 在类方法中使用类变量 @classmethod def heals(cls): print(lijing.name) # 在类方法中使用实例变量 # 静态方法 @staticmethod def ignit(): print(\u0026#34;used fire\u0026#34;) @staticmethod def say_game_name(): print(Hero.game_name) # 在静态方法中使用类变量 print(lijing.name) # 在静态方法中使用实例变量 lijing = Hero(\u0026#34;Lijing\u0026#34;) lijing.flash() # 实例调用实例方法 Hero.heal() # 类使用类方法 lijing.heal() # 实例使用类方法 Hero.ignit() # 类使用静态方法 lijing.ignit() # 实例使用静态方法 lijing.heals() # 实例使用类方法访问实例变量 lijing.say_game_name() # 实例使用静态方法访问类变量与实例变量 Hero.say_game_name() # 类使用静态方法访问类变量与实例变量   \u0026gt;\u0026gt;\u0026gt;\nLijing used flash!\rLOL\rLOL\rused fire\rused fire\rLijing\rLOL\rLijing\rLOL\rLijing\r","description":"","id":113,"section":"python","tags":null,"title":"09. 静态方法","uri":"https://yorkfish.github.io/review/python/class/09_static_method/"},{"content":"1. ferror 简介  除了在 getc, putc, fread, fwrite 等函数出错时有用 还可以主动使用以检查  一般形式 ferror(fp);\n说明  若返回值为 0，表示未出错 若返回一个非零值，表示出错 同一个文件每次调用输入输出函数，均产生一个新的 ferror 函数值 在调用一个输入输出函数后，应立即检查，否则信息会丢失  2. clearerr 作用  将文件错误标志和文件结束标志置为 0  说明   假设在调用一个输入输出函数时出现错误，ferror 函数值为一个非零值\n  在调用 clearerr(fp) 后，ferror(fp) 的值变为 0\n  只要出现错误标志，就一直保留，直到出现如下情况\n 对同一文件调用 clearerr 函数 对同一文件调用 rewind 函数 使用任何其他一个输入输出函数    3. 举例 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;test.txt\u0026#34;, \u0026#34;wb\u0026#34;); fputs(\u0026#34;YorkFish\u0026#34;, fp); printf(\u0026#34;%d\\n\u0026#34;, ferror(fp)); // 0  fclose(fp); return 0; }   ","description":"","id":114,"section":"c","tags":null,"title":"09. ferror() \u0026 clearerr()","uri":"https://yorkfish.github.io/review/c/file/09_ferror_and_clearerr/"},{"content":" 无条件转向语句  1. 形式  goto 语句标号;  语句标号：用标识符表示，命名规则与标识符相同（字母、数字、下划线，不用数字开头） 如：goto label_1;    2. 使用  一般不用，以下两种情形可以考虑  与 if 语句构成循环结构 从循环体中跳转到循环体外  因为有 break 与 continue，goto 的使用机会不多 需要从多重循环的内层跳转到循环的外层，可以使用 goto 即使是跳出多重循环，一般也不采用 goto      3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { int i = 1, sum = 0; loop: if (i \u0026lt;= 100) { sum += i; i++; goto loop; } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; }   ","description":"","id":115,"section":"c","tags":null,"title":"09. goto","uri":"https://yorkfish.github.io/review/c/basics/09_goto/"},{"content":"1. 结论  实际上，用 register 声明变量是不必要的 如今优化的编译系统能够识别频繁的变量，从而自动地将这些变量放在寄存器中  2. 了解  由于对寄存器的存取速度远高于对内存的存取速度，因此这样做可以提高执行效率 如果需要重复运算的 n 很大，使用 register 可以节约许多执行时间 一个计算机系统中的寄存器数目是有限的 有的系统只允许将 int, char 和指针型变量定义为寄存器 局部静态变量不能定义为寄存器变量 register static int a, b, c;  3. 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int factorial(long n) { register long ans = 1; for (int i = 2; i \u0026lt;= n; i++) { ans *= i; } return ans; } int main() { int res = factorial(19); printf(\u0026#34;%d\\n\u0026#34;, res); // 109641728  return 0; }   ","description":"","id":116,"section":"c","tags":null,"title":"09. register","uri":"https://yorkfish.github.io/review/c/function/09_register/"},{"content":"1. 常见的数据类型    定义 含义     int i 定义整型变量   int * p p 为指向整型数据的指针变量   int a[n] 定义整型数组 a，它有 n 个元素   int * p[n] 定义指针数组 p，它由 n 个指向整型数据的指针元素组成   int (*p)[n] p 为指向含 n 个元素的一维数组的指针变量   int f() f 为返回整型函数值的函数   int * p() p 为返回一个指针的函数，该指针指向整型数据   int (*p)() p 为指向函数的指针，该函数返回一个整型值   int **p p 是一个指针变量，它指向一个指向整型数据的指针变量    2. 指针运算 指针变量加减一个整数  p++ p-- p+i p-i p += i p -= i  指针变量赋值   p = \u0026amp;arr;\n  p = arr;\n  p = \u0026amp;arr[i];\n  p = max;\n  p1 = p2;\n  不应把一个整数赋给指针变量\n  不应把指针变量的值赋给一个整型变量\n  指针变量可以有空值  NULL 是整数 0，它的存储单元中所有二进位均为 0 一般，NULL 是这样定义的：#define NULL 0 系统保证 NULL 不作他用（不存放有效数据），即有效数据的指针不指向 0 单元 int* p = NULL; 与 int* p; 是两个不同的概念 任何指针变量或地址都可以与 NULL 作相等或不相等的比较  两个指针变量可以相减  两个指针变量之差是两个指针之间的元素的个数 p1 + p2 是没有意义的  两个指针变量的比较  若两个指针指向同一个数组的元素，则可以进行比较 指向前面的指针变量“小于”指向后面元素的指针变量  3. void 指针类型  (void *)p1: 将 p1 的值转换成 void * 类型 将一个函数定义为 void * 类型  函数返回的是一个地址，它指向“空类型” 可以对该函数调用得到的地址进行强制类型转换，如 char* p2 = (char*)func(str, n);    ","description":"","id":117,"section":"c","tags":null,"title":"09. 小结","uri":"https://yorkfish.github.io/review/c/pointer/09_summary/"},{"content":"1. 使用场景  如果一个变量只有几种可能的值，则可以定义为枚举类型 变量的值只限于列举出来的值的范围  2. 一般定义形式 enum weekday {sun, mon, tue, wed, thu, fri, sat};\n3. 用法 例一  C 编译中，对枚举元素按常量处理，故称枚举常量 因为是常量，所以不能像变量那样对它们赋值 枚举元素作为常量是有值的，按顺序，默认为 0, 1, 2, \u0026hellip;  1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; enum weekday {sun, mon, tue, wed, thu, fri, sat}; int main() { enum weekday weekend, workday; weekend = sun; workday = mon; printf(\u0026#34;%d, %d\\n\u0026#34;, weekend, workday); // 0, 1  return 0; }   例二  可以改变枚举元素的值  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; enum weekday { sun = 7, mon = 1, tue, wed, thu, fri, sat } weekend, workday; // tue = 2, ...  int main() { weekend = sun; workday = tue; printf(\u0026#34;%d, %d\\n\u0026#34;, weekend, workday); // 7, 2  return 0; }   例三  枚举值可以用来作判断比较 一个整数不能直接赋给一个枚举变量，需要先进行强制类型转换  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt; typedef enum weekday { sun = 7, mon = 1, tue, wed, thu, fri, sat } Weekday; int main() { Weekday weekend = sun; Weekday workday1 = (Weekday)1; // 相当于 \u0026#34;workday = tue;\u0026#34;  Weekday workday2 = (Weekday)(5-3); if (workday1) { printf(\u0026#34;%d, %d\\n\u0026#34;, weekend, workday2); // 7, 2  } return 0; }   ","description":"","id":118,"section":"c","tags":null,"title":"09. 枚举","uri":"https://yorkfish.github.io/review/c/struct-union-enum/09_enum/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;500x300\u0026#34;) window.mainloop()   2. 添加一个 canvas 1 2 3  canvas = tk.Canvas(window, bg=\u0026#34;gray\u0026#34;, width=500, height=250) # ... canvas.pack()   3. 添加图片 1 2  image_file = tk.PhotoImage(file=\u0026#34;test.png\u0026#34;) image = canvas.create_image(0, 0, anchor=\u0026#34;nw\u0026#34;, image=image_file)   ps   Python 3.8 的 tkinter 支持 PGM, PPM, GIF, PNG 四种格式\n  想使用 JPG 格式的话，可以借助 Pillow\n  anchor 属性有如下几种方位\nNR N NE\rW CENTER E\rSW S SE\r  4. 画线 1  line = canvas.create_line(0, 0, 100, 100)   5. 画圆 1  oval = canvas.create_oval(0, 0, 100, 100, fill=\u0026#34;red\u0026#34;)   6. 画扇形 1  arc = canvas.create_arc(0, 0, 100, 100, start=30, extent=120)   7. 画矩形 1  rect = canvas.create_rectangle(0, 0, 200, 100)   8. 移动图形 1 2 3 4 5  def move_down(): canvas.move(rect, 0, 2) # 横坐标移动 0 个单位，纵坐标移动 2 个单位 tk.Button(window, text=\u0026#34;move down\u0026#34;, width=10, command=move_down).pack()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;500x300\u0026#34;) canvas = tk.Canvas(window, bg=\u0026#34;gray\u0026#34;, width=500, height=250) image_file = tk.PhotoImage(file=\u0026#34;ins.gif\u0026#34;) image = canvas.create_image(0, 0, anchor=\u0026#34;nw\u0026#34;, image=image_file) x0, y0, x1, y1 = 100, 100, 200, 200 line = canvas.create_line(x0, y0, x1, y1) oval = canvas.create_oval(x0, y0, x1, y1, fill=\u0026#34;red\u0026#34;) arc = canvas.create_arc(200, 100, 300, 200, start=30, extent=120) rect = canvas.create_rectangle(300, 100, 400, 200) canvas.pack() def move_down(): canvas.move(rect, 0, 2) # 横坐标移动 0 个单位，纵坐标移动 2 个单位 tk.Button(window, text=\u0026#34;move down\u0026#34;, width=10, command=move_down).pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"画布","id":119,"section":"python","tags":null,"title":"10. Canvas","uri":"https://yorkfish.github.io/review/python/tkinter/10_canvas/"},{"content":"1. 简介  np.hstack() 与 np.vstack() 无法指定 axis  2. 操作 导入 1  import numpy as np   创建 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2], [3, 4]]) \u0026gt;\u0026gt;\u0026gt; b = np.array([[5, 6]]) \u0026gt;\u0026gt;\u0026gt; print(a) [[1 2] [3 4]] \u0026gt;\u0026gt;\u0026gt; print(b) [[5 6]] \u0026gt;\u0026gt;\u0026gt;   显示形状 1 2 3 4 5  \u0026gt;\u0026gt;\u0026gt; a.shape (2, 2) \u0026gt;\u0026gt;\u0026gt; b.shape (1, 2) \u0026gt;\u0026gt;\u0026gt;   连接 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; c = np.concatenate((a, b)) \u0026gt;\u0026gt;\u0026gt; print(c) [[1 2] [3 4] [5 6]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d = np.concatenate((a, b.T), axis=1) \u0026gt;\u0026gt;\u0026gt; print(d) [[1 2 5] [3 4 6]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":120,"section":"python","tags":null,"title":"10. concatenate","uri":"https://yorkfish.github.io/review/python/numpy/10_concatenate/"},{"content":"例一 导入时避免使用相对路径   文件结构\nD:\\test\rprints.py\rimport_issue.py\r  import_issue.py\n1  from .prints import *     运行结果\n...\rImportError: attempted relative import with no known parent package\r...\r  说明\n . 所表示的根路径也是 '__main__' 的值 在入口文件中，应该避免使用相对路径进行模块导入    例二 查看模块信息 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; import time \u0026gt;\u0026gt;\u0026gt; time \u0026lt;module \u0026#39;time\u0026#39; (built-in)\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random \u0026lt;module \u0026#39;random\u0026#39; from \u0026#39;D:\\\\anaconda3\\\\lib\\\\random.py\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;   例三 查看模块路径 1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; __import__(\u0026#39;random\u0026#39;) \u0026lt;module \u0026#39;random\u0026#39; from \u0026#39;D:\\\\anaconda3\\\\lib\\\\random.py\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import http.server \u0026gt;\u0026gt;\u0026gt; http.server \u0026lt;module \u0026#39;http.server\u0026#39; from \u0026#39;D:\\\\anaconda3\\\\lib\\\\http\\\\server.py\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;   例四 一行导入并使用 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; __import__(\u0026#39;random\u0026#39;).randint(1, 10) 6 \u0026gt;\u0026gt;\u0026gt; __import__(\u0026#39;random\u0026#39;).randint(1, 10) 1 \u0026gt;\u0026gt;\u0026gt; random Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; NameError: name \u0026#39;random\u0026#39; is not defined \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random \u0026lt;module \u0026#39;random\u0026#39; from \u0026#39;D:\\\\anaconda3\\\\lib\\\\random.py\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":121,"section":"python","tags":null,"title":"10. import","uri":"https://yorkfish.github.io/review/python/basics/10_import/"},{"content":"例一 1 2 3 4  lst_a = [\u0026#39;a1\u0026#39;, \u0026#39;b1\u0026#39;, \u0026#39;c1\u0026#39;] lst_b = [\u0026#39;a2\u0026#39;, \u0026#39;b2\u0026#39;, \u0026#39;c2\u0026#39;] for a, b in zip(lst_a, lst_b): print(a, b)   \u0026gt;\u0026gt;\u0026gt;\na1 a2\rb1 b2\rc1 c2\r例二  有点像木桶原理，多出的数据不作处理  1 2 3 4  lst_c = [\u0026#39;a3\u0026#39;, \u0026#39;b3\u0026#39;, \u0026#39;c3\u0026#39;, \u0026#39;d3\u0026#39;, \u0026#39;e3\u0026#39;] lst_d = [\u0026#39;a4\u0026#39;, \u0026#39;b4\u0026#39;, \u0026#39;c4\u0026#39;] for c, d in zip(lst_c, lst_d): print(c, d)   \u0026gt;\u0026gt;\u0026gt;\na3 a4\rb3 b4\rc3 c4\r","description":"","id":122,"section":"python","tags":null,"title":"10. zip()","uri":"https://yorkfish.github.io/review/python/bif/10_zip/"},{"content":"公共部分 1 2 3  class Hero(object): def __init__(self, name): self.name = name   例一 1 2 3 4 5 6 7 8  class AD1(Hero): def __init__(self, name, gender): self.name = name self.gender = gender ashe = AD1(\u0026#34;艾希\u0026#34;, \u0026#34;female\u0026#34;) print(ashe.__dict__)   \u0026gt;\u0026gt;\u0026gt;\n{'name': '艾希', 'gender': 'female'}\r例二 1 2 3 4 5 6 7 8  class AD2(Hero): def __init__(self, name, gender): Hero.__init__(self, name) self.gender = gender jinx = AD2(\u0026#34;金克丝\u0026#34;, \u0026#34;female\u0026#34;) print(jinx.__dict__)   \u0026gt;\u0026gt;\u0026gt;\n{'name': '金克丝', 'gender': 'female'}\r例三 1 2 3 4 5 6 7 8  class AD3(Hero): def __init__(self, name, gender): super(AD3, self).__init__(name) self.gender = gender vayne = AD3(\u0026#34;薇恩\u0026#34;, \u0026#34;female\u0026#34;) print(vayne.__dict__)   \u0026gt;\u0026gt;\u0026gt;\n{'name': '薇恩', 'gender': 'female'}\r","description":"","id":123,"section":"python","tags":null,"title":"10. 继承","uri":"https://yorkfish.github.io/review/python/class/10_inheritance/"},{"content":"1. 声明外部变量  一般的做法：将外部变量的定义放在引用它的所有函数之前 类型名可写可不写  写：extern int A, B; 不写：extern A, B;，会有 warning    2. 编译时的顺序  先在文本中找外部变量的定义  如果找到，就在文本文件中扩展作用域 如果找不到，就在连接时从其他文件中找外部变量的定义   若从其他文件中找外部变量的定义  如果从其他文件中找到了，就将作用域扩展到本文件 如果再找不到，就按出错处理    3. 举例 例一   main.c\n1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; extern int count; int main() { printf(\u0026#34;%d\\n\u0026#34;, count); return 0; }     test.c\n1  int count = 100;     编译命令：gcc main.c test.c -o main\n  运行结果：100\n  例二   更改例一的 test.c\n1  static int count = 100;     其他不变\n  编译结果\n undefined reference to `count'\r   解释\n 用 static 声明，只能用于本文件 这种外部变量称为“静态外部变量”    4. 使用  若干个人独立地在其设计的文件中使用相同的外部变量名，若要不受影响，就在每个文件中的外部变量前加上 static 如果其他文件不需要引用本文件的外部变量，可以对本文件中的外部变量都加上 static，成为静态外部变量，以免被其他文件误用  5. 说明   静态存储方式（存放在静态存储区中）\n  动态存储方式（存放在动态存储区中）\n  不要误认为对外部变量加 static 声明后才是静态存储方式，而不加 static 的是动态存储\n 其实加与不加都是静态存储方式 只是作用范围不同而已 都是在编译时分配内存的    ","description":"","id":124,"section":"c","tags":null,"title":"10. extern","uri":"https://yorkfish.github.io/review/c/function/10_extern/"},{"content":"1. 说明  若格式中有两个空格，应对应给到两个或更多的空格 输入数据时，遇到以下情况，认为结束  遇空格、回车、跳格键 超过指定宽度 非法输入    2. 举例 例一 因空格中断输入 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { char str[13]; scanf(\u0026#34;%s\u0026#34;, str); printf(\u0026#34;%s\\n\u0026#34;, str); return 0; }    Input: How are you? Output: How  例二 因设定值中断输入 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { char str[13]; scanf(\u0026#34;%6s\u0026#34;, str); printf(\u0026#34;%s\\n\u0026#34;, str); return 0; }    Input: How_are_you? Output: How_ar  例三 因格式不符导致结果有误 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { int a, b, c; scanf(\u0026#34;%d, %d, %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); printf(\u0026#34;a = %d, b = %d, c = %d\\n\u0026#34;, a, b, c); return 0; }    Input: 1,2,3 Output: a = 1, b = 30, c = 0 Explain: 没有按照 scanf() 中的设定输入，少了空格  ","description":"","id":125,"section":"c","tags":null,"title":"10. scanf","uri":"https://yorkfish.github.io/review/c/basics/10_scanf/"},{"content":"   分类 函数名 功能     打开文件 fopen() 打开文件   关闭文件 fclose() 关闭文件   文件定位 fseek() 改变文件位置指针的位置    rewind() 使文件位置指针重新至于文件开头    ftell() 返回文件位置指针的当前值   文件读写 fgetc(), getc() 从指定文件取得一个字符    fputc(), putc() 把字符输出到指定文件    fgets() 从指定文件读取字符串    fputs() 把字符串输出到指定文件    getw() 从指定文件读取一个字 int    putw() 把一个字 int 输出到指定文件    fread() 从指定文件中读取数据项    fwrite() 把数据项写到指定文件    fscanf() 从指定文件按格式输入数据    fprintf() 按指定格式将数据写到指定文件中   文件状态 feof() 若到文件末尾，函数值为真（非 0）    ferror() 若对文件操作出错，函数值为真    clearerr() 使 ferror 和 feof 函数值置零    ","description":"","id":126,"section":"c","tags":null,"title":"10. 小结","uri":"https://yorkfish.github.io/review/c/file/10_summary/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7 8  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;do 0\u0026#34;, bg=\u0026#34;yellow\u0026#34;) l.pack() window.mainloop()   2. 添加 menubar 1 2 3 4 5  menubar = tk.Menu(window) filemenu = tk.Menu(menubar, tearoff=0) menubar.add_cascade(label=\u0026#34;File\u0026#34;, menu=filemenu, underline=1) filemenu.add_command(label=\u0026#34;New\u0026#34;, command=do_job) window.config(menu=menubar) # 将 window 的 menu 设置为自定义的 menubar   ps  tearoff 默认值为 1  1: 可分 0: 不可分   underline 为 1 的选项，按下 Alt 时，有下划线提示，对应快捷键  3. 添加一个 submenu 1 2 3 4  submenu = tk.Menu(filemenu, tearoff=0) filemenu.add_cascade(label=\u0026#34;Import\u0026#34;, menu=submenu) submenu.add_command(label=\u0026#34;submenu1\u0026#34;, command=do_job) submenu.add_command(label=\u0026#34;submenu2\u0026#34;, command=do_job)   4. 添加一个 separator 1  filemenu.add_separator()   5. 添加一个 quit 1  filemenu.add_command(label=\u0026#34;Exit\u0026#34;, command=window.quit) # window.quit 是 tkinter 自带的   6. do_job 方法  需要写在调用它语句的上方  1 2 3 4 5 6 7 8 9  l = tk.Label(window, text=\u0026#34;do 0\u0026#34;, bg=\u0026#34;yellow\u0026#34;) l.pack() counter = 0 def do_job(): global counter counter += 1 l.config(text=\u0026#34;do \u0026#34; + str(counter))   ps  config 可以改变参数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) l = tk.Label(window, text=\u0026#34;do 0\u0026#34;, bg=\u0026#34;yellow\u0026#34;) l.pack() counter = 0 def do_job(): global counter counter += 1 l.config(text=\u0026#34;do \u0026#34; + str(counter)) menubar = tk.Menu(window) filemenu = tk.Menu(menubar, tearoff=0) # 0: 不可分，1: 可分 menubar.add_cascade(label=\u0026#34;File\u0026#34;, menu=filemenu, underline=1) # menubar 添加 File 栏目 filemenu.add_command(label=\u0026#34;New\u0026#34;, command=do_job) filemenu.add_command(label=\u0026#34;Open\u0026#34;, command=do_job) filemenu.add_command(label=\u0026#34;Save\u0026#34;, command=do_job) filemenu.add_separator() # 分割线 filemenu.add_command(label=\u0026#34;Exit\u0026#34;, command=window.quit) editmenu = tk.Menu(menubar, tearoff=0) menubar.add_cascade(label=\u0026#34;Edit\u0026#34;, menu=editmenu, underline=1) # menubar 添加 Edit 栏目 editmenu.add_command(label=\u0026#34;Cut\u0026#34;, command=do_job) editmenu.add_command(label=\u0026#34;Copy\u0026#34;, command=do_job) editmenu.add_command(label=\u0026#34;Paste\u0026#34;, command=do_job) submenu = tk.Menu(editmenu, tearoff=0) editmenu.add_cascade(label=\u0026#34;Import\u0026#34;, menu=submenu) # Edit 添加 submenu 栏目 submenu.add_command(label=\u0026#34;submenu1\u0026#34;, command=do_job) submenu.add_command(label=\u0026#34;submenu2\u0026#34;, command=do_job) window.config(menu=menubar) window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"菜单","id":127,"section":"python","tags":null,"title":"11. Menu","uri":"https://yorkfish.github.io/review/python/tkinter/11_menu/"},{"content":"例一 平方 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = lambda x: x ** 2 \u0026gt;\u0026gt;\u0026gt; a(3) 9 \u0026gt;\u0026gt;\u0026gt;   例二 最小值 1 2 3 4  \u0026gt;\u0026gt;\u0026gt; b = lambda x, y: x if x \u0026lt; y else y \u0026gt;\u0026gt;\u0026gt; b(66, 88) 66 \u0026gt;\u0026gt;\u0026gt;   例三 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; lst = [lambda x: x.strip(), lambda x: x ** 2] \u0026gt;\u0026gt;\u0026gt; lst [\u0026lt;function \u0026lt;lambda\u0026gt; at 0x00000259206ED5E0\u0026gt;, \u0026lt;function \u0026lt;lambda\u0026gt; at 0x00000259206ED8B0\u0026gt;] \u0026gt;\u0026gt;\u0026gt; lst[0](\u0026#34; YorkFish \u0026#34;) \u0026#39;YorkFish\u0026#39; \u0026gt;\u0026gt;\u0026gt; lst[1](3) 9 \u0026gt;\u0026gt;\u0026gt;   例四 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; def test(): ... return lambda x: x ** 2 ... \u0026gt;\u0026gt;\u0026gt; test() \u0026lt;function test.\u0026lt;locals\u0026gt;.\u0026lt;lambda\u0026gt; at 0x00000259206EDA60\u0026gt; \u0026gt;\u0026gt;\u0026gt; test()(3) 9 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":128,"section":"python","tags":null,"title":"11. lambda","uri":"https://yorkfish.github.io/review/python/basics/11_lambda/"},{"content":"1. 导入 1  import numpy as np   2. 举例 例一 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.arange(4) \u0026gt;\u0026gt;\u0026gt; print(a) [0 1 2 3] \u0026gt;\u0026gt;\u0026gt; a.shape (4,) \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; b = a.reshape((4, 1)) \u0026gt;\u0026gt;\u0026gt; print(b) [[0] [1] [2] [3]] \u0026gt;\u0026gt;\u0026gt; b.shape (4, 1) \u0026gt;\u0026gt;\u0026gt;   例三 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; c = a[:, np.newaxis] \u0026gt;\u0026gt;\u0026gt; print(c) [[0] [1] [2] [3]] \u0026gt;\u0026gt;\u0026gt; c.shape (4, 1) \u0026gt;\u0026gt;\u0026gt;   例四 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; d = a[np.newaxis, ] \u0026gt;\u0026gt;\u0026gt; print(d) [[0 1 2 3]] \u0026gt;\u0026gt;\u0026gt; d.shape (1, 4) \u0026gt;\u0026gt;\u0026gt;   例五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  \u0026gt;\u0026gt;\u0026gt; e = a.reshape((2, 2)) \u0026gt;\u0026gt;\u0026gt; print(e) [[0 1] [2 3]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(e[np.newaxis, ]) [[[0 1] [2 3]]] \u0026gt;\u0026gt;\u0026gt; e[np.newaxis, ].shape (1, 2, 2) \u0026gt;\u0026gt;\u0026gt; # [] 内有 1 个二维数据，每个二维数据内有 2 个一维数据，每个一维数据内有 2 个数据 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(e[:, np.newaxis]) [[[0 1]] [[2 3]]] \u0026gt;\u0026gt;\u0026gt; e[:, np.newaxis].shape (2, 1, 2) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(e[:, :, np.newaxis]) [[[0] [1]] [[2] [3]]] \u0026gt;\u0026gt;\u0026gt; e[:, :, np.newaxis].shape (2, 2, 1) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(e[:, :, None]) [[[0] [1]] [[2] [3]]] \u0026gt;\u0026gt;\u0026gt; e[:, :, None].shape (2, 2, 1) \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":129,"section":"python","tags":null,"title":"11. newaxis","uri":"https://yorkfish.github.io/review/python/numpy/11_newaxis/"},{"content":"1. getchar() 说明  字符输入函数 从终端或系统隐含指定的输入设备，输入一个字符  举例 1 2 3 4 5 6 7 8 9  #include \u0026lt;stdio.h\u0026gt; int main() { char c; c = getchar(); printf(\u0026#34;%c\\n\u0026#34;, c); return 0; }    Input: y Output: y  2. putchar() 说明  字符输出函数 向终端输出一个字符  举例 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { char s1 = \u0026#39;A\u0026#39;; putchar(s1); putchar(\u0026#39;B\u0026#39;); putchar(\u0026#39;\\103\u0026#39;); putchar(68); putchar(\u0026#39;\\n\u0026#39;); return 0; }     运行结果\nABCD\r  ","description":"","id":130,"section":"c","tags":null,"title":"11. getchar() \u0026 putchar()","uri":"https://yorkfish.github.io/review/c/basics/11_getchar_and_putchar/"},{"content":"1. 简介 组成  一个函数一般由两部分组成  声明部分 执行语句    声明与定义   函数的声明是函数的原型\n  函数的定义是函数的本身\n  int a; 既是声明，也是定义\n  extern a; 是声明，但不是定义\n  int a;\nstatic a; // 这样会被认为是重新定义\r 2. static 声明变量的作用  局部变量用 static 声明，则使该变量在整个程序执行期间不释放，为其分配的空间始终存在 全局变量用 static 声明，则该变量的作用域只限于本文件模块（即被声明的文件中）  3. 小结   对一个数据的定义，需要指定两种属性\n 数据类型 存储类别    使用两个关键字，如\n auto char c; static int a; register int d;    用 extern 声明变量为已定义的外部变量\n extern b; —— 声明 b 是一个已被定义的外部变量    ","description":"","id":131,"section":"c","tags":null,"title":"11. 变量的声明与定义","uri":"https://yorkfish.github.io/review/c/function/11_declaration_and_definition/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. 定义主 frame 1 2  frm = tk.Frame(window) frm.pack()   3. 定义左 frame 1 2  frm_l = tk.Frame(frm) frm_l.pack(side=\u0026#34;left\u0026#34;)    frm_r 同理  4. 在左 frame 上添加 label 1  tk.Label(frm_l, text=\u0026#34;on the frm_l1\u0026#34;).pack()    frm_r 同理  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) tk.Label(window, text=\u0026#34;on the window\u0026#34;).pack() frm = tk.Frame(window) frm.pack() frm_l = tk.Frame(frm) frm_r = tk.Frame(frm) frm_l.pack(side=\u0026#34;left\u0026#34;) frm_r.pack(side=\u0026#34;right\u0026#34;) tk.Label(frm_l, text=\u0026#34;on the frm_l1\u0026#34;).pack() tk.Label(frm_l, text=\u0026#34;on the frm_l2\u0026#34;).pack() tk.Label(frm_r, text=\u0026#34;on the frm_r1\u0026#34;).pack() window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"框架","id":132,"section":"python","tags":null,"title":"12. Frame","uri":"https://yorkfish.github.io/review/python/tkinter/12_frame/"},{"content":"1. copy \u0026amp; deepcopy 例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; b = a \u0026gt;\u0026gt;\u0026gt; id(a) 2581819681792 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819681792 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a[1] = 22 \u0026gt;\u0026gt;\u0026gt; id(a) 2581819681792 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819681792 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = [4, 5, 6] \u0026gt;\u0026gt;\u0026gt; id(a) 2581819678848 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819681792 \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt; b = a.copy() \u0026gt;\u0026gt;\u0026gt; id(a) 2581819650560 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819700352 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a[1] = 22 \u0026gt;\u0026gt;\u0026gt; id(a) 2581819650560 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819700352 \u0026gt;\u0026gt;\u0026gt; a [1, 22, 3, [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a[3].append(7) # 第二层是浅拷贝 \u0026gt;\u0026gt;\u0026gt; id(a) 2581819650560 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819700352 \u0026gt;\u0026gt;\u0026gt; a [1, 22, 3, [4, 5, 6, 7]] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, [4, 5, 6, 7]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; id(a[3]) 2581819653056 \u0026gt;\u0026gt;\u0026gt; id(b[3]) 2581819653056 \u0026gt;\u0026gt;\u0026gt;   例三 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026gt;\u0026gt;\u0026gt; from copy import deepcopy \u0026gt;\u0026gt;\u0026gt; a = [1, 2, 3, [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt; b = deepcopy(a) \u0026gt;\u0026gt;\u0026gt; id(a) 2581819729408 \u0026gt;\u0026gt;\u0026gt; id(b) 2581819741760 \u0026gt;\u0026gt;\u0026gt; a[3].append(7) \u0026gt;\u0026gt;\u0026gt; a [1, 2, 3, [4, 5, 6, 7]] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, [4, 5, 6]] \u0026gt;\u0026gt;\u0026gt;   2. slice 例四 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; lst = list(range(10)) \u0026gt;\u0026gt;\u0026gt; lst [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt; lst[:-2:] [0, 1, 2, 3, 4, 5, 6, 7] \u0026gt;\u0026gt;\u0026gt; lst[:-2] [0, 1, 2, 3, 4, 5, 6, 7] \u0026gt;\u0026gt;\u0026gt; lst[-1:-7] [] \u0026gt;\u0026gt;\u0026gt; lst[-1:-7:-1] [9, 8, 7, 6, 5, 4] \u0026gt;\u0026gt;\u0026gt; lst[-3:-15:-1] [7, 6, 5, 4, 3, 2, 1, 0] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":133,"section":"python","tags":null,"title":"12. list","uri":"https://yorkfish.github.io/review/python/basics/12_list/"},{"content":"1. 简介  此 stack() 非彼 stack stack()  对每一个数组在 axis=0 上添加一维 把它们沿着这个新的维度串起来    2. 操作 导入 1  import numpy as np   例一 创建  沿着新的维度串起来  1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2]) \u0026gt;\u0026gt;\u0026gt; b = np.array([3, 4]) \u0026gt;\u0026gt;\u0026gt; c = np.array([5, 6]) \u0026gt;\u0026gt;\u0026gt; a.shape # a, b, c 都是 (2,) 的一维数组 (2,) \u0026gt;\u0026gt;\u0026gt;   堆叠 1 2 3 4 5 6  \u0026gt;\u0026gt;\u0026gt; d = np.stack((a, b, c)) \u0026gt;\u0026gt;\u0026gt; print(d) [[1 2] [3 4] [5 6]] \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2])[np.newaxis] \u0026gt;\u0026gt;\u0026gt; b = np.array([3, 4])[np.newaxis] \u0026gt;\u0026gt;\u0026gt; c = np.array([5, 6])[np.newaxis] \u0026gt;\u0026gt;\u0026gt; d = np.concatenate((a, b, c), axis=0) \u0026gt;\u0026gt;\u0026gt; print(a) [[1 2]] \u0026gt;\u0026gt;\u0026gt; print(d) [[1 2] [3 4] [5 6]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":134,"section":"python","tags":null,"title":"12. stack()","uri":"https://yorkfish.github.io/review/python/numpy/12_stack/"},{"content":"1. gets(字符数组) 说明  只针对一个字符串 从终端输入一个字符串到字符数组，并得到一个函数值 该函数值是字符数组的起始地址  举例 1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt; int main() { char str[80]; int num; printf(\u0026#34;please input a string: \u0026#34;); num = gets(str); printf(\u0026#34;\u0026gt;\u0026gt;\u0026gt; str: %s\\n\u0026#34;, str); printf(\u0026#34;\u0026gt;\u0026gt;\u0026gt; num: %d\\n\u0026#34;, num); return 0; }     运行结果\nplease input a string: york fish\r\u0026gt;\u0026gt;\u0026gt; str: york fish\r\u0026gt;\u0026gt;\u0026gt; num: 6422140\r  2. puts(字符数组) 说明  只针对一个字符串 将一个字符串（以 '\\0' 结束的字符序列）输出到终端 因为有 printf()，所以 puts() 用到不多 用 puts() 输出的字符串中可以包含转义字符 可以在输出时将字符串结束标志 '\\0' 转换成 '\\n'，即输出完字符串后换行  举例 1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { puts(\u0026#34;hello world\u0026#34;); puts(\u0026#34;york\\nfish\u0026#34;); return 0; }     运行结果\nhello world\ryork\rfish\r  ","description":"","id":135,"section":"c","tags":null,"title":"12. gets() \u0026 puts()","uri":"https://yorkfish.github.io/review/c/basics/12_gets_and_puts/"},{"content":"1. 内部函数   如果一个函数只能被本文件中其他函数所调用，它称为内部函数\n  在定义内部函数时，在函数名和函数类型的前面加 static，即\n static 类型标识符 函数名(形参表); static int fun(int a, int b);    内部函数又称静态函数\n  在不同的文件中有同名的内部函数，互不干扰\n  2. 外部函数   形如 extern int fun(int a, int b);\n  C 语言规定，如果在定义函数时省略 extern，则隐含为外部函数\n  用 extern 对函数作声明，表示该函数是其他文件中定义的外部函数\n  函数在本质上是外部的，在程序中经常要调用外部函数\n 为方便编程，C 语言允许在声明函数时省写 extern 一般也都是省写    3. 例外  如，三角函数 三角函数不是由用户在本文件中定义的，而是存放在数学函数库中的 在本文件中使用（如 sin 函数），必须写出函数的原型（如 double sin(double x);）  例一 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt; #define PI 3.14159265  double sin(double x); // sin() 函数的参数是弧度  int main() { printf(\u0026#34;%lf\\n\u0026#34;, sin(30.0 * PI/180)); // 0.500000  return 0; }    程序设计者在调用库函数时，需要先从手册中查出所用的库函数的原型 不过可以简化，如，使用头文件 math.h  例二 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;math.h\u0026gt; #define PI 3.14159265  int main() { printf(\u0026#34;%lf\\n\u0026#34;, sin(30.0 * PI/180)); return 0; }   ","description":"","id":136,"section":"c","tags":null,"title":"12. 内部函数和外部函数","uri":"https://yorkfish.github.io/review/c/function/12_internal_and_external_functions/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6 7  import tkinter as tk import tkinter.messagebox # messagebox 需要另外导入 window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. 添加一个 button 并关联弹窗 1 2 3 4 5  def hit_me(): tk.messagebox.showinfo(title=\u0026#34;showinfo\u0026#34;, message=\u0026#34;This is showinfo.\u0026#34;) tk.Button(window, text=\u0026#34;hit me\u0026#34;, command=hit_me).pack()   \u0026gt;\u0026gt;\u0026gt;\n ps: 有声音，与更改文件后缀的提示音一样  3. 其他弹窗 showwarning 1  tk.messagebox.showwarning(title=\u0026#34;showwarning\u0026#34;, message=\u0026#34;This is showwarning.\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\n ps: 有声音，与更改文件后缀的提示音一样  showerror 1  tk.messagebox.showerror(title=\u0026#34;showerror\u0026#34;, message=\u0026#34;This is showerror.\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\n ps: 有声音，与 U 盘弹出失败的提示音一样  askquestion 1  print(tk.messagebox.askquestion(title=\u0026#34;askquestion\u0026#34;, message=\u0026#34;yes or no?\u0026#34;))   \u0026gt;\u0026gt;\u0026gt;\n ps  是(Y)：return \u0026ldquo;yes\u0026rdquo; 否(N)：return \u0026ldquo;no\u0026rdquo;    askyesno 1  print(tk.messagebox.askyesno(title=\u0026#34;askyesno\u0026#34;, message=\u0026#34;yes or no\u0026#34;))   \u0026gt;\u0026gt;\u0026gt;\n ps  是(Y)：return True 否(N)：return False    askretrycancel 1  print(tk.messagebox.askretrycancel(title=\u0026#34;askretrycancel\u0026#34;, message=\u0026#34;yes or no\u0026#34;))   \u0026gt;\u0026gt;\u0026gt;\n ps  有声音，与更改文件后缀的提示音一样 重试(R)：return True 取消：return False 右上角的叉：return False    askokcancel 1  print(tk.messagebox.askokcancel(title=\u0026#34;askokcancel\u0026#34;, message=\u0026#34;yes or no\u0026#34;))   \u0026gt;\u0026gt;\u0026gt;\n ps  确定：return True 取消：return False 右上角的叉：return False    ","description":"弹窗","id":137,"section":"python","tags":null,"title":"13. Massagebox","uri":"https://yorkfish.github.io/review/python/tkinter/13_massagebox/"},{"content":"1. 导入 1  import numpy as np   colstack 例一 1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; b = np.array([4, 5, 6]) \u0026gt;\u0026gt;\u0026gt; c = np.column_stack((a, b)) \u0026gt;\u0026gt;\u0026gt; print(c) [[1 4] [2 5] [3 6]] \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7  \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; b = np.array([[9, 8, 7], [6, 5, 4]]) \u0026gt;\u0026gt;\u0026gt; c = np.column_stack((a, b)) \u0026gt;\u0026gt;\u0026gt; print(c) [[1 2 3 9 8 7] [4 5 6 6 5 4]] \u0026gt;\u0026gt;\u0026gt;   rowstack 例三 1 2 3 4 5 6 7 8 9  \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; b = np.array([[9, 8, 7], [6, 5, 4]]) \u0026gt;\u0026gt;\u0026gt; c = np.row_stack((a, b)) \u0026gt;\u0026gt;\u0026gt; print(c) [[1 2 3] [4 5 6] [9 8 7] [6 5 4]] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":138,"section":"python","tags":null,"title":"13. colstack \u0026 rowstack","uri":"https://yorkfish.github.io/review/python/numpy/13_colstack_and_rowstack/"},{"content":"1. 举例 例一 加数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 1 \u0026gt;\u0026gt;\u0026gt; id(a) 140724528887584 \u0026gt;\u0026gt;\u0026gt; a += b \u0026gt;\u0026gt;\u0026gt; id(a) 140724528887616 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 1 \u0026gt;\u0026gt;\u0026gt; id(a) 140724528887584 \u0026gt;\u0026gt;\u0026gt; a = a + b \u0026gt;\u0026gt;\u0026gt; id(a) 140724528887616 \u0026gt;\u0026gt;\u0026gt;   ps  数字的相加，a += b 与 a = a + b 等价 a 的新老 id 相差 32，即 1 与 2 的 id 相差 32  如果再定义一个 3，2 与 3 的 id 也会相差 32 不过数字大了，就没这个规律了    例二 “加列表” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026gt;\u0026gt;\u0026gt; a = [1, 2] \u0026gt;\u0026gt;\u0026gt; b = [3, 4] \u0026gt;\u0026gt;\u0026gt; id(a) 2581819664704 \u0026gt;\u0026gt;\u0026gt; a += b \u0026gt;\u0026gt;\u0026gt; id(a) 2581819664704 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = [1, 2] \u0026gt;\u0026gt;\u0026gt; b = [3, 4] \u0026gt;\u0026gt;\u0026gt; id(a) 2581819665152 \u0026gt;\u0026gt;\u0026gt; a = a + b \u0026gt;\u0026gt;\u0026gt; id(a) 2581819752512 \u0026gt;\u0026gt;\u0026gt;   ps  列表的相加，a += b 与 a = a + b 等价  例三 “加元组” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026gt;\u0026gt;\u0026gt; a = [1, 2] \u0026gt;\u0026gt;\u0026gt; b = (3, 4) \u0026gt;\u0026gt;\u0026gt; id(a) 2581819687104 \u0026gt;\u0026gt;\u0026gt; a += b \u0026gt;\u0026gt;\u0026gt; id(a) 2581819687104 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; try: ... a = a + b ... except TypeError as e: ... print(e) ... can only concatenate list (not \u0026#34;tuple\u0026#34;) to list \u0026gt;\u0026gt;\u0026gt;   ps  列表是不能加元组的 上面的列表 += 元组，实际上是调用了 extend 方法  2. 结论   有两个魔法方法\n __iadd__() __add__()    可变对象，如 list, set 等，两个方法都有\n  不可变对象，如 tuple, int 等，只有 __add__()\n  += 优先调用 __iadd__()，若没有，再调用 __add__()\n  __iadd__() 是由 extend 实现的\n1 2 3  def __iadd__(self, values): self.extend(values) return self     ","description":"","id":139,"section":"python","tags":null,"title":"13. plus","uri":"https://yorkfish.github.io/review/python/basics/13_plus/"},{"content":"strcat(字符数组1, 字符数组2) 简介  string catenate 把“字符串2”接到“字符串1”的后面  使用 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[] = \u0026#34;abcde\u0026#34;; char str2[] = \u0026#34;123\u0026#34;; strcpy(str1, str2); printf(\u0026#34;%s\\n\u0026#34;, str1); // abcde123  return 0; }   ","description":"","id":140,"section":"c","tags":null,"title":"13. strcat()","uri":"https://yorkfish.github.io/review/c/basics/13_strcat/"},{"content":"1. 准备一个简易窗口 1 2 3 4 5 6  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) window.mainloop()   2. pack 1  tk.Label(window, text=1).pack(side=\u0026#34;top\u0026#34;)    ps: 除了 top，还有 bottom, left, right  3. grid  简单地说，就是按照格子摆放  1 2 3  for i in range(3): for j in range(4): tk.Label(window, text=1).grid(row=i, column=j)   ps  pad 参数（向外展开）\ntk.Label(window, text=1).grid(row=i, column=j, padx=10, pady=10) ipad 参数（内部扩展）  tk.Label(window, text=1).grid(row=i, column=j, ipadx=10, ipady=10)    4. place  精确到具体的像素点摆放  1  tk.Label(window, text=1).place(x=10, y=100)   ps   anchor 参数与 tkinter.Canvas 的一致\nNR N NE\rW CENTER E\rSW S SE\r  1 2 3 4 5 6 7 8 9 10 11 12  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) tk.Label(window, text=1).pack(side=\u0026#34;top\u0026#34;) tk.Label(window, text=1).pack(side=\u0026#34;bottom\u0026#34;) tk.Label(window, text=1).pack(side=\u0026#34;left\u0026#34;) tk.Label(window, text=1).pack(side=\u0026#34;right\u0026#34;) window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) for i in range(3): for j in range(4): tk.Label(window, text=1).grid(row=i, column=j, ipadx=10, ipady=10) window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n1 2 3 4 5 6 7 8 9  import tkinter as tk window = tk.Tk() window.title(\u0026#34;YorkFish\u0026#34;) window.geometry(\u0026#34;300x200\u0026#34;) tk.Label(window, text=1).place(x=150, y=100) window.mainloop()   \u0026gt;\u0026gt;\u0026gt;\n","description":"摆放位置","id":141,"section":"python","tags":null,"title":"14. pack \u0026 grid \u0026 place","uri":"https://yorkfish.github.io/review/python/tkinter/14_pack_grid_place/"},{"content":"1. set 间的运算 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;\u0026gt;\u0026gt; a = {1, 2, 3} \u0026gt;\u0026gt;\u0026gt; b = {2, 3, 4} \u0026gt;\u0026gt;\u0026gt; a \u0026amp; b # intersection {2, 3} \u0026gt;\u0026gt;\u0026gt; a | b # union set {1, 2, 3, 4} \u0026gt;\u0026gt;\u0026gt; a - b {1} \u0026gt;\u0026gt;\u0026gt; a ^ b # difference set {1, 4} \u0026gt;\u0026gt;\u0026gt;   2. list 借助 set 解决问题 1 2 3 4 5 6 7 8 9 10 11 12  \u0026gt;\u0026gt;\u0026gt; lst1 = [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] \u0026gt;\u0026gt;\u0026gt; lst2 = list(set(lst1)) \u0026gt;\u0026gt;\u0026gt; lst2 [\u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; sorted(list(set(lst1)), key=lambda x: lst1.index(x)) [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; lst2.sort(key=lst1.index) \u0026gt;\u0026gt;\u0026gt; lst2 [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":142,"section":"python","tags":null,"title":"14. set","uri":"https://yorkfish.github.io/review/python/basics/14_set/"},{"content":"1. strcpy(字符数组1, 字符串2) 简介  string copy 字符串赋值函数 将“字符串2”复制到“字符数组1”中去  注意事项   “字符数组1”必须定义得足够大，以便容纳被复制的字符串\n  “字符数组1”必须写成数组名形式，“字符串2”可以是字符数组名，也可以是字符串常量\n  复制时，“字符串2”连带它末尾的 '\\0' 一并复制\n  不能用赋值语句将一个字符串常量或字符数组直接给一个字符数组，如\n1 2 3  char str1[10], str2[10]; str1 = \u0026#34;China\u0026#34;; str2 = str1; // error!     使用 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[] = \u0026#34;abcde\u0026#34;; char str2[] = \u0026#34;123\u0026#34;; strcpy(str1, str2); printf(\u0026#34;%s\\n\u0026#34;, str1); // 123  return 0; }   2. strncpy(str1, str2, n) 简介  将 str2 中前 n 个字符复制到 str1 中去 strncpy(str1, str2, 2)  将 str2 中最前面 2 个字符复制到 str1 中，取代 str1 中原有的最前面的 2 个字符    注意事项  复制的字符个数 n 不应多于 str1 中原有的字符（不包括 '\\0'）  使用 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[10] = \u0026#34;abcde\u0026#34;; char str2[10] = \u0026#34;12345\u0026#34;; strncpy(str1, str2, 3); printf(\u0026#34;%s\\n\u0026#34;, str1); // 123de  return 0; }   ","description":"","id":143,"section":"c","tags":null,"title":"14. strcpy() \u0026 strncpy()","uri":"https://yorkfish.github.io/review/c/basics/14_strcpy_and_strncpy/"},{"content":"例一  C 的话有溢出风险，Python 就不用担心了  1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 2 \u0026gt;\u0026gt;\u0026gt; a = a + b \u0026gt;\u0026gt;\u0026gt; b = a - b \u0026gt;\u0026gt;\u0026gt; a = a - b \u0026gt;\u0026gt;\u0026gt; a 2 \u0026gt;\u0026gt;\u0026gt; b 1 \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 2 \u0026gt;\u0026gt;\u0026gt; a = a ^ b \u0026gt;\u0026gt;\u0026gt; b = a ^ b \u0026gt;\u0026gt;\u0026gt; a = a ^ b \u0026gt;\u0026gt;\u0026gt; a 2 \u0026gt;\u0026gt;\u0026gt; b 1 \u0026gt;\u0026gt;\u0026gt;   例三  golang 等别的语言也有这种方法  1 2 3 4 5 6 7 8  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = 2 \u0026gt;\u0026gt;\u0026gt; a, b = b, a \u0026gt;\u0026gt;\u0026gt; a 2 \u0026gt;\u0026gt;\u0026gt; b 1 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":144,"section":"python","tags":null,"title":"15. swap","uri":"https://yorkfish.github.io/review/python/basics/15_swap/"},{"content":"strcmp(字符串1, 字符串2) 简介  string compare 比较“字符串1”与“字符串2”  比较规则  若出现不同字符，以第一个不相同的字符的比较结果为准 str1 == str2 返回 0 str1 \u0026gt; str2 返回某正整数 str1 \u0026lt; str2 返回某负整数  使用 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;york\u0026#34;, \u0026#34;york\u0026#34;)); // 0  printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;york\u0026#34;, \u0026#34;fish\u0026#34;)); // 1  printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;fish\u0026#34;, \u0026#34;york\u0026#34;)); // -1  printf(\u0026#34;%d\\n\u0026#34;, strcmp(\u0026#34;york\u0026#34;, \u0026#34;yorkfish\u0026#34;)); // -1  return 0; }   ","description":"","id":145,"section":"c","tags":null,"title":"15. strcmp()","uri":"https://yorkfish.github.io/review/c/basics/15_strcmp/"},{"content":"1. 说明  若参数为不可变对象，如 int, str, tuple 等，采用的是“值传递”，相当于用形参接收参数，不影响原值 若参数为可变对象，如 list, dict 等，采用的是“引用传递”，相当于用指针接收参数，影响原值  2. 举例 例一 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def test(num): ... num += 1 ... return num ... \u0026gt;\u0026gt;\u0026gt; num = 10 \u0026gt;\u0026gt;\u0026gt; test(num) 11 \u0026gt;\u0026gt;\u0026gt; num 10 \u0026gt;\u0026gt;\u0026gt;   例二 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; def test(lst): ... lst[0] += 1 ... return lst ... \u0026gt;\u0026gt;\u0026gt; alist = [10, 20, 30] \u0026gt;\u0026gt;\u0026gt; test(alist) [11, 20, 30] \u0026gt;\u0026gt;\u0026gt; alist [11, 20, 30] \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":146,"section":"python","tags":null,"title":"16. transmit","uri":"https://yorkfish.github.io/review/python/basics/16_transmit/"},{"content":"strlen(字符数组) 简介  string length 测试字符串长度  注意事项  函数的值位字符串的实际长度，不包括 '\\0'  使用 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str1[] = \u0026#34;york\u0026#34;; char str2[10] = \u0026#34;fish\u0026#34;; printf(\u0026#34;%d\\n\u0026#34;, strlen(str1)); // 4  printf(\u0026#34;%d\\n\u0026#34;, sizeof(str1)); // 5  printf(\u0026#34;%d\\n\u0026#34;, strlen(str2)); // 4  printf(\u0026#34;%d\\n\u0026#34;, sizeof(str2)); // 10  return 0; }   ","description":"","id":147,"section":"c","tags":null,"title":"16. strlen()","uri":"https://yorkfish.github.io/review/c/basics/16_strlen/"},{"content":"例一 有点像 switch-case 1 2 3 4 5 6 7 8 9 10  try: a = b except ArithmeticError: print(\u0026#34;ArithmeticError!\u0026#34;) except KeyError: print(\u0026#34;KeyError!\u0026#34;) except TypeError: print(\u0026#34;TypeError!\u0026#34;) except Exception: print(\u0026#34;Some error!\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\nSome error!\r例二 1 2 3 4  try: a = b except Exception as e: print(e)   \u0026gt;\u0026gt;\u0026gt;\nname 'b' is not defined\r例三 1 2 3 4 5 6  try: a = b except NameError: print(\u0026#34;NameError!\u0026#34;) finally: print(\u0026#34;You must enter into finally!\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\nNameError!\rYou must enter into finally!\r例四 1 2 3 4 5 6 7 8  try: a = 1 except NameError: print(\u0026#34;NameError!\u0026#34;) else: print(\u0026#34;No error!\u0026#34;) finally: print(\u0026#34;You must enter into finally!\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\nNo error!\rYou must enter into finally!\r","description":"","id":148,"section":"python","tags":null,"title":"17. try-except-else-finally","uri":"https://yorkfish.github.io/review/python/basics/17_try-except-else-finally/"},{"content":"1. strlwr(字符串)  string lowercase 将字符串中的大写字母换成小写字母  2. strupr(字符车)  string uppercase 将字符串中的小写字母换成大写字母  3. 使用 1 2 3 4 5 6 7 8 9 10  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;YorkFish\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, strlwr(str)); // yorkfish  printf(\u0026#34;%s\\n\u0026#34;, strupr(str)); // YORKFISH  return 0; }   ","description":"","id":149,"section":"c","tags":null,"title":"17. strlwr() \u0026 strupr()","uri":"https://yorkfish.github.io/review/c/basics/17_strlwr_and_strupr/"},{"content":"情形一 说明  后置单下划线 撞了关键字，但又懒得想变量名  举例 1  class_ = \u0026#34;101\u0026#34;    tkinter.Scale() 的 from_ 参数  情形二 说明  下划线作占位符 少起一个名字  举例 1  a = [[1, 2, 3] for _ in range(10)]   情形三 说明  下划线作占位符 解包时对应用不到的数据  举例 1 2  nums = [1, 2, 3, 4] n1, _, _, n4 = nums   情形四 说明  下划线作分割符 方便数字多的时候看 “格式化”指定下划线为填充物时  十进制默认隔 3 位 其他进制默认隔 4 位    举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026gt;\u0026gt;\u0026gt; num = 1_000_000 \u0026gt;\u0026gt;\u0026gt; num 1000000 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; num = 0xFF_FF \u0026gt;\u0026gt;\u0026gt; num 65535 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; num = 1000000 \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:_}\u0026#34; \u0026#39;1_000_000\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:_b}\u0026#34; \u0026#39;1111_0100_0010_0100_0000\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:_o}\u0026#34; \u0026#39;364_1100\u0026#39; \u0026gt;\u0026gt;\u0026gt; f\u0026#34;{num:_x}\u0026#34; \u0026#39;f_4240\u0026#39; \u0026gt;\u0026gt;\u0026gt;   情形五 说明  前置单下划线 Python 中没有对 public 和 private 进行严格的定义 为了区分，社区的程序员达成了一个约定 当看到以下划线开头的变量或方法时，最好只在内部使用  举例 1 2 3 4  class Hero(object): def __init__(self, name, chinesename): self.name = name self._chinesename = chinesename   情形六 说明  前置双下划线 使属性变量私有，不被派生类去继承 避免了派生类和父类属性名称的冲突  举例 1 2 3 4 5 6 7 8 9 10 11 12 13  class Hero(object): def __init__(self, name, chinesename): self.name = name self.__chinesename = chinesename garen = Hero(\u0026#34;garen\u0026#34;, \u0026#34;盖伦\u0026#34;) try: print(garen.__chinesename) except AttributeError as e: print(e) finally: print(garen._Hero__chinesename)   \u0026gt;\u0026gt;\u0026gt;\n'Hero' object has no attribute '__chinesename'\r盖伦\r情形七 说明  前置双下划线 如果类内的方法也加上了前置双下划线，那么它也无法在外部用实例.方法名访问  举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Hero(object): def __init__(self, name, chinesename): self.name = name self.__chinesename = chinesename def __flash(self): print(\u0026#34;F!\u0026#34;) garen = Hero(\u0026#34;garen\u0026#34;, \u0026#34;盖伦\u0026#34;) try: garen.__flash() except AttributeError as e: print(e) finally: garen._Hero__flash()   \u0026gt;\u0026gt;\u0026gt;\n'Hero' object has no attribute '__flash'\rF!\r情形八 说明  在交互模式下，自动保存上一个值  举例 1 2 3 4 5 6 7 8 9 10  \u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; _ Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; NameError: name \u0026#39;_\u0026#39; is not defined \u0026gt;\u0026gt;\u0026gt; a 1 \u0026gt;\u0026gt;\u0026gt; _ 1 \u0026gt;\u0026gt;\u0026gt;   ","description":"","id":150,"section":"python","tags":null,"title":"18. underscore","uri":"https://yorkfish.github.io/review/python/basics/18_underscroe/"},{"content":"1. 全局变量 例一 1 2 3 4 5 6 7 8 9  def test(): global num num = 2 print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; num =\u0026#34;, num) num = 1 test() print(\u0026#34;\u0026lt;\u0026lt;\u0026lt; num =\u0026#34;, num)   \u0026gt;\u0026gt;\u0026gt;\n\u0026gt;\u0026gt;\u0026gt; num = 2\r\u0026lt;\u0026lt;\u0026lt; num = 2\r例二 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def test(): num = 1 def inside(): global num num *= 2 print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; num =\u0026#34;, num) print(\u0026#34;before use inside():\u0026#34;, num) inside() print(\u0026#34; after use inside():\u0026#34;, num) num = 1 test() print(\u0026#34;\u0026lt;\u0026lt;\u0026lt; num =\u0026#34;, num)   \u0026gt;\u0026gt;\u0026gt;\nbefore use inside(): 1\r\u0026gt;\u0026gt;\u0026gt; num = 2\rafter use inside(): 1\r\u0026lt;\u0026lt;\u0026lt; num = 2\r2. 局部变量 例三 1 2 3 4 5 6 7 8 9 10 11  def test(): num = 1 def inside(): nonlocal num num *= 2 print(\u0026#34;before use inside():\u0026#34;, num) inside() print(\u0026#34; after use inside():\u0026#34;, num) test()   \u0026gt;\u0026gt;\u0026gt;\nbefore use inside(): 1\rafter use inside(): 2\r3. 不可变对象  常见的不可变对象：str, int, float, complex, tuple, bool  i = 5 | i += 2\r--------------------\ri -\u0026gt; 5 | i -- 5 -\u0026gt; Garbage collection\r| \\\r| --\u0026gt; 7\rps  一开始，i 指向存储 5 的那片空间 运算后，新增了一片存储 7 的空间，i 改变指向，指向存储 7 的那片空间 存储 5 的那片空间，如果没有“人”去使用，就会被回收  4. 可变对象  常见的可变对象：list, dict, set  1 2  lst = [0, 1, 2, 3] lst[0] = 10   ps  lst[0] = 10  先找到 lst[0] 的地址 再把这片地址上的数据修改为 10（整个过程没有创建新的对象）    ","description":"","id":151,"section":"python","tags":null,"title":"19. variable","uri":"https://yorkfish.github.io/review/python/basics/19_variable/"},{"content":"1. 说明  属于 generator 二叉树中就会用到 有速度优势  2. 举例 公共部分 1 2 3 4 5 6  def fib(num): n, a, b = 0, 0, 1 while n \u0026lt; num: yield b # 相当于挂起；可以看成一种不退出的 return a, b = b, a+b n += 1   例一 1 2 3  y1 = fib(10) for i in y1: print(i)   \u0026gt;\u0026gt;\u0026gt;\n1\r1\r2\r3\r5\r8\r13\r21\r34\r55\r例二 1 2 3 4 5 6 7 8 9  # \u0026lt; 3.8 y2 = fib(10) try: n = next(y2) while n: print(n) n = next(y2) except StopIteration: print(\u0026#34;over\u0026#34;)   \u0026gt;\u0026gt;\u0026gt;\n1\r1\r2\r3\r5\r8\r13\r21\r34\r55\rover\r例三 yield 起来的数据会随着遍厉一一清除 1 2 3 4 5 6 7 8 9  # \u0026gt;= 3.8 y3 = fib(10) try: while n := next(y3): print(n) except StopIteration: print(\u0026#34;over\u0026#34;) for i in y3: # 不会进入循环 print(i)   \u0026gt;\u0026gt;\u0026gt;\n1\r1\r2\r3\r5\r8\r13\r21\r34\r55\rover\r","description":"","id":152,"section":"python","tags":null,"title":"20. yield","uri":"https://yorkfish.github.io/review/python/basics/20_yield/"},{"content":"有两种方式\n图片存放地址  图片需要放在博客根目录的 static 文件夹下 我在 root/static 下 新建了 imgs 文件夹，以后有图片就在里面建相应的文件夹，并放入  使用方法  图片路径：root/static/imgs/python/numpy/plt.png  方式一 ![test](/imgs/python/numpy/plt.png \u0026quot;plt\u0026quot;)\r或\r![](/imgs/python/numpy/plt.png)\r方式二 {{\u0026lt; img src=\u0026quot;/imgs/python/numpy/plt.png\u0026quot; title=\u0026quot;test\u0026quot; caption=\u0026quot;Hugo-zdoc add image\u0026quot; alt=\u0026quot;plt\u0026quot; width=\u0026quot;500px\u0026quot; height=\u0026quot;500px\u0026quot; position=\u0026quot;center\u0026quot; \u0026gt;}}\r或\r{{\u0026lt; img src=\u0026quot;/imgs/python/numpy/plt.png\u0026quot; \u0026gt;}}\r","description":"","id":153,"section":"blog","tags":["zdoc"],"title":"Hugo-zdoc 添加图片","uri":"https://yorkfish.github.io/review/blog/05_zdoc_add_image/"},{"content":"摘要  分屏 调整分屏大小 光标移动 全屏 翻页 字体大小  1. 分屏    快捷键 功能     Alt + Shift + + 横向分屏   Alt + Shift + - 竖向分屏   Ctrl + Shift + t 打开新标签页   Ctrl + Shift + w 取消分屏/关闭当前标签页    2. 调整分屏大小    快捷键 功能     Alt + Shift + 方向键 调整当前分屏区大小    3. 光标移动    快捷键 功能     Alt + 方向键 分屏间移动光标    4. 全屏    快捷键 功能      F11 全屏切换    5. 翻页    快捷键 功能     Ctrl + Shift + PgUp/PgDn 上/下翻页    6. 字体大小    快捷键 功能     Ctrl + 鼠标滚轮 调整窗口显示大小   ","description":"","id":154,"section":"blog","tags":["terminal"],"title":"Windows Terminal","uri":"https://yorkfish.github.io/review/blog/04_windows_terminal/"},{"content":"摘要  记事本 CMD 颜色 文件名含 \u0026amp;  1. 打开记事本 C:\\Users\\York\u0026gt;notepad\rC:\\Users\\York\u0026gt;notepad hello.py\r2. 更改 CMD 背景颜色  命令：C:\\Users\\York\u0026gt;color f0 重启失效  3. 文件中出现 \u0026amp;  在命令行运行的文件，若文件名中包含 \u0026amp;，需要加引号  D:\\test\u0026gt;nvim \u0026quot;t\u0026amp;t\u0026quot;.py\rD:\\test\u0026gt;nvim \u0026quot;t\u0026amp;t.py\u0026quot;\rD:\\test\u0026gt;python \u0026quot;t\u0026amp;t.py\u0026quot;\rtest\rD:\\test\u0026gt;\r","description":"","id":155,"section":"blog","tags":["dos"],"title":"几条 DOS 命令","uri":"https://yorkfish.github.io/review/blog/03_dos_command/"},{"content":"1. 二进制转十进制 例一 0b101.11  整数部分：1 * 22 + 0 * 21 + 1 * 20 小数部分：1 * 2-1 + 1 * 2-2   0b101.11 = 4 + 1 + 0.5 + 0.25 = 5.75  2. 十进制转二进制 例二 0.125   0.125 * 2 = 0.25, 取整数部分 0\n  0.25 * 2 = 0.5, 取整数部分 0\n  0.5 * 2 = 1, 取整数部分 1（到 1 为止）\n  0.125 = 0b0.001\n  例三 0.6875   0.6875 * 2 = 1.375, 取整数部分 1（整数取走就剩 0.375 了）\n  0.375 * 2 = 0.75, 取整数部分 0\n  0.75 * 2 = 1.5, 取整数部分 1\n  0.5 * 2 = 1, 取整数部分 1\n  0.6875 = 0b0.1011\n ","description":"","id":156,"section":"blog","tags":["basics"],"title":"进制转换","uri":"https://yorkfish.github.io/review/blog/02_binary-decimal_conversion/"},{"content":"1. 拷贝文档  在 content 文件夹下新建 blog 文件夹 将 root/themes/zdoc/exampleSite/content/en/blog/_index.md 拷贝过来  2. 新建文档   在 blog 文件夹下新建文档\n  在文档开头写入如下语句\n+++\rauthor = \u0026quot;YorkFish\u0026quot;\rtitle = \u0026quot;Usage\u0026quot;\rdate = \u0026quot;2020-09-10\u0026quot;\r# description = \u0026quot;zdoc blog quick start\u0026quot;\rtags = [\r\u0026quot;zdoc\u0026quot;,\r]\rimage = \u0026quot;\u0026quot;\r+++\r  3. 修改配置文件   打开 root/config/_default/menus.zh.toml\n  在合适的位置加入如下语句\n[[main]]\ridentifier = \u0026quot;blog\u0026quot;\rname = \u0026quot;Blog\u0026quot;\rurl = \u0026quot;blog\u0026quot;\rweight = 3\r  修改几个 weight 值\n ","description":"","id":157,"section":"blog","tags":["zdoc"],"title":"Usage","uri":"https://yorkfish.github.io/review/blog/01_usage/"},{"content":"1. 简介  博客：不求全，方便回忆 本人：野生的，菜鸟一只  2. 参考与感谢   C\n “谭爷爷”的绿皮书    Python\n 莫烦Python(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门 棋子、棋子(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门 DavyCloud(Bilibili\u0026rsquo;s up) \u0026gt;\u0026gt;\u0026gt; 传送门    ","description":"YorkFish about page","id":158,"section":"","tags":null,"title":"About","uri":"https://yorkfish.github.io/review/about/"}]